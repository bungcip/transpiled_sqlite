#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut)]
#![feature(c_variadic, extern_types, label_break_value)]
use ::c2rust_out::*;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type sqlite3;
    pub type sqlite3_api_routines;
    pub type sqlite3_stmt;
    pub type sqlite3_value;
    pub type sqlite3_context;
    pub type sqlite3_str;
    pub type sqlite3_backup;
    pub type __dirstream;
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn rewind(__stream: *mut FILE);
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
    fn sqlite3_libversion() -> *const libc::c_char;
    fn sqlite3_sourceid() -> *const libc::c_char;
    fn sqlite3_libversion_number() -> libc::c_int;
    fn sqlite3_close(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_exec(
        _: *mut sqlite3,
        sql: *const libc::c_char,
        callback_0: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *mut *mut libc::c_char,
                *mut *mut libc::c_char,
            ) -> libc::c_int,
        >,
        _: *mut libc::c_void,
        errmsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_initialize() -> libc::c_int;
    fn sqlite3_config(_: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_db_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_total_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_interrupt(_: *mut sqlite3);
    fn sqlite3_complete(sql: *const libc::c_char) -> libc::c_int;
    fn sqlite3_busy_timeout(_: *mut sqlite3, ms: libc::c_int) -> libc::c_int;
    fn sqlite3_mprintf(_: *const libc::c_char, _: ...) -> *mut libc::c_char;
    fn sqlite3_vmprintf(
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_snprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ...
    ) -> *mut libc::c_char;
    fn sqlite3_vsnprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_malloc(_: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_malloc64(_: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_realloc(_: *mut libc::c_void, _: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_realloc64(_: *mut libc::c_void, _: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_free(_: *mut libc::c_void);
    fn sqlite3_randomness(N: libc::c_int, P: *mut libc::c_void);
    fn sqlite3_set_authorizer(
        _: *mut sqlite3,
        xAuth: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *const libc::c_char,
                *const libc::c_char,
                *const libc::c_char,
                *const libc::c_char,
            ) -> libc::c_int,
        >,
        pUserData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_trace_v2(
        _: *mut sqlite3,
        uMask: libc::c_uint,
        xCallback: Option::<
            unsafe extern "C" fn(
                libc::c_uint,
                *mut libc::c_void,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        pCtx: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_progress_handler(
        _: *mut sqlite3,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
        _: *mut libc::c_void,
    );
    fn sqlite3_open(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
    ) -> libc::c_int;
    fn sqlite3_open_v2(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
        flags: libc::c_int,
        zVfs: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_extended_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_errmsg(_: *mut sqlite3) -> *const libc::c_char;
    fn sqlite3_error_offset(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_limit(
        _: *mut sqlite3,
        id: libc::c_int,
        newVal: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_prepare_v2(
        db: *mut sqlite3,
        zSql: *const libc::c_char,
        nByte: libc::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const libc::c_char;
    fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut libc::c_char;
    fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_blob(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_void,
        n: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_double(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: libc::c_double,
    ) -> libc::c_int;
    fn sqlite3_bind_int(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_bind_int64(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: sqlite3_int64,
    ) -> libc::c_int;
    fn sqlite3_bind_null(_: *mut sqlite3_stmt, _: libc::c_int) -> libc::c_int;
    fn sqlite3_bind_text(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_value(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const sqlite3_value,
    ) -> libc::c_int;
    fn sqlite3_bind_parameter_count(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_parameter_name(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_name(_: *mut sqlite3_stmt, N: libc::c_int) -> *const libc::c_char;
    fn sqlite3_column_decltype(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_step(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_blob(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *const libc::c_void;
    fn sqlite3_column_double(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_double;
    fn sqlite3_column_int(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_int64(_: *mut sqlite3_stmt, iCol: libc::c_int) -> sqlite3_int64;
    fn sqlite3_column_text(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *const libc::c_uchar;
    fn sqlite3_column_value(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *mut sqlite3_value;
    fn sqlite3_column_bytes(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_type(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_create_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xFunc: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xStep: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_create_window_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xStep: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
        xValue: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
        xInverse: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xDestroy: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_value_blob(_: *mut sqlite3_value) -> *const libc::c_void;
    fn sqlite3_value_double(_: *mut sqlite3_value) -> libc::c_double;
    fn sqlite3_value_int(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_int64(_: *mut sqlite3_value) -> sqlite3_int64;
    fn sqlite3_value_text(_: *mut sqlite3_value) -> *const libc::c_uchar;
    fn sqlite3_value_bytes(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_type(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_aggregate_context(
        _: *mut sqlite3_context,
        nBytes: libc::c_int,
    ) -> *mut libc::c_void;
    fn sqlite3_user_data(_: *mut sqlite3_context) -> *mut libc::c_void;
    fn sqlite3_context_db_handle(_: *mut sqlite3_context) -> *mut sqlite3;
    fn sqlite3_get_auxdata(_: *mut sqlite3_context, N: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_set_auxdata(
        _: *mut sqlite3_context,
        N: libc::c_int,
        _: *mut libc::c_void,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob64(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: sqlite3_uint64,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_double(_: *mut sqlite3_context, _: libc::c_double);
    fn sqlite3_result_error(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
    );
    fn sqlite3_result_error_nomem(_: *mut sqlite3_context);
    fn sqlite3_result_error_code(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int64(_: *mut sqlite3_context, _: sqlite3_int64);
    fn sqlite3_result_null(_: *mut sqlite3_context);
    fn sqlite3_result_text(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_text64(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: sqlite3_uint64,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        encoding: libc::c_uchar,
    );
    fn sqlite3_result_value(_: *mut sqlite3_context, _: *mut sqlite3_value);
    fn sqlite3_create_collation(
        _: *mut sqlite3,
        zName: *const libc::c_char,
        eTextRep: libc::c_int,
        pArg: *mut libc::c_void,
        xCompare: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *const libc::c_void,
                libc::c_int,
                *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
    fn sqlite3_sleep(_: libc::c_int) -> libc::c_int;
    fn sqlite3_get_autocommit(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_db_handle(_: *mut sqlite3_stmt) -> *mut sqlite3;
    fn sqlite3_db_readonly(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_txn_state(_: *mut sqlite3, zSchema: *const libc::c_char) -> libc::c_int;
    fn sqlite3_table_column_metadata(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
        zTableName: *const libc::c_char,
        zColumnName: *const libc::c_char,
        pzDataType: *mut *const libc::c_char,
        pzCollSeq: *mut *const libc::c_char,
        pNotNull: *mut libc::c_int,
        pPrimaryKey: *mut libc::c_int,
        pAutoinc: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_load_extension(
        db: *mut sqlite3,
        zFile: *const libc::c_char,
        zProc: *const libc::c_char,
        pzErrMsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_enable_load_extension(
        db: *mut sqlite3,
        onoff: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_create_module(
        db: *mut sqlite3,
        zName: *const libc::c_char,
        p: *const sqlite3_module,
        pClientData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_declare_vtab(_: *mut sqlite3, zSQL: *const libc::c_char) -> libc::c_int;
    fn sqlite3_vfs_find(zVfsName: *const libc::c_char) -> *mut sqlite3_vfs;
    fn sqlite3_vfs_register(_: *mut sqlite3_vfs, makeDflt: libc::c_int) -> libc::c_int;
    fn sqlite3_file_control(
        _: *mut sqlite3,
        zDbName: *const libc::c_char,
        op: libc::c_int,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_test_control(op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_keyword_count() -> libc::c_int;
    fn sqlite3_keyword_name(
        _: libc::c_int,
        _: *mut *const libc::c_char,
        _: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_keyword_check(_: *const libc::c_char, _: libc::c_int) -> libc::c_int;
    fn sqlite3_str_new(_: *mut sqlite3) -> *mut sqlite3_str;
    fn sqlite3_str_finish(_: *mut sqlite3_str) -> *mut libc::c_char;
    fn sqlite3_str_appendf(_: *mut sqlite3_str, zFormat: *const libc::c_char, _: ...);
    fn sqlite3_str_append(_: *mut sqlite3_str, zIn: *const libc::c_char, N: libc::c_int);
    fn sqlite3_str_appendall(_: *mut sqlite3_str, zIn: *const libc::c_char);
    fn sqlite3_status64(
        op: libc::c_int,
        pCurrent: *mut sqlite3_int64,
        pHighwater: *mut sqlite3_int64,
        resetFlag: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_db_status(
        _: *mut sqlite3,
        op: libc::c_int,
        pCur: *mut libc::c_int,
        pHiwtr: *mut libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_stmt_status(
        _: *mut sqlite3_stmt,
        op: libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_backup_init(
        pDest: *mut sqlite3,
        zDestName: *const libc::c_char,
        pSource: *mut sqlite3,
        zSourceName: *const libc::c_char,
    ) -> *mut sqlite3_backup;
    fn sqlite3_backup_step(p: *mut sqlite3_backup, nPage: libc::c_int) -> libc::c_int;
    fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> libc::c_int;
    fn sqlite3_stricmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn sqlite3_strnicmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_strglob(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_strlike(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
        cEsc: libc::c_uint,
    ) -> libc::c_int;
    fn sqlite3_vtab_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_vtab_collation(
        _: *mut sqlite3_index_info,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_deserialize(
        db: *mut sqlite3,
        zSchema: *const libc::c_char,
        pData: *mut libc::c_uchar,
        szDb: sqlite3_int64,
        szBuf: sqlite3_int64,
        mFlags: libc::c_uint,
    ) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn tolower(_: libc::c_int) -> libc::c_int;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn raise(__sig: libc::c_int) -> libc::c_int;
    fn getpwuid(__uid: __uid_t) -> *mut passwd;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn chdir(__path: *const libc::c_char) -> libc::c_int;
    fn getpid() -> __pid_t;
    fn getuid() -> __uid_t;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
    fn readlink(
        __path: *const libc::c_char,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> ssize_t;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn opendir(__name: *const libc::c_char) -> *mut DIR;
    fn closedir(__dirp: *mut DIR) -> libc::c_int;
    fn readdir(__dirp: *mut DIR) -> *mut dirent;
    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
    fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
    fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> libc::c_int;
    fn time(__timer: *mut time_t) -> time_t;
    fn __errno_location() -> *mut libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type sqlite_int64 = libc::c_longlong;
pub type sqlite_uint64 = libc::c_ulonglong;
pub type sqlite3_int64 = sqlite_int64;
pub type sqlite3_uint64 = sqlite_uint64;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_file {
    pub pMethods: *const sqlite3_io_methods,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_io_methods {
    pub iVersion: libc::c_int,
    pub xClose: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int>,
    pub xRead: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            *mut libc::c_void,
            libc::c_int,
            sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xWrite: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            *const libc::c_void,
            libc::c_int,
            sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xTruncate: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, sqlite3_int64) -> libc::c_int,
    >,
    pub xSync: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xFileSize: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xLock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xUnlock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xCheckReservedLock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, *mut libc::c_int) -> libc::c_int,
    >,
    pub xFileControl: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xSectorSize: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int>,
    pub xDeviceCharacteristics: Option::<
        unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
    >,
    pub xShmMap: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xShmLock: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xShmBarrier: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> ()>,
    pub xShmUnmap: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xFetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            sqlite3_int64,
            libc::c_int,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xUnfetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            sqlite3_int64,
            *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vfs {
    pub iVersion: libc::c_int,
    pub szOsFile: libc::c_int,
    pub mxPathname: libc::c_int,
    pub pNext: *mut sqlite3_vfs,
    pub zName: *const libc::c_char,
    pub pAppData: *mut libc::c_void,
    pub xOpen: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            *mut sqlite3_file,
            libc::c_int,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub xDelete: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xAccess: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub xFullPathname: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xDlOpen: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *const libc::c_char) -> *mut libc::c_void,
    >,
    pub xDlError: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int, *mut libc::c_char) -> (),
    >,
    pub xDlSym: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *mut libc::c_void,
            *const libc::c_char,
        ) -> Option::<unsafe extern "C" fn() -> ()>,
    >,
    pub xDlClose: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_void) -> (),
    >,
    pub xRandomness: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xSleep: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int) -> libc::c_int,
    >,
    pub xCurrentTime: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_double) -> libc::c_int,
    >,
    pub xGetLastError: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xCurrentTimeInt64: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xSetSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            sqlite3_syscall_ptr,
        ) -> libc::c_int,
    >,
    pub xGetSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
        ) -> sqlite3_syscall_ptr,
    >,
    pub xNextSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
        ) -> *const libc::c_char,
    >,
}
pub type sqlite3_syscall_ptr = Option::<unsafe extern "C" fn() -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_mem_methods {
    pub xMalloc: Option::<unsafe extern "C" fn(libc::c_int) -> *mut libc::c_void>,
    pub xFree: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub xRealloc: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> *mut libc::c_void,
    >,
    pub xSize: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xRoundup: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub xInit: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xShutdown: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub pAppData: *mut libc::c_void,
}
pub type sqlite3_destructor_type = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab {
    pub pModule: *const sqlite3_module,
    pub nRef: libc::c_int,
    pub zErrMsg: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_module {
    pub iVersion: libc::c_int,
    pub xCreate: Option::<
        unsafe extern "C" fn(
            *mut sqlite3,
            *mut libc::c_void,
            libc::c_int,
            *const *const libc::c_char,
            *mut *mut sqlite3_vtab,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xConnect: Option::<
        unsafe extern "C" fn(
            *mut sqlite3,
            *mut libc::c_void,
            libc::c_int,
            *const *const libc::c_char,
            *mut *mut sqlite3_vtab,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xBestIndex: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, *mut sqlite3_index_info) -> libc::c_int,
    >,
    pub xDisconnect: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xDestroy: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xOpen: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            *mut *mut sqlite3_vtab_cursor,
        ) -> libc::c_int,
    >,
    pub xClose: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xFilter: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab_cursor,
            libc::c_int,
            *const libc::c_char,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> libc::c_int,
    >,
    pub xNext: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xEof: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xColumn: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab_cursor,
            *mut sqlite3_context,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xRowid: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab_cursor, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xUpdate: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            libc::c_int,
            *mut *mut sqlite3_value,
            *mut sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xBegin: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xSync: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xCommit: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xRollback: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xFindFunction: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            libc::c_int,
            *const libc::c_char,
            *mut Option::<
                unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
            >,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xRename: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, *const libc::c_char) -> libc::c_int,
    >,
    pub xSavepoint: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xRelease: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xRollbackTo: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xShadowName: Option::<unsafe extern "C" fn(*const libc::c_char) -> libc::c_int>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab_cursor {
    pub pVtab: *mut sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_info {
    pub nConstraint: libc::c_int,
    pub aConstraint: *mut sqlite3_index_constraint,
    pub nOrderBy: libc::c_int,
    pub aOrderBy: *mut sqlite3_index_orderby,
    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
    pub idxNum: libc::c_int,
    pub idxStr: *mut libc::c_char,
    pub needToFreeIdxStr: libc::c_int,
    pub orderByConsumed: libc::c_int,
    pub estimatedCost: libc::c_double,
    pub estimatedRows: sqlite3_int64,
    pub idxFlags: libc::c_int,
    pub colUsed: sqlite3_uint64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint_usage {
    pub argvIndex: libc::c_int,
    pub omit: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_orderby {
    pub iColumn: libc::c_int,
    pub desc: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint {
    pub iColumn: libc::c_int,
    pub op: libc::c_uchar,
    pub usable: libc::c_uchar,
    pub iTermOffset: libc::c_int,
}
pub type i64_0 = sqlite3_int64;
pub type u64_0 = sqlite3_uint64;
pub type u8_0 = libc::c_uchar;
pub type C2RustUnnamed = libc::c_uint;
pub const _ISalnum: C2RustUnnamed = 8;
pub const _ISpunct: C2RustUnnamed = 4;
pub const _IScntrl: C2RustUnnamed = 2;
pub const _ISblank: C2RustUnnamed = 1;
pub const _ISgraph: C2RustUnnamed = 32768;
pub const _ISprint: C2RustUnnamed = 16384;
pub const _ISspace: C2RustUnnamed = 8192;
pub const _ISxdigit: C2RustUnnamed = 4096;
pub const _ISdigit: C2RustUnnamed = 2048;
pub const _ISalpha: C2RustUnnamed = 1024;
pub const _ISlower: C2RustUnnamed = 512;
pub const _ISupper: C2RustUnnamed = 256;
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct passwd {
    pub pw_name: *mut libc::c_char,
    pub pw_passwd: *mut libc::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut libc::c_char,
    pub pw_dir: *mut libc::c_char,
    pub pw_shell: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dirent {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: libc::c_ushort,
    pub d_type: libc::c_uchar,
    pub d_name: [libc::c_char; 256],
}
pub type DIR = __dirstream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type __rusage_who = libc::c_int;
pub const RUSAGE_CHILDREN: __rusage_who = -1;
pub const RUSAGE_SELF: __rusage_who = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub c2rust_unnamed: C2RustUnnamed_13,
    pub c2rust_unnamed_0: C2RustUnnamed_12,
    pub c2rust_unnamed_1: C2RustUnnamed_11,
    pub c2rust_unnamed_2: C2RustUnnamed_10,
    pub c2rust_unnamed_3: C2RustUnnamed_9,
    pub c2rust_unnamed_4: C2RustUnnamed_8,
    pub c2rust_unnamed_5: C2RustUnnamed_7,
    pub c2rust_unnamed_6: C2RustUnnamed_6,
    pub c2rust_unnamed_7: C2RustUnnamed_5,
    pub c2rust_unnamed_8: C2RustUnnamed_4,
    pub c2rust_unnamed_9: C2RustUnnamed_3,
    pub c2rust_unnamed_10: C2RustUnnamed_2,
    pub c2rust_unnamed_11: C2RustUnnamed_1,
    pub c2rust_unnamed_12: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub ru_nivcsw: libc::c_long,
    pub __ru_nivcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub ru_nvcsw: libc::c_long,
    pub __ru_nvcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub ru_nsignals: libc::c_long,
    pub __ru_nsignals_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub ru_msgrcv: libc::c_long,
    pub __ru_msgrcv_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub ru_msgsnd: libc::c_long,
    pub __ru_msgsnd_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub ru_oublock: libc::c_long,
    pub __ru_oublock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub ru_inblock: libc::c_long,
    pub __ru_inblock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub ru_nswap: libc::c_long,
    pub __ru_nswap_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub ru_majflt: libc::c_long,
    pub __ru_majflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub ru_minflt: libc::c_long,
    pub __ru_minflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub ru_isrss: libc::c_long,
    pub __ru_isrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub ru_idrss: libc::c_long,
    pub __ru_idrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_12 {
    pub ru_ixrss: libc::c_long,
    pub __ru_ixrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub ru_maxrss: libc::c_long,
    pub __ru_maxrss_word: __syscall_slong_t,
}
pub type __rusage_who_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub zSuffix: *mut libc::c_char,
    pub iMult: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellText {
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SHA3Context {
    pub u: C2RustUnnamed_15,
    pub nRate: libc::c_uint,
    pub nLoaded: libc::c_uint,
    pub ixMask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub s: [u64_0; 25],
    pub x: [libc::c_uchar; 1600],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Decimal {
    pub sign: libc::c_char,
    pub oom: libc::c_char,
    pub isNull: libc::c_char,
    pub isInit: libc::c_char,
    pub nDigit: libc::c_int,
    pub nFrac: libc::c_int,
    pub a: *mut libc::c_schar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub zFuncName: *const libc::c_char,
    pub nArg: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub zFName: *mut libc::c_char,
    pub nArg: libc::c_int,
    pub iAux: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct series_cursor {
    pub base: sqlite3_vtab_cursor,
    pub isDesc: libc::c_int,
    pub iRowid: sqlite3_int64,
    pub iValue: sqlite3_int64,
    pub mnValue: sqlite3_int64,
    pub mxValue: sqlite3_int64,
    pub iStep: sqlite3_int64,
}
pub type ReStateNumber = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReStateSet {
    pub nState: libc::c_uint,
    pub aState: *mut ReStateNumber,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReInput {
    pub z: *const libc::c_uchar,
    pub i: libc::c_int,
    pub mx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReCompiled {
    pub sIn: ReInput,
    pub zErr: *const libc::c_char,
    pub aOp: *mut libc::c_char,
    pub aArg: *mut libc::c_int,
    pub xNextChar: Option::<unsafe extern "C" fn(*mut ReInput) -> libc::c_uint>,
    pub zInit: [libc::c_uchar; 12],
    pub nInit: libc::c_int,
    pub nState: libc::c_uint,
    pub nAlloc: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_cursor {
    pub base: sqlite3_vtab_cursor,
    pub nLvl: libc::c_int,
    pub iLvl: libc::c_int,
    pub aLvl: *mut FsdirLevel,
    pub zBase: *const libc::c_char,
    pub nBase: libc::c_int,
    pub sStat: stat,
    pub zPath: *mut libc::c_char,
    pub iRowid: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FsdirLevel {
    pub pDir: *mut DIR,
    pub zDir: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_tab {
    pub base: sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_vtab {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_cursor {
    pub base: sqlite3_vtab_cursor,
    pub db: *mut sqlite3,
    pub nPrefix: libc::c_int,
    pub nLine: libc::c_int,
    pub zPrefix: *mut libc::c_char,
    pub zLine: *mut libc::c_char,
    pub zCurrentRow: *const libc::c_char,
    pub szRow: libc::c_int,
    pub pStmt: *mut sqlite3_stmt,
    pub iRowid: sqlite3_int64,
    pub ePhase: libc::c_int,
    pub j: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ApndFile {
    pub base: sqlite3_file,
    pub iPgOne: sqlite3_int64,
    pub iMark: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3expert {
    pub iSample: libc::c_int,
    pub db: *mut sqlite3,
    pub dbm: *mut sqlite3,
    pub dbv: *mut sqlite3,
    pub pTable: *mut IdxTable,
    pub pScan: *mut IdxScan,
    pub pWrite: *mut IdxWrite,
    pub pStatement: *mut IdxStatement,
    pub bRun: libc::c_int,
    pub pzErrmsg: *mut *mut libc::c_char,
    pub rc: libc::c_int,
    pub hIdx: IdxHash,
    pub zCandidates: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHash {
    pub pFirst: *mut IdxHashEntry,
    pub aHash: [*mut IdxHashEntry; 1023],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHashEntry {
    pub zKey: *mut libc::c_char,
    pub zVal: *mut libc::c_char,
    pub zVal2: *mut libc::c_char,
    pub pHashNext: *mut IdxHashEntry,
    pub pNext: *mut IdxHashEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxStatement {
    pub iId: libc::c_int,
    pub zSql: *mut libc::c_char,
    pub zIdx: *mut libc::c_char,
    pub zEQP: *mut libc::c_char,
    pub pNext: *mut IdxStatement,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxWrite {
    pub pTab: *mut IdxTable,
    pub eOp: libc::c_int,
    pub pNext: *mut IdxWrite,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxTable {
    pub nCol: libc::c_int,
    pub zName: *mut libc::c_char,
    pub aCol: *mut IdxColumn,
    pub pNext: *mut IdxTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxColumn {
    pub zName: *mut libc::c_char,
    pub zColl: *mut libc::c_char,
    pub iPk: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxScan {
    pub pTab: *mut IdxTable,
    pub iDb: libc::c_int,
    pub covering: i64_0,
    pub pOrder: *mut IdxConstraint,
    pub pEq: *mut IdxConstraint,
    pub pRange: *mut IdxConstraint,
    pub pNextScan: *mut IdxScan,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxConstraint {
    pub zColl: *mut libc::c_char,
    pub bRange: libc::c_int,
    pub iCol: libc::c_int,
    pub bFlag: libc::c_int,
    pub bDesc: libc::c_int,
    pub pNext: *mut IdxConstraint,
    pub pLink: *mut IdxConstraint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertCsr {
    pub base: sqlite3_vtab_cursor,
    pub pData: *mut sqlite3_stmt,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertVtab {
    pub base: sqlite3_vtab,
    pub pTab: *mut IdxTable,
    pub pExpert: *mut sqlite3expert,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemCtx {
    pub nSlot: libc::c_int,
    pub aSlot: [IdxRemSlot; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemSlot {
    pub eType: libc::c_int,
    pub iVal: i64_0,
    pub rVal: libc::c_double,
    pub nByte: libc::c_int,
    pub n: libc::c_int,
    pub z: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxSampleCtx {
    pub iTarget: libc::c_int,
    pub target: libc::c_double,
    pub nRow: libc::c_double,
    pub nRet: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertInfo {
    pub pExpert: *mut sqlite3expert,
    pub bVerbose: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraphRow {
    pub iEqpId: libc::c_int,
    pub iParentId: libc::c_int,
    pub pNext: *mut EQPGraphRow,
    pub zText: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraph {
    pub pRow: *mut EQPGraphRow,
    pub pLast: *mut EQPGraphRow,
    pub zPrefix: [libc::c_char; 100],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColModeOpts {
    pub iWrap: libc::c_int,
    pub bQuote: u8_0,
    pub bWordWrap: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellState {
    pub db: *mut sqlite3,
    pub autoExplain: u8_0,
    pub autoEQP: u8_0,
    pub autoEQPtest: u8_0,
    pub autoEQPtrace: u8_0,
    pub scanstatsOn: u8_0,
    pub openMode: u8_0,
    pub doXdgOpen: u8_0,
    pub nEqpLevel: u8_0,
    pub eTraceType: u8_0,
    pub bSafeMode: u8_0,
    pub bSafeModePersist: u8_0,
    pub cmOpts: ColModeOpts,
    pub statsOn: libc::c_uint,
    pub mEqpLines: libc::c_uint,
    pub inputNesting: libc::c_int,
    pub outCount: libc::c_int,
    pub cnt: libc::c_int,
    pub lineno: libc::c_int,
    pub openFlags: libc::c_int,
    pub in_0: *mut FILE,
    pub out: *mut FILE,
    pub traceOut: *mut FILE,
    pub nErr: libc::c_int,
    pub mode: libc::c_int,
    pub modePrior: libc::c_int,
    pub cMode: libc::c_int,
    pub normalMode: libc::c_int,
    pub writableSchema: libc::c_int,
    pub showHeader: libc::c_int,
    pub nCheck: libc::c_int,
    pub nProgress: libc::c_uint,
    pub mxProgress: libc::c_uint,
    pub flgProgress: libc::c_uint,
    pub shellFlgs: libc::c_uint,
    pub priorShFlgs: libc::c_uint,
    pub szMax: sqlite3_int64,
    pub zDestTable: *mut libc::c_char,
    pub zTempFile: *mut libc::c_char,
    pub zTestcase: [libc::c_char; 30],
    pub colSeparator: [libc::c_char; 20],
    pub rowSeparator: [libc::c_char; 20],
    pub colSepPrior: [libc::c_char; 20],
    pub rowSepPrior: [libc::c_char; 20],
    pub colWidth: *mut libc::c_int,
    pub actualWidth: *mut libc::c_int,
    pub nWidth: libc::c_int,
    pub nullValue: [libc::c_char; 20],
    pub outfile: [libc::c_char; 4096],
    pub pStmt: *mut sqlite3_stmt,
    pub pLog: *mut FILE,
    pub aAuxDb: [AuxDb; 5],
    pub pAuxDb: *mut AuxDb,
    pub aiIndent: *mut libc::c_int,
    pub nIndent: libc::c_int,
    pub iIndent: libc::c_int,
    pub zNonce: *mut libc::c_char,
    pub sGraph: EQPGraph,
    pub expert: ExpertInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AuxDb {
    pub db: *mut sqlite3,
    pub zDbFilename: *const libc::c_char,
    pub zFreeOnClose: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub zPattern: *const libc::c_char,
    pub zDesc: *const libc::c_char,
}
pub type QuickScanState = libc::c_uint;
pub const QSS_Start: QuickScanState = 0;
pub const QSS_ScanMask: QuickScanState = 768;
pub const QSS_CharMask: QuickScanState = 255;
pub const QSS_EndingSemi: QuickScanState = 512;
pub const QSS_HasDark: QuickScanState = 256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub unSafe: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub zLimitName: *const libc::c_char,
    pub limitCode: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ImportCtx {
    pub zFile: *const libc::c_char,
    pub in_0: *mut FILE,
    pub xCloser: Option::<unsafe extern "C" fn(*mut FILE) -> libc::c_int>,
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
    pub nLine: libc::c_int,
    pub nRow: libc::c_int,
    pub nErr: libc::c_int,
    pub bNotFirst: libc::c_int,
    pub cTerm: libc::c_int,
    pub cColSep: libc::c_int,
    pub cRowSep: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbConfigChoices {
    pub zName: *const libc::c_char,
    pub op: libc::c_int,
}
static mut enableTimer: libc::c_int = 0 as libc::c_int;
unsafe extern "C" fn timeOfDay() -> sqlite3_int64 {
    static mut clockVfs: *mut sqlite3_vfs = 0 as *const sqlite3_vfs as *mut sqlite3_vfs;
    let mut t: sqlite3_int64 = 0;
    if clockVfs.is_null() {
        clockVfs = sqlite3_vfs_find(0 as *const libc::c_char);
    }
    if clockVfs.is_null() {
        return 0 as libc::c_int as sqlite3_int64;
    }
    if (*clockVfs).iVersion >= 2 as libc::c_int
        && ((*clockVfs).xCurrentTimeInt64).is_some()
    {
        ((*clockVfs).xCurrentTimeInt64)
            .expect("non-null function pointer")(clockVfs, &mut t);
    } else {
        let mut r: libc::c_double = 0.;
        ((*clockVfs).xCurrentTime).expect("non-null function pointer")(clockVfs, &mut r);
        t = (r * 86400000.0f64) as sqlite3_int64;
    }
    return t;
}
static mut sBegin: rusage = rusage {
    ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
    ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
    c2rust_unnamed: C2RustUnnamed_13 { ru_maxrss: 0 },
    c2rust_unnamed_0: C2RustUnnamed_12 { ru_ixrss: 0 },
    c2rust_unnamed_1: C2RustUnnamed_11 { ru_idrss: 0 },
    c2rust_unnamed_2: C2RustUnnamed_10 { ru_isrss: 0 },
    c2rust_unnamed_3: C2RustUnnamed_9 { ru_minflt: 0 },
    c2rust_unnamed_4: C2RustUnnamed_8 { ru_majflt: 0 },
    c2rust_unnamed_5: C2RustUnnamed_7 { ru_nswap: 0 },
    c2rust_unnamed_6: C2RustUnnamed_6 { ru_inblock: 0 },
    c2rust_unnamed_7: C2RustUnnamed_5 { ru_oublock: 0 },
    c2rust_unnamed_8: C2RustUnnamed_4 { ru_msgsnd: 0 },
    c2rust_unnamed_9: C2RustUnnamed_3 { ru_msgrcv: 0 },
    c2rust_unnamed_10: C2RustUnnamed_2 { ru_nsignals: 0 },
    c2rust_unnamed_11: C2RustUnnamed_1 { ru_nvcsw: 0 },
    c2rust_unnamed_12: C2RustUnnamed_0 { ru_nivcsw: 0 },
};
static mut iBegin: sqlite3_int64 = 0;
unsafe extern "C" fn beginTimer() {
    if enableTimer != 0 {
        getrusage(RUSAGE_SELF as libc::c_int, &mut sBegin);
        iBegin = timeOfDay();
    }
}
unsafe extern "C" fn timeDiff(
    mut pStart: *mut timeval,
    mut pEnd: *mut timeval,
) -> libc::c_double {
    return ((*pEnd).tv_usec - (*pStart).tv_usec) as libc::c_double * 0.000001f64
        + ((*pEnd).tv_sec - (*pStart).tv_sec) as libc::c_double;
}
unsafe extern "C" fn endTimer() {
    if enableTimer != 0 {
        let mut iEnd: sqlite3_int64 = timeOfDay();
        let mut sEnd: rusage = rusage {
            ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
            ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
            c2rust_unnamed: C2RustUnnamed_13 { ru_maxrss: 0 },
            c2rust_unnamed_0: C2RustUnnamed_12 { ru_ixrss: 0 },
            c2rust_unnamed_1: C2RustUnnamed_11 { ru_idrss: 0 },
            c2rust_unnamed_2: C2RustUnnamed_10 { ru_isrss: 0 },
            c2rust_unnamed_3: C2RustUnnamed_9 { ru_minflt: 0 },
            c2rust_unnamed_4: C2RustUnnamed_8 { ru_majflt: 0 },
            c2rust_unnamed_5: C2RustUnnamed_7 { ru_nswap: 0 },
            c2rust_unnamed_6: C2RustUnnamed_6 { ru_inblock: 0 },
            c2rust_unnamed_7: C2RustUnnamed_5 { ru_oublock: 0 },
            c2rust_unnamed_8: C2RustUnnamed_4 { ru_msgsnd: 0 },
            c2rust_unnamed_9: C2RustUnnamed_3 { ru_msgrcv: 0 },
            c2rust_unnamed_10: C2RustUnnamed_2 { ru_nsignals: 0 },
            c2rust_unnamed_11: C2RustUnnamed_1 { ru_nvcsw: 0 },
            c2rust_unnamed_12: C2RustUnnamed_0 { ru_nivcsw: 0 },
        };
        getrusage(RUSAGE_SELF as libc::c_int, &mut sEnd);
        printf(
            b"Run Time: real %.3f user %f sys %f\n\0" as *const u8
                as *const libc::c_char,
            (iEnd - iBegin) as libc::c_double * 0.001f64,
            timeDiff(&mut sBegin.ru_utime, &mut sEnd.ru_utime),
            timeDiff(&mut sBegin.ru_stime, &mut sEnd.ru_stime),
        );
    }
}
static mut bail_on_error: libc::c_int = 0 as libc::c_int;
static mut stdin_is_interactive: libc::c_int = 1 as libc::c_int;
static mut stdout_is_console: libc::c_int = 1 as libc::c_int;
static mut globalDb: *mut sqlite3 = 0 as *const sqlite3 as *mut sqlite3;
static mut seenInterrupt: libc::c_int = 0 as libc::c_int;
static mut Argv0: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
static mut mainPrompt: [libc::c_char; 20] = [0; 20];
static mut continuePrompt: [libc::c_char; 20] = [0; 20];
unsafe extern "C" fn shell_out_of_memory() {
    fprintf(stderr, b"Error: out of memory\n\0" as *const u8 as *const libc::c_char);
    exit(1 as libc::c_int);
}
unsafe extern "C" fn shell_check_oom(mut p: *mut libc::c_void) {
    if p.is_null() {
        shell_out_of_memory();
    }
}
unsafe extern "C" fn utf8_width_print(
    mut pOut: *mut FILE,
    mut w: libc::c_int,
    mut zUtf: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut aw: libc::c_int = if w < 0 as libc::c_int { -w } else { w };
    n = 0 as libc::c_int;
    i = n;
    while *zUtf.offset(i as isize) != 0 {
        if *zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
            != 0x80 as libc::c_int
        {
            n += 1;
            if n == aw {
                loop {
                    i += 1;
                    if !(*zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                        == 0x80 as libc::c_int)
                    {
                        break;
                    }
                }
                break;
            }
        }
        i += 1;
    }
    if n >= aw {
        fprintf(pOut, b"%.*s\0" as *const u8 as *const libc::c_char, i, zUtf);
    } else if w < 0 as libc::c_int {
        fprintf(
            pOut,
            b"%*s%s\0" as *const u8 as *const libc::c_char,
            aw - n,
            b"\0" as *const u8 as *const libc::c_char,
            zUtf,
        );
    } else {
        fprintf(
            pOut,
            b"%s%*s\0" as *const u8 as *const libc::c_char,
            zUtf,
            aw - n,
            b"\0" as *const u8 as *const libc::c_char,
        );
    };
}
unsafe extern "C" fn isNumber(
    mut z: *const libc::c_char,
    mut realnum: *mut libc::c_int,
) -> libc::c_int {
    if *z as libc::c_int == '-' as i32 || *z as libc::c_int == '+' as i32 {
        z = z.offset(1);
    }
    if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
    {
        return 0 as libc::c_int;
    }
    z = z.offset(1);
    if !realnum.is_null() {
        *realnum = 0 as libc::c_int;
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        z = z.offset(1);
    }
    if *z as libc::c_int == '.' as i32 {
        z = z.offset(1);
        if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            return 0 as libc::c_int;
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1);
        }
        if !realnum.is_null() {
            *realnum = 1 as libc::c_int;
        }
    }
    if *z as libc::c_int == 'e' as i32 || *z as libc::c_int == 'E' as i32 {
        z = z.offset(1);
        if *z as libc::c_int == '+' as i32 || *z as libc::c_int == '-' as i32 {
            z = z.offset(1);
        }
        if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            return 0 as libc::c_int;
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1);
        }
        if !realnum.is_null() {
            *realnum = 1 as libc::c_int;
        }
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn strlen30(mut z: *const libc::c_char) -> libc::c_int {
    let mut z2: *const libc::c_char = z;
    while *z2 != 0 {
        z2 = z2.offset(1);
    }
    return 0x3fffffff as libc::c_int & z2.offset_from(z) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn strlenChar(mut z: *const libc::c_char) -> libc::c_int {
    let mut n: libc::c_int = 0 as libc::c_int;
    while *z != 0 {
        let fresh0 = z;
        z = z.offset(1);
        if 0xc0 as libc::c_int & *fresh0 as libc::c_int != 0x80 as libc::c_int {
            n += 1;
        }
    }
    return n;
}
unsafe extern "C" fn openChrSource(mut zFile: *const libc::c_char) -> *mut FILE {
    let mut x: stat = {
        let mut init = stat {
            st_dev: 0 as libc::c_int as __dev_t,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
            __glibc_reserved: [0; 3],
        };
        init
    };
    let mut rc: libc::c_int = stat(zFile, &mut x);
    if rc != 0 as libc::c_int {
        return 0 as *mut FILE;
    }
    if x.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o10000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o20000 as libc::c_int as libc::c_uint
    {
        return fopen(zFile, b"rb\0" as *const u8 as *const libc::c_char)
    } else {
        return 0 as *mut FILE
    };
}
unsafe extern "C" fn local_getline(
    mut zLine: *mut libc::c_char,
    mut in_0: *mut FILE,
) -> *mut libc::c_char {
    let mut nLine: libc::c_int = if zLine.is_null() {
        0 as libc::c_int
    } else {
        100 as libc::c_int
    };
    let mut n: libc::c_int = 0 as libc::c_int;
    loop {
        if n + 100 as libc::c_int > nLine {
            nLine = nLine * 2 as libc::c_int + 100 as libc::c_int;
            zLine = realloc(zLine as *mut libc::c_void, nLine as libc::c_ulong)
                as *mut libc::c_char;
            shell_check_oom(zLine as *mut libc::c_void);
        }
        if (fgets(&mut *zLine.offset(n as isize), nLine - n, in_0)).is_null() {
            if n == 0 as libc::c_int {
                free(zLine as *mut libc::c_void);
                return 0 as *mut libc::c_char;
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        } else {
            while *zLine.offset(n as isize) != 0 {
                n += 1;
            }
            if !(n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\n' as i32)
            {
                continue;
            }
            n -= 1;
            if n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\r' as i32
            {
                n -= 1;
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        }
    }
    return zLine;
}
unsafe extern "C" fn one_input_line(
    mut in_0: *mut FILE,
    mut zPrior: *mut libc::c_char,
    mut isContinuation: libc::c_int,
) -> *mut libc::c_char {
    let mut zPrompt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zResult: *mut libc::c_char = 0 as *mut libc::c_char;
    if !in_0.is_null() {
        zResult = local_getline(zPrior, in_0);
    } else {
        zPrompt = if isContinuation != 0 {
            continuePrompt.as_mut_ptr()
        } else {
            mainPrompt.as_mut_ptr()
        };
        printf(b"%s\0" as *const u8 as *const libc::c_char, zPrompt);
        fflush(stdout);
        zResult = local_getline(zPrior, stdin);
    }
    return zResult;
}
unsafe extern "C" fn hexDigitValue(mut c: libc::c_char) -> libc::c_int {
    if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
        return c as libc::c_int - '0' as i32;
    }
    if c as libc::c_int >= 'a' as i32 && c as libc::c_int <= 'f' as i32 {
        return c as libc::c_int - 'a' as i32 + 10 as libc::c_int;
    }
    if c as libc::c_int >= 'A' as i32 && c as libc::c_int <= 'F' as i32 {
        return c as libc::c_int - 'A' as i32 + 10 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn integerValue(mut zArg: *const libc::c_char) -> sqlite3_int64 {
    let mut v: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    static mut aMult: [C2RustUnnamed_14; 9] = [
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"KiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"MiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"GiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"KB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"MB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"GB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"K\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"M\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"G\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut isNeg: libc::c_int = 0 as libc::c_int;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        isNeg = 1 as libc::c_int;
        zArg = zArg.offset(1);
    } else if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32 {
        zArg = zArg.offset(1);
    }
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        let mut x: libc::c_int = 0;
        zArg = zArg.offset(2 as libc::c_int as isize);
        loop {
            x = hexDigitValue(*zArg.offset(0 as libc::c_int as isize));
            if !(x >= 0 as libc::c_int) {
                break;
            }
            v = (v << 4 as libc::c_int) + x as libc::c_longlong;
            zArg = zArg.offset(1);
        }
    } else {
        while *(*__ctype_b_loc())
            .offset(
                *zArg.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                    as isize,
            ) as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            v = v * 10 as libc::c_int as libc::c_longlong
                + *zArg.offset(0 as libc::c_int as isize) as libc::c_longlong
                - '0' as i32 as libc::c_longlong;
            zArg = zArg.offset(1);
        }
    }
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<[C2RustUnnamed_14; 9]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_14>() as libc::c_ulong)
            as libc::c_int
    {
        if sqlite3_stricmp(aMult[i as usize].zSuffix, zArg) == 0 as libc::c_int {
            v *= aMult[i as usize].iMult as libc::c_longlong;
            break;
        } else {
            i += 1;
        }
    }
    return if isNeg != 0 { -v } else { v };
}
unsafe extern "C" fn initText(mut p: *mut ShellText) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ShellText>() as libc::c_ulong,
    );
}
unsafe extern "C" fn freeText(mut p: *mut ShellText) {
    free((*p).z as *mut libc::c_void);
    initText(p);
}
unsafe extern "C" fn appendText(
    mut p: *mut ShellText,
    mut zAppend: *const libc::c_char,
    mut quote: libc::c_char,
) {
    let mut len: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut nAppend: libc::c_int = strlen30(zAppend);
    len = nAppend + (*p).n + 1 as libc::c_int;
    if quote != 0 {
        len += 2 as libc::c_int;
        i = 0 as libc::c_int;
        while i < nAppend {
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                len += 1;
            }
            i += 1;
        }
    }
    if ((*p).z).is_null() || (*p).n + len >= (*p).nAlloc {
        (*p).nAlloc = (*p).nAlloc * 2 as libc::c_int + len + 20 as libc::c_int;
        (*p)
            .z = realloc((*p).z as *mut libc::c_void, (*p).nAlloc as libc::c_ulong)
            as *mut libc::c_char;
        shell_check_oom((*p).z as *mut libc::c_void);
    }
    if quote != 0 {
        let mut zCsr: *mut libc::c_char = ((*p).z).offset((*p).n as isize);
        let fresh1 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh1 = quote;
        i = 0 as libc::c_int;
        while i < nAppend {
            let fresh2 = zCsr;
            zCsr = zCsr.offset(1);
            *fresh2 = *zAppend.offset(i as isize);
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                let fresh3 = zCsr;
                zCsr = zCsr.offset(1);
                *fresh3 = quote;
            }
            i += 1;
        }
        let fresh4 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh4 = quote;
        (*p).n = zCsr.offset_from((*p).z) as libc::c_long as libc::c_int;
        *zCsr = '\0' as i32 as libc::c_char;
    } else {
        memcpy(
            ((*p).z).offset((*p).n as isize) as *mut libc::c_void,
            zAppend as *const libc::c_void,
            nAppend as libc::c_ulong,
        );
        (*p).n += nAppend;
        *((*p).z).offset((*p).n as isize) = '\0' as i32 as libc::c_char;
    };
}
unsafe extern "C" fn quoteChar(mut zName: *const libc::c_char) -> libc::c_char {
    let mut i: libc::c_int = 0;
    if *(*__ctype_b_loc())
        .offset(
            *zName.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                as isize,
        ) as libc::c_int & _ISalpha as libc::c_int as libc::c_ushort as libc::c_int == 0
        && *zName.offset(0 as libc::c_int as isize) as libc::c_int != '_' as i32
    {
        return '"' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while *zName.offset(i as isize) != 0 {
        if *(*__ctype_b_loc())
            .offset(*zName.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
            == 0 && *zName.offset(i as isize) as libc::c_int != '_' as i32
        {
            return '"' as i32 as libc::c_char;
        }
        i += 1;
    }
    return (if sqlite3_keyword_check(zName, i) != 0 {
        '"' as i32
    } else {
        0 as libc::c_int
    }) as libc::c_char;
}
unsafe extern "C" fn shellFakeSchema(
    mut db: *mut sqlite3,
    mut zSchema: *const libc::c_char,
    mut zName: *const libc::c_char,
) -> *mut libc::c_char {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: ShellText = ShellText {
        z: 0 as *mut libc::c_char,
        n: 0,
        nAlloc: 0,
    };
    let mut cQuote: libc::c_char = 0;
    let mut zDiv: *mut libc::c_char = b"(\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    let mut nRow: libc::c_int = 0 as libc::c_int;
    zSql = sqlite3_mprintf(
        b"PRAGMA \"%w\".table_info=%Q;\0" as *const u8 as *const libc::c_char,
        if !zSchema.is_null() {
            zSchema
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        },
        zName,
    );
    shell_check_oom(zSql as *mut libc::c_void);
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    initText(&mut s);
    if !zSchema.is_null() {
        cQuote = quoteChar(zSchema);
        if cQuote as libc::c_int != 0
            && sqlite3_stricmp(zSchema, b"temp\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            cQuote = 0 as libc::c_int as libc::c_char;
        }
        appendText(&mut s, zSchema, cQuote);
        appendText(
            &mut s,
            b".\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    cQuote = quoteChar(zName);
    appendText(&mut s, zName, cQuote);
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        let mut zCol: *const libc::c_char = sqlite3_column_text(pStmt, 1 as libc::c_int)
            as *const libc::c_char;
        nRow += 1;
        appendText(&mut s, zDiv, 0 as libc::c_int as libc::c_char);
        zDiv = b",\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        if zCol.is_null() {
            zCol = b"\0" as *const u8 as *const libc::c_char;
        }
        cQuote = quoteChar(zCol);
        appendText(&mut s, zCol, cQuote);
    }
    appendText(
        &mut s,
        b")\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as libc::c_char,
    );
    sqlite3_finalize(pStmt);
    if nRow == 0 as libc::c_int {
        freeText(&mut s);
        s.z = 0 as *mut libc::c_char;
    }
    return s.z;
}
unsafe extern "C" fn shellModuleSchema(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
    zName = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    zFake = if !zName.is_null() {
        shellFakeSchema(sqlite3_context_db_handle(pCtx), 0 as *const libc::c_char, zName)
    } else {
        0 as *mut libc::c_char
    };
    if !zFake.is_null() {
        sqlite3_result_text(
            pCtx,
            sqlite3_mprintf(b"/* %s */\0" as *const u8 as *const libc::c_char, zFake),
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
        free(zFake as *mut libc::c_void);
    }
}
unsafe extern "C" fn shellAddSchemaName(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    static mut aPrefix: [*const libc::c_char; 6] = [
        b"TABLE\0" as *const u8 as *const libc::c_char,
        b"INDEX\0" as *const u8 as *const libc::c_char,
        b"UNIQUE INDEX\0" as *const u8 as *const libc::c_char,
        b"VIEW\0" as *const u8 as *const libc::c_char,
        b"TRIGGER\0" as *const u8 as *const libc::c_char,
        b"VIRTUAL TABLE\0" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut zIn: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut zSchema: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(1 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut zName: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(2 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    if !zIn.is_null()
        && strncmp(
            zIn,
            b"CREATE \0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            let mut n: libc::c_int = strlen30(aPrefix[i as usize]);
            if strncmp(
                zIn.offset(7 as libc::c_int as isize),
                aPrefix[i as usize],
                n as libc::c_ulong,
            ) == 0 as libc::c_int
                && *zIn.offset((n + 7 as libc::c_int) as isize) as libc::c_int
                    == ' ' as i32
            {
                let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
                if !zSchema.is_null() {
                    let mut cQuote: libc::c_char = quoteChar(zSchema);
                    if cQuote as libc::c_int != 0
                        && sqlite3_stricmp(
                            zSchema,
                            b"temp\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                    {
                        z = sqlite3_mprintf(
                            b"%.*s \"%w\".%s\0" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%.*s %s.%s\0" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        );
                    }
                }
                if !zName.is_null()
                    && *(aPrefix[i as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_int == 'V' as i32
                    && {
                        zFake = shellFakeSchema(db, zSchema, zName);
                        !zFake.is_null()
                    }
                {
                    if z.is_null() {
                        z = sqlite3_mprintf(
                            b"%s\n/* %s */\0" as *const u8 as *const libc::c_char,
                            zIn,
                            zFake,
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%z\n/* %s */\0" as *const u8 as *const libc::c_char,
                            z,
                            zFake,
                        );
                    }
                    free(zFake as *mut libc::c_void);
                }
                if !z.is_null() {
                    sqlite3_result_text(
                        pCtx,
                        z,
                        -(1 as libc::c_int),
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    return;
                }
            }
            i += 1;
        }
    }
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
static mut memtraceBase: sqlite3_mem_methods = sqlite3_mem_methods {
    xMalloc: None,
    xFree: None,
    xRealloc: None,
    xSize: None,
    xRoundup: None,
    xInit: None,
    xShutdown: None,
    pAppData: 0 as *const libc::c_void as *mut libc::c_void,
};
static mut memtraceOut: *mut FILE = 0 as *const FILE as *mut FILE;
unsafe extern "C" fn memtraceMalloc(mut n: libc::c_int) -> *mut libc::c_void {
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: allocate %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xRoundup).expect("non-null function pointer")(n),
        );
    }
    return (memtraceBase.xMalloc).expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceFree(mut p: *mut libc::c_void) {
    if p.is_null() {
        return;
    }
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: free %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xSize).expect("non-null function pointer")(p),
        );
    }
    (memtraceBase.xFree).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRealloc(
    mut p: *mut libc::c_void,
    mut n: libc::c_int,
) -> *mut libc::c_void {
    if p.is_null() {
        return memtraceMalloc(n);
    }
    if n == 0 as libc::c_int {
        memtraceFree(p);
        return 0 as *mut libc::c_void;
    }
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: resize %d -> %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xSize).expect("non-null function pointer")(p),
            (memtraceBase.xRoundup).expect("non-null function pointer")(n),
        );
    }
    return (memtraceBase.xRealloc).expect("non-null function pointer")(p, n);
}
unsafe extern "C" fn memtraceSize(mut p: *mut libc::c_void) -> libc::c_int {
    return (memtraceBase.xSize).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRoundup(mut n: libc::c_int) -> libc::c_int {
    return (memtraceBase.xRoundup).expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceInit(mut p: *mut libc::c_void) -> libc::c_int {
    return (memtraceBase.xInit).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceShutdown(mut p: *mut libc::c_void) {
    (memtraceBase.xShutdown).expect("non-null function pointer")(p);
}
static mut ersaztMethods: sqlite3_mem_methods = unsafe {
    {
        let mut init = sqlite3_mem_methods {
            xMalloc: Some(
                memtraceMalloc as unsafe extern "C" fn(libc::c_int) -> *mut libc::c_void,
            ),
            xFree: Some(memtraceFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
            xRealloc: Some(
                memtraceRealloc
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                    ) -> *mut libc::c_void,
            ),
            xSize: Some(
                memtraceSize as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xRoundup: Some(
                memtraceRoundup as unsafe extern "C" fn(libc::c_int) -> libc::c_int,
            ),
            xInit: Some(
                memtraceInit as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xShutdown: Some(
                memtraceShutdown as unsafe extern "C" fn(*mut libc::c_void) -> (),
            ),
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3MemTraceActivate(mut out: *mut FILE) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (memtraceBase.xMalloc).is_none() {
        rc = sqlite3_config(
            5 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            rc = sqlite3_config(
                4 as libc::c_int,
                &mut ersaztMethods as *mut sqlite3_mem_methods,
            );
        }
    }
    memtraceOut = out;
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3MemTraceDeactivate() -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (memtraceBase.xMalloc).is_some() {
        rc = sqlite3_config(
            4 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            memset(
                &mut memtraceBase as *mut sqlite3_mem_methods as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sqlite3_mem_methods>() as libc::c_ulong,
            );
        }
    }
    memtraceOut = 0 as *mut FILE;
    return rc;
}
unsafe extern "C" fn KeccakF1600Step(mut p: *mut SHA3Context) {
    let mut i: libc::c_int = 0;
    let mut b0: u64_0 = 0;
    let mut b1: u64_0 = 0;
    let mut b2: u64_0 = 0;
    let mut b3: u64_0 = 0;
    let mut b4: u64_0 = 0;
    let mut c0: u64_0 = 0;
    let mut c1: u64_0 = 0;
    let mut c2: u64_0 = 0;
    let mut c3: u64_0 = 0;
    let mut c4: u64_0 = 0;
    let mut d0: u64_0 = 0;
    let mut d1: u64_0 = 0;
    let mut d2: u64_0 = 0;
    let mut d3: u64_0 = 0;
    let mut d4: u64_0 = 0;
    static mut RC: [u64_0; 24] = [
        0x1 as libc::c_ulonglong,
        0x8082 as libc::c_ulonglong,
        0x800000000000808a as libc::c_ulonglong,
        0x8000000080008000 as libc::c_ulonglong,
        0x808b as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008009 as libc::c_ulonglong,
        0x8a as libc::c_ulonglong,
        0x88 as libc::c_ulonglong,
        0x80008009 as libc::c_ulonglong,
        0x8000000a as libc::c_ulonglong,
        0x8000808b as libc::c_ulonglong,
        0x800000000000008b as libc::c_ulonglong,
        0x8000000000008089 as libc::c_ulonglong,
        0x8000000000008003 as libc::c_ulonglong,
        0x8000000000008002 as libc::c_ulonglong,
        0x8000000000000080 as libc::c_ulonglong,
        0x800a as libc::c_ulonglong,
        0x800000008000000a as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008080 as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008008 as libc::c_ulonglong,
    ];
    i = 0 as libc::c_int;
    while i < 24 as libc::c_int {
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[5 as libc::c_int as usize]
            ^ (*p).u.s[10 as libc::c_int as usize] ^ (*p).u.s[15 as libc::c_int as usize]
            ^ (*p).u.s[20 as libc::c_int as usize];
        c1 = (*p).u.s[1 as libc::c_int as usize] ^ (*p).u.s[6 as libc::c_int as usize]
            ^ (*p).u.s[11 as libc::c_int as usize] ^ (*p).u.s[16 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[2 as libc::c_int as usize] ^ (*p).u.s[7 as libc::c_int as usize]
            ^ (*p).u.s[12 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[22 as libc::c_int as usize];
        c3 = (*p).u.s[3 as libc::c_int as usize] ^ (*p).u.s[8 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[18 as libc::c_int as usize]
            ^ (*p).u.s[23 as libc::c_int as usize];
        c4 = (*p).u.s[4 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[14 as libc::c_int as usize] ^ (*p).u.s[19 as libc::c_int as usize]
            ^ (*p).u.s[24 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[i as usize];
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[10 as libc::c_int as usize]
            ^ (*p).u.s[20 as libc::c_int as usize] ^ (*p).u.s[5 as libc::c_int as usize]
            ^ (*p).u.s[15 as libc::c_int as usize];
        c1 = (*p).u.s[6 as libc::c_int as usize] ^ (*p).u.s[16 as libc::c_int as usize]
            ^ (*p).u.s[1 as libc::c_int as usize] ^ (*p).u.s[11 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[12 as libc::c_int as usize] ^ (*p).u.s[22 as libc::c_int as usize]
            ^ (*p).u.s[7 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[2 as libc::c_int as usize];
        c3 = (*p).u.s[18 as libc::c_int as usize] ^ (*p).u.s[3 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[23 as libc::c_int as usize]
            ^ (*p).u.s[8 as libc::c_int as usize];
        c4 = (*p).u.s[24 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[19 as libc::c_int as usize] ^ (*p).u.s[4 as libc::c_int as usize]
            ^ (*p).u.s[14 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[(i + 1 as libc::c_int) as usize];
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[20 as libc::c_int as usize]
            ^ (*p).u.s[15 as libc::c_int as usize] ^ (*p).u.s[10 as libc::c_int as usize]
            ^ (*p).u.s[5 as libc::c_int as usize];
        c1 = (*p).u.s[16 as libc::c_int as usize] ^ (*p).u.s[11 as libc::c_int as usize]
            ^ (*p).u.s[6 as libc::c_int as usize] ^ (*p).u.s[1 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[7 as libc::c_int as usize] ^ (*p).u.s[2 as libc::c_int as usize]
            ^ (*p).u.s[22 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[12 as libc::c_int as usize];
        c3 = (*p).u.s[23 as libc::c_int as usize] ^ (*p).u.s[18 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[8 as libc::c_int as usize]
            ^ (*p).u.s[3 as libc::c_int as usize];
        c4 = (*p).u.s[14 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[4 as libc::c_int as usize] ^ (*p).u.s[24 as libc::c_int as usize]
            ^ (*p).u.s[19 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[(i + 2 as libc::c_int) as usize];
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[15 as libc::c_int as usize]
            ^ (*p).u.s[5 as libc::c_int as usize] ^ (*p).u.s[20 as libc::c_int as usize]
            ^ (*p).u.s[10 as libc::c_int as usize];
        c1 = (*p).u.s[11 as libc::c_int as usize] ^ (*p).u.s[1 as libc::c_int as usize]
            ^ (*p).u.s[16 as libc::c_int as usize] ^ (*p).u.s[6 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[22 as libc::c_int as usize] ^ (*p).u.s[12 as libc::c_int as usize]
            ^ (*p).u.s[2 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[7 as libc::c_int as usize];
        c3 = (*p).u.s[8 as libc::c_int as usize] ^ (*p).u.s[23 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[3 as libc::c_int as usize]
            ^ (*p).u.s[18 as libc::c_int as usize];
        c4 = (*p).u.s[19 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[24 as libc::c_int as usize] ^ (*p).u.s[14 as libc::c_int as usize]
            ^ (*p).u.s[4 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[(i + 3 as libc::c_int) as usize];
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        i += 4 as libc::c_int;
    }
}
unsafe extern "C" fn SHA3Init(mut p: *mut SHA3Context, mut iSize: libc::c_int) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<SHA3Context>() as libc::c_ulong,
    );
    if iSize >= 128 as libc::c_int && iSize <= 512 as libc::c_int {
        (*p)
            .nRate = ((1600 as libc::c_int
            - (iSize + 31 as libc::c_int & !(31 as libc::c_int)) * 2 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint;
    } else {
        (*p)
            .nRate = ((1600 as libc::c_int - 2 as libc::c_int * 256 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint;
    };
}
unsafe extern "C" fn SHA3Update(
    mut p: *mut SHA3Context,
    mut aData: *const libc::c_uchar,
    mut nData: libc::c_uint,
) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if aData.is_null() {
        return;
    }
    if ((*p).nLoaded).wrapping_rem(8 as libc::c_int as libc::c_uint)
        == 0 as libc::c_int as libc::c_uint
        && aData.offset_from(0 as *const libc::c_uchar) as libc::c_long
            & 7 as libc::c_int as libc::c_long == 0 as libc::c_int as libc::c_long
    {
        while i.wrapping_add(7 as libc::c_int as libc::c_uint) < nData {
            (*p)
                .u
                .s[((*p).nLoaded).wrapping_div(8 as libc::c_int as libc::c_uint)
                as usize]
                ^= *(&*aData.offset(i as isize) as *const libc::c_uchar as *mut u64_0);
            (*p).nLoaded = ((*p).nLoaded).wrapping_add(8 as libc::c_int as libc::c_uint);
            if (*p).nLoaded >= (*p).nRate {
                KeccakF1600Step(p);
                (*p).nLoaded = 0 as libc::c_int as libc::c_uint;
            }
            i = i.wrapping_add(8 as libc::c_int as libc::c_uint);
        }
    }
    while i < nData {
        (*p)
            .u
            .x[(*p).nLoaded
            as usize] = ((*p).u.x[(*p).nLoaded as usize] as libc::c_int
            ^ *aData.offset(i as isize) as libc::c_int) as libc::c_uchar;
        (*p).nLoaded = ((*p).nLoaded).wrapping_add(1);
        if (*p).nLoaded == (*p).nRate {
            KeccakF1600Step(p);
            (*p).nLoaded = 0 as libc::c_int as libc::c_uint;
        }
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn SHA3Final(mut p: *mut SHA3Context) -> *mut libc::c_uchar {
    let mut i: libc::c_uint = 0;
    if (*p).nLoaded == ((*p).nRate).wrapping_sub(1 as libc::c_int as libc::c_uint) {
        let c1: libc::c_uchar = 0x86 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c1, 1 as libc::c_int as libc::c_uint);
    } else {
        let c2: libc::c_uchar = 0x6 as libc::c_int as libc::c_uchar;
        let c3: libc::c_uchar = 0x80 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c2, 1 as libc::c_int as libc::c_uint);
        (*p).nLoaded = ((*p).nRate).wrapping_sub(1 as libc::c_int as libc::c_uint);
        SHA3Update(p, &c3, 1 as libc::c_int as libc::c_uint);
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*p).nRate {
        (*p)
            .u
            .x[i.wrapping_add((*p).nRate)
            as usize] = (*p).u.x[(i ^ (*p).ixMask) as usize];
        i = i.wrapping_add(1);
    }
    return &mut *((*p).u.x).as_mut_ptr().offset((*p).nRate as isize)
        as *mut libc::c_uchar;
}
unsafe extern "C" fn sha3Func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: [0; 25] },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut eType: libc::c_int = sqlite3_value_type(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut nByte: libc::c_int = sqlite3_value_bytes(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int;
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if eType == 5 as libc::c_int {
        return;
    }
    SHA3Init(&mut cx, iSize);
    if eType == 4 as libc::c_int {
        SHA3Update(
            &mut cx,
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
                as *const libc::c_uchar,
            nByte as libc::c_uint,
        );
    } else {
        SHA3Update(
            &mut cx,
            sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)),
            nByte as libc::c_uint,
        );
    }
    sqlite3_result_blob(
        context,
        SHA3Final(&mut cx) as *const libc::c_void,
        iSize / 8 as libc::c_int,
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn hash_step_vformat(
    mut p: *mut SHA3Context,
    mut zFormat: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    let mut n: libc::c_int = 0;
    let mut zBuf: [libc::c_char; 50] = [0; 50];
    ap = args.clone();
    sqlite3_vsnprintf(
        ::core::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong as libc::c_int,
        zBuf.as_mut_ptr(),
        zFormat,
        ap.as_va_list(),
    );
    n = strlen(zBuf.as_mut_ptr()) as libc::c_int;
    SHA3Update(p, zBuf.as_mut_ptr() as *mut libc::c_uchar, n as libc::c_uint);
}
unsafe extern "C" fn sha3QueryFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(context);
    let mut zSql: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: [0; 25] },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int;
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if zSql.is_null() {
        return;
    }
    SHA3Init(&mut cx, iSize);
    while *zSql.offset(0 as libc::c_int as isize) != 0 {
        rc = sqlite3_prepare_v2(db, zSql, -(1 as libc::c_int), &mut pStmt, &mut zSql);
        if rc != 0 {
            let mut zMsg: *mut libc::c_char = sqlite3_mprintf(
                b"error SQL statement [%s]: %s\0" as *const u8 as *const libc::c_char,
                zSql,
                sqlite3_errmsg(db),
            );
            sqlite3_finalize(pStmt);
            sqlite3_result_error(context, zMsg, -(1 as libc::c_int));
            sqlite3_free(zMsg as *mut libc::c_void);
            return;
        }
        if sqlite3_stmt_readonly(pStmt) == 0 {
            let mut zMsg_0: *mut libc::c_char = sqlite3_mprintf(
                b"non-query: [%s]\0" as *const u8 as *const libc::c_char,
                sqlite3_sql(pStmt),
            );
            sqlite3_finalize(pStmt);
            sqlite3_result_error(context, zMsg_0, -(1 as libc::c_int));
            sqlite3_free(zMsg_0 as *mut libc::c_void);
            return;
        }
        nCol = sqlite3_column_count(pStmt);
        z = sqlite3_sql(pStmt);
        if !z.is_null() {
            n = strlen(z) as libc::c_int;
            hash_step_vformat(
                &mut cx as *mut SHA3Context,
                b"S%d:\0" as *const u8 as *const libc::c_char,
                n,
            );
            SHA3Update(&mut cx, z as *mut libc::c_uchar, n as libc::c_uint);
        }
        while 100 as libc::c_int == sqlite3_step(pStmt) {
            SHA3Update(
                &mut cx,
                b"R\0" as *const u8 as *const libc::c_char as *const libc::c_uchar,
                1 as libc::c_int as libc::c_uint,
            );
            i = 0 as libc::c_int;
            while i < nCol {
                match sqlite3_column_type(pStmt, i) {
                    5 => {
                        SHA3Update(
                            &mut cx,
                            b"N\0" as *const u8 as *const libc::c_char
                                as *const libc::c_uchar,
                            1 as libc::c_int as libc::c_uint,
                        );
                    }
                    1 => {
                        let mut u: sqlite3_uint64 = 0;
                        let mut j: libc::c_int = 0;
                        let mut x: [libc::c_uchar; 9] = [0; 9];
                        let mut v: sqlite3_int64 = sqlite3_column_int64(pStmt, i);
                        memcpy(
                            &mut u as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut v as *mut sqlite3_int64 as *const libc::c_void,
                            8 as libc::c_int as libc::c_ulong,
                        );
                        j = 8 as libc::c_int;
                        while j >= 1 as libc::c_int {
                            x[j
                                as usize] = (u & 0xff as libc::c_int as libc::c_ulonglong)
                                as libc::c_uchar;
                            u >>= 8 as libc::c_int;
                            j -= 1;
                        }
                        x[0 as libc::c_int as usize] = 'I' as i32 as libc::c_uchar;
                        SHA3Update(
                            &mut cx,
                            x.as_mut_ptr(),
                            9 as libc::c_int as libc::c_uint,
                        );
                    }
                    2 => {
                        let mut u_0: sqlite3_uint64 = 0;
                        let mut j_0: libc::c_int = 0;
                        let mut x_0: [libc::c_uchar; 9] = [0; 9];
                        let mut r: libc::c_double = sqlite3_column_double(pStmt, i);
                        memcpy(
                            &mut u_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r as *mut libc::c_double as *const libc::c_void,
                            8 as libc::c_int as libc::c_ulong,
                        );
                        j_0 = 8 as libc::c_int;
                        while j_0 >= 1 as libc::c_int {
                            x_0[j_0
                                as usize] = (u_0 & 0xff as libc::c_int as libc::c_ulonglong)
                                as libc::c_uchar;
                            u_0 >>= 8 as libc::c_int;
                            j_0 -= 1;
                        }
                        x_0[0 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
                        SHA3Update(
                            &mut cx,
                            x_0.as_mut_ptr(),
                            9 as libc::c_int as libc::c_uint,
                        );
                    }
                    3 => {
                        let mut n2: libc::c_int = sqlite3_column_bytes(pStmt, i);
                        let mut z2: *const libc::c_uchar = sqlite3_column_text(pStmt, i);
                        hash_step_vformat(
                            &mut cx as *mut SHA3Context,
                            b"T%d:\0" as *const u8 as *const libc::c_char,
                            n2,
                        );
                        SHA3Update(&mut cx, z2, n2 as libc::c_uint);
                    }
                    4 => {
                        let mut n2_0: libc::c_int = sqlite3_column_bytes(pStmt, i);
                        let mut z2_0: *const libc::c_uchar = sqlite3_column_blob(
                            pStmt,
                            i,
                        ) as *const libc::c_uchar;
                        hash_step_vformat(
                            &mut cx as *mut SHA3Context,
                            b"B%d:\0" as *const u8 as *const libc::c_char,
                            n2_0,
                        );
                        SHA3Update(&mut cx, z2_0, n2_0 as libc::c_uint);
                    }
                    _ => {}
                }
                i += 1;
            }
        }
        sqlite3_finalize(pStmt);
    }
    sqlite3_result_blob(
        context,
        SHA3Final(&mut cx) as *const libc::c_void,
        iSize / 8 as libc::c_int,
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_shathree_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sha3\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sha3Func
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3Func
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn uintCollFunc(
    mut notUsed: *mut libc::c_void,
    mut nKey1: libc::c_int,
    mut pKey1: *const libc::c_void,
    mut nKey2: libc::c_int,
    mut pKey2: *const libc::c_void,
) -> libc::c_int {
    let mut zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let mut zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut x: libc::c_int = 0;
    while i < nKey1 && j < nKey2 {
        x = *zA.offset(i as isize) as libc::c_int
            - *zB.offset(j as isize) as libc::c_int;
        if *(*__ctype_b_loc()).offset(*zA.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            let mut k: libc::c_int = 0;
            if *(*__ctype_b_loc()).offset(*zB.offset(j as isize) as libc::c_int as isize)
                as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return x;
            }
            while i < nKey1 && *zA.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1;
            }
            while j < nKey2 && *zB.offset(j as isize) as libc::c_int == '0' as i32 {
                j += 1;
            }
            k = 0 as libc::c_int;
            while i + k < nKey1
                && *(*__ctype_b_loc())
                    .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                && j + k < nKey2
                && *(*__ctype_b_loc())
                    .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                k += 1;
            }
            if i + k < nKey1
                && *(*__ctype_b_loc())
                    .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                return 1 as libc::c_int
            } else {
                if j + k < nKey2
                    && *(*__ctype_b_loc())
                        .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    return -(1 as libc::c_int)
                } else {
                    x = memcmp(
                        zA.offset(i as isize) as *const libc::c_void,
                        zB.offset(j as isize) as *const libc::c_void,
                        k as libc::c_ulong,
                    );
                    if x != 0 {
                        return x;
                    }
                    i += k;
                    j += k;
                }
            }
        } else if x != 0 {
            return x
        } else {
            i += 1;
            j += 1;
        }
    }
    return nKey1 - i - (nKey2 - j);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_uint_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3_create_collation(
        db,
        b"uint\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            uintCollFunc
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *const libc::c_void,
                    libc::c_int,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
}
unsafe extern "C" fn decimal_clear(mut p: *mut Decimal) {
    sqlite3_free((*p).a as *mut libc::c_void);
}
unsafe extern "C" fn decimal_free(mut p: *mut Decimal) {
    if !p.is_null() {
        decimal_clear(p);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn decimal_new(
    mut pCtx: *mut sqlite3_context,
    mut pIn: *mut sqlite3_value,
    mut nAlt: libc::c_int,
    mut zAlt: *const libc::c_uchar,
) -> *mut Decimal {
    let mut current_block: u64;
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut zIn: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut iExp: libc::c_int = 0 as libc::c_int;
    p = sqlite3_malloc(::core::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int)
        as *mut Decimal;
    if !p.is_null() {
        (*p).sign = 0 as libc::c_int as libc::c_char;
        (*p).oom = 0 as libc::c_int as libc::c_char;
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        (*p).isNull = 0 as libc::c_int as libc::c_char;
        (*p).nDigit = 0 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
        if !zAlt.is_null() {
            n = nAlt;
            zIn = zAlt;
        } else {
            if sqlite3_value_type(pIn) == 5 as libc::c_int {
                (*p).a = 0 as *mut libc::c_schar;
                (*p).isNull = 1 as libc::c_int as libc::c_char;
                return p;
            }
            n = sqlite3_value_bytes(pIn);
            zIn = sqlite3_value_text(pIn);
        }
        (*p)
            .a = sqlite3_malloc64((n + 1 as libc::c_int) as sqlite3_uint64)
            as *mut libc::c_schar;
        if !((*p).a).is_null() {
            i = 0 as libc::c_int;
            while *(*__ctype_b_loc())
                .offset(*zIn.offset(i as isize) as libc::c_int as isize) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                i += 1;
            }
            if *zIn.offset(i as isize) as libc::c_int == '-' as i32 {
                (*p).sign = 1 as libc::c_int as libc::c_char;
                i += 1;
            } else if *zIn.offset(i as isize) as libc::c_int == '+' as i32 {
                i += 1;
            }
            while i < n && *zIn.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1;
            }
            while i < n {
                let mut c: libc::c_char = *zIn.offset(i as isize) as libc::c_char;
                if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
                    let fresh5 = (*p).nDigit;
                    (*p).nDigit = (*p).nDigit + 1;
                    *((*p).a)
                        .offset(
                            fresh5 as isize,
                        ) = (c as libc::c_int - '0' as i32) as libc::c_schar;
                } else if c as libc::c_int == '.' as i32 {
                    (*p).nFrac = (*p).nDigit + 1 as libc::c_int;
                } else if c as libc::c_int == 'e' as i32
                    || c as libc::c_int == 'E' as i32
                {
                    let mut j: libc::c_int = i + 1 as libc::c_int;
                    let mut neg: libc::c_int = 0 as libc::c_int;
                    if j >= n {
                        break;
                    }
                    if *zIn.offset(j as isize) as libc::c_int == '-' as i32 {
                        neg = 1 as libc::c_int;
                        j += 1;
                    } else if *zIn.offset(j as isize) as libc::c_int == '+' as i32 {
                        j += 1;
                    }
                    while j < n && iExp < 1000000 as libc::c_int {
                        if *zIn.offset(j as isize) as libc::c_int >= '0' as i32
                            && *zIn.offset(j as isize) as libc::c_int <= '9' as i32
                        {
                            iExp = iExp * 10 as libc::c_int
                                + *zIn.offset(j as isize) as libc::c_int - '0' as i32;
                        }
                        j += 1;
                    }
                    if neg != 0 {
                        iExp = -iExp;
                    }
                    break;
                }
                i += 1;
            }
            if (*p).nFrac != 0 {
                (*p).nFrac = (*p).nDigit - ((*p).nFrac - 1 as libc::c_int);
            }
            if iExp > 0 as libc::c_int {
                if (*p).nFrac > 0 as libc::c_int {
                    if iExp <= (*p).nFrac {
                        (*p).nFrac -= iExp;
                        iExp = 0 as libc::c_int;
                    } else {
                        iExp -= (*p).nFrac;
                        (*p).nFrac = 0 as libc::c_int;
                    }
                }
                if iExp > 0 as libc::c_int {
                    (*p)
                        .a = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if ((*p).a).is_null() {
                        current_block = 10537003136019651358;
                    } else {
                        memset(
                            ((*p).a).offset((*p).nDigit as isize) as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        current_block = 16231175055492490595;
                    }
                } else {
                    current_block = 16231175055492490595;
                }
            } else if iExp < 0 as libc::c_int {
                let mut nExtra: libc::c_int = 0;
                iExp = -iExp;
                nExtra = (*p).nDigit - (*p).nFrac - 1 as libc::c_int;
                if nExtra != 0 {
                    if nExtra >= iExp {
                        (*p).nFrac += iExp;
                        iExp = 0 as libc::c_int;
                    } else {
                        iExp -= nExtra;
                        (*p).nFrac = (*p).nDigit - 1 as libc::c_int;
                    }
                }
                if iExp > 0 as libc::c_int {
                    (*p)
                        .a = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if ((*p).a).is_null() {
                        current_block = 10537003136019651358;
                    } else {
                        memmove(
                            ((*p).a).offset(iExp as isize) as *mut libc::c_void,
                            (*p).a as *const libc::c_void,
                            (*p).nDigit as libc::c_ulong,
                        );
                        memset(
                            (*p).a as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        (*p).nFrac += iExp;
                        current_block = 16231175055492490595;
                    }
                } else {
                    current_block = 16231175055492490595;
                }
            } else {
                current_block = 16231175055492490595;
            }
            match current_block {
                10537003136019651358 => {}
                _ => return p,
            }
        }
    }
    if !pCtx.is_null() {
        sqlite3_result_error_nomem(pCtx);
    }
    sqlite3_free(p as *mut libc::c_void);
    return 0 as *mut Decimal;
}
unsafe extern "C" fn decimal_result(
    mut pCtx: *mut sqlite3_context,
    mut p: *mut Decimal,
) {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if p.is_null() || (*p).oom as libc::c_int != 0 {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    if (*p).isNull != 0 {
        sqlite3_result_null(pCtx);
        return;
    }
    z = sqlite3_malloc((*p).nDigit + 4 as libc::c_int) as *mut libc::c_char;
    if z.is_null() {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    i = 0 as libc::c_int;
    if (*p).nDigit == 0 as libc::c_int
        || (*p).nDigit == 1 as libc::c_int
            && *((*p).a).offset(0 as libc::c_int as isize) as libc::c_int
                == 0 as libc::c_int
    {
        (*p).sign = 0 as libc::c_int as libc::c_char;
    }
    if (*p).sign != 0 {
        *z.offset(0 as libc::c_int as isize) = '-' as i32 as libc::c_char;
        i = 1 as libc::c_int;
    }
    n = (*p).nDigit - (*p).nFrac;
    if n <= 0 as libc::c_int {
        let fresh6 = i;
        i = i + 1;
        *z.offset(fresh6 as isize) = '0' as i32 as libc::c_char;
    }
    j = 0 as libc::c_int;
    while n > 1 as libc::c_int
        && *((*p).a).offset(j as isize) as libc::c_int == 0 as libc::c_int
    {
        j += 1;
        n -= 1;
    }
    while n > 0 as libc::c_int {
        let fresh7 = i;
        i = i + 1;
        *z
            .offset(
                fresh7 as isize,
            ) = (*((*p).a).offset(j as isize) as libc::c_int + '0' as i32)
            as libc::c_char;
        j += 1;
        n -= 1;
    }
    if (*p).nFrac != 0 {
        let fresh8 = i;
        i = i + 1;
        *z.offset(fresh8 as isize) = '.' as i32 as libc::c_char;
        loop {
            let fresh9 = i;
            i = i + 1;
            *z
                .offset(
                    fresh9 as isize,
                ) = (*((*p).a).offset(j as isize) as libc::c_int + '0' as i32)
                as libc::c_char;
            j += 1;
            if !(j < (*p).nDigit) {
                break;
            }
        }
    }
    *z.offset(i as isize) = 0 as libc::c_int as libc::c_char;
    sqlite3_result_text(
        pCtx,
        z,
        i,
        Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
    );
}
unsafe extern "C" fn decimalFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_result(context, p);
    decimal_free(p);
}
unsafe extern "C" fn decimal_cmp(
    mut pA: *const Decimal,
    mut pB: *const Decimal,
) -> libc::c_int {
    let mut nASig: libc::c_int = 0;
    let mut nBSig: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if (*pA).sign as libc::c_int != (*pB).sign as libc::c_int {
        return if (*pA).sign as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    if (*pA).sign != 0 {
        let mut pTemp: *const Decimal = pA;
        pA = pB;
        pB = pTemp;
    }
    nASig = (*pA).nDigit - (*pA).nFrac;
    nBSig = (*pB).nDigit - (*pB).nFrac;
    if nASig != nBSig {
        return nASig - nBSig;
    }
    n = (*pA).nDigit;
    if n > (*pB).nDigit {
        n = (*pB).nDigit;
    }
    rc = memcmp(
        (*pA).a as *const libc::c_void,
        (*pB).a as *const libc::c_void,
        n as libc::c_ulong,
    );
    if rc == 0 as libc::c_int {
        rc = (*pA).nDigit - (*pB).nDigit;
    }
    return rc;
}
unsafe extern "C" fn decimalCmpFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = 0 as *mut Decimal;
    let mut pB: *mut Decimal = 0 as *mut Decimal;
    let mut rc: libc::c_int = 0;
    pA = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !(pA.is_null() || (*pA).isNull as libc::c_int != 0) {
        pB = decimal_new(
            context,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            0 as *const libc::c_uchar,
        );
        if !(pB.is_null() || (*pB).isNull as libc::c_int != 0) {
            rc = decimal_cmp(pA, pB);
            if rc < 0 as libc::c_int {
                rc = -(1 as libc::c_int);
            } else if rc > 0 as libc::c_int {
                rc = 1 as libc::c_int;
            }
            sqlite3_result_int(context, rc);
        }
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimal_expand(
    mut p: *mut Decimal,
    mut nDigit: libc::c_int,
    mut nFrac: libc::c_int,
) {
    let mut nAddSig: libc::c_int = 0;
    let mut nAddFrac: libc::c_int = 0;
    if p.is_null() {
        return;
    }
    nAddFrac = nFrac - (*p).nFrac;
    nAddSig = nDigit - (*p).nDigit - nAddFrac;
    if nAddFrac == 0 as libc::c_int && nAddSig == 0 as libc::c_int {
        return;
    }
    (*p)
        .a = sqlite3_realloc64(
        (*p).a as *mut libc::c_void,
        (nDigit + 1 as libc::c_int) as sqlite3_uint64,
    ) as *mut libc::c_schar;
    if ((*p).a).is_null() {
        (*p).oom = 1 as libc::c_int as libc::c_char;
        return;
    }
    if nAddSig != 0 {
        memmove(
            ((*p).a).offset(nAddSig as isize) as *mut libc::c_void,
            (*p).a as *const libc::c_void,
            (*p).nDigit as libc::c_ulong,
        );
        memset((*p).a as *mut libc::c_void, 0 as libc::c_int, nAddSig as libc::c_ulong);
        (*p).nDigit += nAddSig;
    }
    if nAddFrac != 0 {
        memset(
            ((*p).a).offset((*p).nDigit as isize) as *mut libc::c_void,
            0 as libc::c_int,
            nAddFrac as libc::c_ulong,
        );
        (*p).nDigit += nAddFrac;
        (*p).nFrac += nAddFrac;
    }
}
unsafe extern "C" fn decimal_add(mut pA: *mut Decimal, mut pB: *mut Decimal) {
    let mut nSig: libc::c_int = 0;
    let mut nFrac: libc::c_int = 0;
    let mut nDigit: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    if pA.is_null() {
        return;
    }
    if (*pA).oom as libc::c_int != 0 || pB.is_null() || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
        return;
    }
    if (*pA).isNull as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0 {
        (*pA).isNull = 1 as libc::c_int as libc::c_char;
        return;
    }
    nSig = (*pA).nDigit - (*pA).nFrac;
    if nSig != 0
        && *((*pA).a).offset(0 as libc::c_int as isize) as libc::c_int
            == 0 as libc::c_int
    {
        nSig -= 1;
    }
    if nSig < (*pB).nDigit - (*pB).nFrac {
        nSig = (*pB).nDigit - (*pB).nFrac;
    }
    nFrac = (*pA).nFrac;
    if nFrac < (*pB).nFrac {
        nFrac = (*pB).nFrac;
    }
    nDigit = nSig + nFrac + 1 as libc::c_int;
    decimal_expand(pA, nDigit, nFrac);
    decimal_expand(pB, nDigit, nFrac);
    if (*pA).oom as libc::c_int != 0 || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
    } else if (*pA).sign as libc::c_int == (*pB).sign as libc::c_int {
        let mut carry: libc::c_int = 0 as libc::c_int;
        i = nDigit - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut x: libc::c_int = *((*pA).a).offset(i as isize) as libc::c_int
                + *((*pB).a).offset(i as isize) as libc::c_int + carry;
            if x >= 10 as libc::c_int {
                carry = 1 as libc::c_int;
                *((*pA).a).offset(i as isize) = (x - 10 as libc::c_int) as libc::c_schar;
            } else {
                carry = 0 as libc::c_int;
                *((*pA).a).offset(i as isize) = x as libc::c_schar;
            }
            i -= 1;
        }
    } else {
        let mut aA: *mut libc::c_schar = 0 as *mut libc::c_schar;
        let mut aB: *mut libc::c_schar = 0 as *mut libc::c_schar;
        let mut borrow: libc::c_int = 0 as libc::c_int;
        rc = memcmp(
            (*pA).a as *const libc::c_void,
            (*pB).a as *const libc::c_void,
            nDigit as libc::c_ulong,
        );
        if rc < 0 as libc::c_int {
            aA = (*pB).a;
            aB = (*pA).a;
            (*pA).sign = ((*pA).sign == 0) as libc::c_int as libc::c_char;
        } else {
            aA = (*pA).a;
            aB = (*pB).a;
        }
        i = nDigit - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut x_0: libc::c_int = *aA.offset(i as isize) as libc::c_int
                - *aB.offset(i as isize) as libc::c_int - borrow;
            if x_0 < 0 as libc::c_int {
                *((*pA).a)
                    .offset(i as isize) = (x_0 + 10 as libc::c_int) as libc::c_schar;
                borrow = 1 as libc::c_int;
            } else {
                *((*pA).a).offset(i as isize) = x_0 as libc::c_schar;
                borrow = 0 as libc::c_int;
            }
            i -= 1;
        }
    };
}
unsafe extern "C" fn decimalCollFunc(
    mut notUsed: *mut libc::c_void,
    mut nKey1: libc::c_int,
    mut pKey1: *const libc::c_void,
    mut nKey2: libc::c_int,
    mut pKey2: *const libc::c_void,
) -> libc::c_int {
    let mut zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let mut zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut pA: *mut Decimal = decimal_new(
        0 as *mut sqlite3_context,
        0 as *mut sqlite3_value,
        nKey1,
        zA,
    );
    let mut pB: *mut Decimal = decimal_new(
        0 as *mut sqlite3_context,
        0 as *mut sqlite3_value,
        nKey2,
        zB,
    );
    let mut rc: libc::c_int = 0;
    if pA.is_null() || pB.is_null() {
        rc = 0 as libc::c_int;
    } else {
        rc = decimal_cmp(pA, pB);
    }
    decimal_free(pA);
    decimal_free(pB);
    return rc;
}
unsafe extern "C" fn decimalAddFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_add(pA, pB);
    decimal_result(context, pA);
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSubFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !pB.is_null() {
        (*pB).sign = ((*pB).sign == 0) as libc::c_int as libc::c_char;
        decimal_add(pA, pB);
        decimal_result(context, pA);
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSumStep(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::core::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    }
    if (*p).isInit == 0 {
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        (*p).a = sqlite3_malloc(2 as libc::c_int) as *mut libc::c_schar;
        if ((*p).a).is_null() {
            (*p).oom = 1 as libc::c_int as libc::c_char;
        } else {
            *((*p).a)
                .offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_schar;
        }
        (*p).nDigit = 1 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    }
    pArg = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_add(p, pArg);
    decimal_free(pArg);
}
unsafe extern "C" fn decimalSumInverse(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::core::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    }
    pArg = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !pArg.is_null() {
        (*pArg).sign = ((*pArg).sign == 0) as libc::c_int as libc::c_char;
    }
    decimal_add(p, pArg);
    decimal_free(pArg);
}
unsafe extern "C" fn decimalSumValue(mut context: *mut sqlite3_context) {
    let mut p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int)
        as *mut Decimal;
    if p.is_null() {
        return;
    }
    decimal_result(context, p);
}
unsafe extern "C" fn decimalSumFinalize(mut context: *mut sqlite3_context) {
    let mut p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int)
        as *mut Decimal;
    if p.is_null() {
        return;
    }
    decimal_result(context, p);
    decimal_clear(p);
}
unsafe extern "C" fn decimalMulFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut acc: *mut libc::c_schar = 0 as *mut libc::c_schar;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut minFrac: libc::c_int = 0;
    if !(pA.is_null() || (*pA).oom as libc::c_int != 0
        || (*pA).isNull as libc::c_int != 0 || pB.is_null()
        || (*pB).oom as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0)
    {
        acc = sqlite3_malloc64(
            ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_schar;
        if acc.is_null() {
            sqlite3_result_error_nomem(context);
        } else {
            memset(
                acc as *mut libc::c_void,
                0 as libc::c_int,
                ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as libc::c_ulong,
            );
            minFrac = (*pA).nFrac;
            if (*pB).nFrac < minFrac {
                minFrac = (*pB).nFrac;
            }
            i = (*pA).nDigit - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let mut f: libc::c_schar = *((*pA).a).offset(i as isize);
                let mut carry: libc::c_int = 0 as libc::c_int;
                let mut x: libc::c_int = 0;
                j = (*pB).nDigit - 1 as libc::c_int;
                k = i + j + 3 as libc::c_int;
                while j >= 0 as libc::c_int {
                    x = *acc.offset(k as isize) as libc::c_int
                        + f as libc::c_int * *((*pB).a).offset(j as isize) as libc::c_int
                        + carry;
                    *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                    carry = x / 10 as libc::c_int;
                    j -= 1;
                    k -= 1;
                }
                x = *acc.offset(k as isize) as libc::c_int + carry;
                *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                let ref mut fresh10 = *acc.offset((k - 1 as libc::c_int) as isize);
                *fresh10 = (*fresh10 as libc::c_int + x / 10 as libc::c_int)
                    as libc::c_schar;
                i -= 1;
            }
            sqlite3_free((*pA).a as *mut libc::c_void);
            (*pA).a = acc;
            acc = 0 as *mut libc::c_schar;
            (*pA).nDigit += (*pB).nDigit + 2 as libc::c_int;
            (*pA).nFrac += (*pB).nFrac;
            (*pA)
                .sign = ((*pA).sign as libc::c_int ^ (*pB).sign as libc::c_int)
                as libc::c_char;
            while (*pA).nFrac > minFrac
                && *((*pA).a).offset(((*pA).nDigit - 1 as libc::c_int) as isize)
                    as libc::c_int == 0 as libc::c_int
            {
                (*pA).nFrac -= 1;
                (*pA).nDigit -= 1;
            }
            decimal_result(context, pA);
        }
    }
    sqlite3_free(acc as *mut libc::c_void);
    decimal_free(pA);
    decimal_free(pB);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_decimal_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    static mut aFunc: [C2RustUnnamed_16; 5] = unsafe {
        [
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal\0" as *const u8 as *const libc::c_char,
                    nArg: 1 as libc::c_int,
                    xFunc: Some(
                        decimalFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_cmp\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalCmpFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_add\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalAddFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_sub\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalSubFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_mul\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalMulFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::core::mem::size_of::<[C2RustUnnamed_16; 5]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_16>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFuncName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1);
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_window_function(
            db,
            b"decimal_sum\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalSumStep
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(decimalSumFinalize as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
            Some(decimalSumValue as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
            Some(
                decimalSumInverse
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_collation(
            db,
            b"decimal\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalCollFunc
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_void,
                        libc::c_int,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
    }
    return rc;
}
unsafe extern "C" fn ieee754func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if argc == 1 as libc::c_int {
        let mut m: sqlite3_int64 = 0;
        let mut a: sqlite3_int64 = 0;
        let mut r: libc::c_double = 0.;
        let mut e: libc::c_int = 0;
        let mut isNeg: libc::c_int = 0;
        let mut zResult: [libc::c_char; 100] = [0; 100];
        if ::core::mem::size_of::<sqlite3_int64>() as libc::c_ulong
            == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {} else {
            __assert_fail(
                b"sizeof(m)==sizeof(r)\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                3079 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 59],
                    &[libc::c_char; 59],
                >(b"void ieee754func(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
        if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 4 as libc::c_int
            && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
                as libc::c_ulong
                == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            let mut x: *const libc::c_uchar = sqlite3_value_blob(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const libc::c_uchar;
            let mut i: libc::c_uint = 0;
            let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
            i = 0 as libc::c_int as libc::c_uint;
            while (i as libc::c_ulong)
                < ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
            {
                v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
                i = i.wrapping_add(1);
            }
            memcpy(
                &mut r as *mut libc::c_double as *mut libc::c_void,
                &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
            );
        } else {
            r = sqlite3_value_double(*argv.offset(0 as libc::c_int as isize));
        }
        if r < 0.0f64 {
            isNeg = 1 as libc::c_int;
            r = -r;
        } else {
            isNeg = 0 as libc::c_int;
        }
        memcpy(
            &mut a as *mut sqlite3_int64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::core::mem::size_of::<sqlite3_int64>() as libc::c_ulong,
        );
        if a == 0 as libc::c_int as libc::c_longlong {
            e = 0 as libc::c_int;
            m = 0 as libc::c_int as sqlite3_int64;
        } else {
            e = (a >> 52 as libc::c_int) as libc::c_int;
            m = a
                & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                    - 1 as libc::c_int as libc::c_longlong;
            if e == 0 as libc::c_int {
                m <<= 1 as libc::c_int;
            } else {
                m |= (1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int;
            }
            while e < 1075 as libc::c_int && m > 0 as libc::c_int as libc::c_longlong
                && m & 1 as libc::c_int as libc::c_longlong
                    == 0 as libc::c_int as libc::c_longlong
            {
                m >>= 1 as libc::c_int;
                e += 1;
            }
            if isNeg != 0 {
                m = -m;
            }
        }
        match *(sqlite3_user_data(context) as *mut libc::c_int) {
            0 => {
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                        as libc::c_int,
                    zResult.as_mut_ptr(),
                    b"ieee754(%lld,%d)\0" as *const u8 as *const libc::c_char,
                    m,
                    e - 1075 as libc::c_int,
                );
                sqlite3_result_text(
                    context,
                    zResult.as_mut_ptr(),
                    -(1 as libc::c_int),
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            }
            1 => {
                sqlite3_result_int64(context, m);
            }
            2 => {
                sqlite3_result_int(context, e - 1075 as libc::c_int);
            }
            _ => {}
        }
    } else {
        let mut m_0: sqlite3_int64 = 0;
        let mut e_0: sqlite3_int64 = 0;
        let mut a_0: sqlite3_int64 = 0;
        let mut r_0: libc::c_double = 0.;
        let mut isNeg_0: libc::c_int = 0 as libc::c_int;
        m_0 = sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize));
        e_0 = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        if e_0 > 10000 as libc::c_int as libc::c_longlong {
            e_0 = 10000 as libc::c_int as sqlite3_int64;
        } else if e_0 < -(10000 as libc::c_int) as libc::c_longlong {
            e_0 = -(10000 as libc::c_int) as sqlite3_int64;
        }
        if m_0 < 0 as libc::c_int as libc::c_longlong {
            isNeg_0 = 1 as libc::c_int;
            m_0 = -m_0;
            if m_0 < 0 as libc::c_int as libc::c_longlong {
                return;
            }
        } else if m_0 == 0 as libc::c_int as libc::c_longlong
            && e_0 > -(1000 as libc::c_int) as libc::c_longlong
            && e_0 < 1000 as libc::c_int as libc::c_longlong
        {
            sqlite3_result_double(context, 0.0f64);
            return;
        }
        while m_0 >> 32 as libc::c_int & 0xffe00000 as libc::c_uint as libc::c_longlong
            != 0
        {
            m_0 >>= 1 as libc::c_int;
            e_0 += 1;
        }
        while m_0 != 0 as libc::c_int as libc::c_longlong
            && m_0 >> 32 as libc::c_int & 0xfff00000 as libc::c_uint as libc::c_longlong
                == 0 as libc::c_int as libc::c_longlong
        {
            m_0 <<= 1 as libc::c_int;
            e_0 -= 1;
        }
        e_0 += 1075 as libc::c_int as libc::c_longlong;
        if e_0 <= 0 as libc::c_int as libc::c_longlong {
            if 1 as libc::c_int as libc::c_longlong - e_0
                >= 64 as libc::c_int as libc::c_longlong
            {
                m_0 = 0 as libc::c_int as sqlite3_int64;
            } else {
                m_0 >>= 1 as libc::c_int as libc::c_longlong - e_0;
            }
            e_0 = 0 as libc::c_int as sqlite3_int64;
        } else if e_0 > 0x7ff as libc::c_int as libc::c_longlong {
            e_0 = 0x7ff as libc::c_int as sqlite3_int64;
        }
        a_0 = m_0
            & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong;
        a_0 |= e_0 << 52 as libc::c_int;
        if isNeg_0 != 0 {
            a_0 = (a_0 as libc::c_ulonglong
                | (1 as libc::c_int as sqlite3_uint64) << 63 as libc::c_int)
                as sqlite3_int64;
        }
        memcpy(
            &mut r_0 as *mut libc::c_double as *mut libc::c_void,
            &mut a_0 as *mut sqlite3_int64 as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r_0);
    };
}
unsafe extern "C" fn ieee754func_from_blob(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int
        && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as libc::c_ulong
            == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
    {
        let mut r: libc::c_double = 0.;
        let mut x: *const libc::c_uchar = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const libc::c_uchar;
        let mut i: libc::c_uint = 0;
        let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong)
            < ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
            i = i.wrapping_add(1);
        }
        memcpy(
            &mut r as *mut libc::c_double as *mut libc::c_void,
            &mut v as *mut sqlite3_uint64 as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r);
    }
}
unsafe extern "C" fn ieee754func_to_blob(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 2 as libc::c_int
        || sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 1 as libc::c_int
    {
        let mut r: libc::c_double = sqlite3_value_double(
            *argv.offset(0 as libc::c_int as isize),
        );
        let mut v: sqlite3_uint64 = 0;
        let mut a: [libc::c_uchar; 8] = [0; 8];
        let mut i: libc::c_uint = 0;
        memcpy(
            &mut v as *mut sqlite3_uint64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        i = 1 as libc::c_int as libc::c_uint;
        while i as libc::c_ulong
            <= ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            a[(::core::mem::size_of::<libc::c_double>() as libc::c_ulong)
                .wrapping_sub(i as libc::c_ulong)
                as usize] = (v & 0xff as libc::c_int as libc::c_ulonglong)
                as libc::c_uchar;
            v >>= 8 as libc::c_int;
            i = i.wrapping_add(1);
        }
        sqlite3_result_blob(
            context,
            a.as_mut_ptr() as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong as libc::c_int,
            ::core::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_ieee_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    static mut aFunc: [C2RustUnnamed_17; 6] = unsafe {
        [
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 2 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_mantissa\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 1 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_exponent\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 2 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_to_blob\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_to_blob
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_from_blob\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_from_blob
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::core::mem::size_of::<[C2RustUnnamed_17; 6]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int,
            &(*aFunc.as_ptr().offset(i as isize)).iAux as *const libc::c_int
                as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1);
    }
    return rc;
}
unsafe extern "C" fn seriesConnect(
    mut db: *mut sqlite3,
    mut pUnused: *mut libc::c_void,
    mut argcUnused: libc::c_int,
    mut argvUnused: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErrUnused: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut sqlite3_vtab = 0 as *mut sqlite3_vtab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(value,start hidden,stop hidden,step hidden)\0" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        *ppVtab = sqlite3_malloc(
            ::core::mem::size_of::<sqlite3_vtab>() as libc::c_ulong as libc::c_int,
        ) as *mut sqlite3_vtab;
        pNew = *ppVtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<sqlite3_vtab>() as libc::c_ulong,
        );
        sqlite3_vtab_config(db, 2 as libc::c_int);
    }
    return rc;
}
unsafe extern "C" fn seriesDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesOpen(
    mut pUnused: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = 0 as *mut series_cursor;
    pCur = sqlite3_malloc(
        ::core::mem::size_of::<series_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut series_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<series_cursor>() as libc::c_ulong,
    );
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    if (*pCur).isDesc != 0 {
        (*pCur).iValue -= (*pCur).iStep;
    } else {
        (*pCur).iValue += (*pCur).iStep;
    }
    (*pCur).iRowid += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    let mut x: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    match i {
        1 => {
            x = (*pCur).mnValue;
        }
        2 => {
            x = (*pCur).mxValue;
        }
        3 => {
            x = (*pCur).iStep;
        }
        _ => {
            x = (*pCur).iValue;
        }
    }
    sqlite3_result_int64(ctx, x);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    if (*pCur).isDesc != 0 {
        return ((*pCur).iValue < (*pCur).mnValue) as libc::c_int
    } else {
        return ((*pCur).iValue > (*pCur).mxValue) as libc::c_int
    };
}
unsafe extern "C" fn seriesFilter(
    mut pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStrUnused: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = pVtabCursor as *mut series_cursor;
    let mut i: libc::c_int = 0 as libc::c_int;
    if idxNum & 1 as libc::c_int != 0 {
        let fresh11 = i;
        i = i + 1;
        (*pCur).mnValue = sqlite3_value_int64(*argv.offset(fresh11 as isize));
    } else {
        (*pCur).mnValue = 0 as libc::c_int as sqlite3_int64;
    }
    if idxNum & 2 as libc::c_int != 0 {
        let fresh12 = i;
        i = i + 1;
        (*pCur).mxValue = sqlite3_value_int64(*argv.offset(fresh12 as isize));
    } else {
        (*pCur).mxValue = 0xffffffff as libc::c_uint as sqlite3_int64;
    }
    if idxNum & 4 as libc::c_int != 0 {
        let fresh13 = i;
        i = i + 1;
        (*pCur).iStep = sqlite3_value_int64(*argv.offset(fresh13 as isize));
        if (*pCur).iStep == 0 as libc::c_int as libc::c_longlong {
            (*pCur).iStep = 1 as libc::c_int as sqlite3_int64;
        } else if (*pCur).iStep < 0 as libc::c_int as libc::c_longlong {
            (*pCur).iStep = -(*pCur).iStep;
            if idxNum & 16 as libc::c_int == 0 as libc::c_int {
                idxNum |= 8 as libc::c_int;
            }
        }
    } else {
        (*pCur).iStep = 1 as libc::c_int as sqlite3_int64;
    }
    i = 0 as libc::c_int;
    while i < argc {
        if sqlite3_value_type(*argv.offset(i as isize)) == 5 as libc::c_int {
            (*pCur).mnValue = 1 as libc::c_int as sqlite3_int64;
            (*pCur).mxValue = 0 as libc::c_int as sqlite3_int64;
            break;
        } else {
            i += 1;
        }
    }
    if idxNum & 8 as libc::c_int != 0 {
        (*pCur).isDesc = 1 as libc::c_int;
        (*pCur).iValue = (*pCur).mxValue;
        if (*pCur).iStep > 0 as libc::c_int as libc::c_longlong {
            (*pCur).iValue -= ((*pCur).mxValue - (*pCur).mnValue) % (*pCur).iStep;
        }
    } else {
        (*pCur).isDesc = 0 as libc::c_int;
        (*pCur).iValue = (*pCur).mnValue;
    }
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesBestIndex(
    mut pVTab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut idxNum: libc::c_int = 0 as libc::c_int;
    let mut bStartSeen: libc::c_int = 0 as libc::c_int;
    let mut unusableMask: libc::c_int = 0 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut aIdx: [libc::c_int; 3] = [0; 3];
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    if 2 as libc::c_int == 1 as libc::c_int + 1 as libc::c_int {} else {
        __assert_fail(
            b"SERIES_COLUMN_STOP == SERIES_COLUMN_START+1\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            3601 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                .as_ptr(),
        );
    }
    if 3 as libc::c_int == 1 as libc::c_int + 2 as libc::c_int {} else {
        __assert_fail(
            b"SERIES_COLUMN_STEP == SERIES_COLUMN_START+2\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            3602 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                .as_ptr(),
        );
    }
    aIdx[2 as libc::c_int as usize] = -(1 as libc::c_int);
    aIdx[1 as libc::c_int as usize] = aIdx[2 as libc::c_int as usize];
    aIdx[0 as libc::c_int as usize] = aIdx[1 as libc::c_int as usize];
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let mut iCol: libc::c_int = 0;
        let mut iMask: libc::c_int = 0;
        if !((*pConstraint).iColumn < 1 as libc::c_int) {
            iCol = (*pConstraint).iColumn - 1 as libc::c_int;
            if iCol >= 0 as libc::c_int && iCol <= 2 as libc::c_int {} else {
                __assert_fail(
                    b"iCol>=0 && iCol<=2\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    3611 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 58],
                        &[libc::c_char; 58],
                    >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                        .as_ptr(),
                );
            }
            iMask = (1 as libc::c_int) << iCol;
            if iCol == 0 as libc::c_int {
                bStartSeen = 1 as libc::c_int;
            }
            if (*pConstraint).usable as libc::c_int == 0 as libc::c_int {
                unusableMask |= iMask;
            } else if (*pConstraint).op as libc::c_int == 2 as libc::c_int {
                idxNum |= iMask;
                aIdx[iCol as usize] = i;
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1);
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        j = aIdx[i as usize];
        if j >= 0 as libc::c_int {
            nArg += 1;
            (*((*pIdxInfo).aConstraintUsage).offset(j as isize)).argvIndex = nArg;
            (*((*pIdxInfo).aConstraintUsage).offset(j as isize))
                .omit = (0 as libc::c_int == 0) as libc::c_int as libc::c_uchar;
        }
        i += 1;
    }
    if bStartSeen == 0 {
        sqlite3_free((*pVTab).zErrMsg as *mut libc::c_void);
        (*pVTab)
            .zErrMsg = sqlite3_mprintf(
            b"first argument to \"generate_series()\" missing or unusable\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if unusableMask & !idxNum != 0 as libc::c_int {
        return 19 as libc::c_int;
    }
    if idxNum & 3 as libc::c_int == 3 as libc::c_int {
        (*pIdxInfo)
            .estimatedCost = (2 as libc::c_int
            - (idxNum & 4 as libc::c_int != 0 as libc::c_int) as libc::c_int)
            as libc::c_double;
        (*pIdxInfo).estimatedRows = 1000 as libc::c_int as sqlite3_int64;
        if (*pIdxInfo).nOrderBy >= 1 as libc::c_int
            && (*((*pIdxInfo).aOrderBy).offset(0 as libc::c_int as isize)).iColumn
                == 0 as libc::c_int
        {
            if (*((*pIdxInfo).aOrderBy).offset(0 as libc::c_int as isize)).desc != 0 {
                idxNum |= 8 as libc::c_int;
            } else {
                idxNum |= 16 as libc::c_int;
            }
            (*pIdxInfo).orderByConsumed = 1 as libc::c_int;
        }
    } else {
        (*pIdxInfo).estimatedRows = 2147483647 as libc::c_int as sqlite3_int64;
    }
    (*pIdxInfo).idxNum = idxNum;
    return 0 as libc::c_int;
}
static mut seriesModule: sqlite3_module = unsafe {
    {
        let mut init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                seriesConnect
                    as unsafe extern "C" fn(
                        *mut sqlite3,
                        *mut libc::c_void,
                        libc::c_int,
                        *const *const libc::c_char,
                        *mut *mut sqlite3_vtab,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                seriesBestIndex
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                seriesDisconnect
                    as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                seriesOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                seriesClose
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                seriesFilter
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        libc::c_int,
                        *const libc::c_char,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                seriesNext
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                seriesEof
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                seriesColumn
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite3_context,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                seriesRowid
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3_series_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sqlite3_libversion_number() < 3008012 as libc::c_int && !pzErrMsg.is_null() {
        *pzErrMsg = sqlite3_mprintf(
            b"generate_series() requires SQLite 3.8.12 or later\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    rc = sqlite3_create_module(
        db,
        b"generate_series\0" as *const u8 as *const libc::c_char,
        &mut seriesModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
unsafe extern "C" fn re_add_state(mut pSet: *mut ReStateSet, mut newState: libc::c_int) {
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*pSet).nState {
        if *((*pSet).aState).offset(i as isize) as libc::c_int == newState {
            return;
        }
        i = i.wrapping_add(1);
    }
    let fresh14 = (*pSet).nState;
    (*pSet).nState = ((*pSet).nState).wrapping_add(1);
    *((*pSet).aState).offset(fresh14 as isize) = newState as ReStateNumber;
}
unsafe extern "C" fn re_next_char(mut p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = 0;
    if (*p).i >= (*p).mx {
        return 0 as libc::c_int as libc::c_uint;
    }
    let fresh15 = (*p).i;
    (*p).i = (*p).i + 1;
    c = *((*p).z).offset(fresh15 as isize) as libc::c_uint;
    if c >= 0x80 as libc::c_int as libc::c_uint {
        if c & 0xe0 as libc::c_int as libc::c_uint == 0xc0 as libc::c_int as libc::c_uint
            && (*p).i < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
        {
            let fresh16 = (*p).i;
            (*p).i = (*p).i + 1;
            c = (c & 0x1f as libc::c_int as libc::c_uint) << 6 as libc::c_int
                | (*((*p).z).offset(fresh16 as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            if c < 0x80 as libc::c_int as libc::c_uint {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else if c & 0xf0 as libc::c_int as libc::c_uint
            == 0xe0 as libc::c_int as libc::c_uint
            && ((*p).i + 1 as libc::c_int) < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            c = (c & 0xf as libc::c_int as libc::c_uint) << 12 as libc::c_int
                | ((*((*p).z).offset((*p).i as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                | (*((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            (*p).i += 2 as libc::c_int;
            if c <= 0x7ff as libc::c_int as libc::c_uint
                || c >= 0xd800 as libc::c_int as libc::c_uint
                    && c <= 0xdfff as libc::c_int as libc::c_uint
            {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else if c & 0xf8 as libc::c_int as libc::c_uint
            == 0xf0 as libc::c_int as libc::c_uint
            && ((*p).i + 3 as libc::c_int) < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            c = (c & 0x7 as libc::c_int as libc::c_uint) << 18 as libc::c_int
                | ((*((*p).z).offset((*p).i as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 12 as libc::c_int) as libc::c_uint
                | ((*((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                | (*((*p).z).offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            (*p).i += 3 as libc::c_int;
            if c <= 0xffff as libc::c_int as libc::c_uint
                || c > 0x10ffff as libc::c_int as libc::c_uint
            {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else {
            c = 0xfffd as libc::c_int as libc::c_uint;
        }
    }
    return c;
}
unsafe extern "C" fn re_next_char_nocase(mut p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = re_next_char(p);
    if c >= 'A' as i32 as libc::c_uint && c <= 'Z' as i32 as libc::c_uint {
        c = c.wrapping_add(('a' as i32 - 'A' as i32) as libc::c_uint);
    }
    return c;
}
unsafe extern "C" fn re_word_char(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32 || c >= 'a' as i32 && c <= 'z' as i32
        || c >= 'A' as i32 && c <= 'Z' as i32 || c == '_' as i32) as libc::c_int;
}
unsafe extern "C" fn re_digit_char(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
unsafe extern "C" fn re_space_char(mut c: libc::c_int) -> libc::c_int {
    return (c == ' ' as i32 || c == '\t' as i32 || c == '\n' as i32 || c == '\r' as i32
        || c == '\u{b}' as i32 || c == '\u{c}' as i32) as libc::c_int;
}
unsafe extern "C" fn sqlite3re_match(
    mut pRe: *mut ReCompiled,
    mut zIn: *const libc::c_uchar,
    mut nIn: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut aStateSet: [ReStateSet; 2] = [ReStateSet {
        nState: 0,
        aState: 0 as *mut ReStateNumber,
    }; 2];
    let mut pThis: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut pNext: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut aSpace: [ReStateNumber; 100] = [0; 100];
    let mut pToFree: *mut ReStateNumber = 0 as *mut ReStateNumber;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut iSwap: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut c: libc::c_int = 0 as libc::c_int + 1 as libc::c_int;
    let mut cPrev: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut in_0: ReInput = ReInput {
        z: 0 as *const libc::c_uchar,
        i: 0,
        mx: 0,
    };
    in_0.z = zIn;
    in_0.i = 0 as libc::c_int;
    in_0
        .mx = if nIn >= 0 as libc::c_int {
        nIn
    } else {
        strlen(zIn as *const libc::c_char) as libc::c_int
    };
    if (*pRe).nInit != 0 {
        let mut x: libc::c_uchar = (*pRe).zInit[0 as libc::c_int as usize];
        while in_0.i + (*pRe).nInit <= in_0.mx
            && (*zIn.offset(in_0.i as isize) as libc::c_int != x as libc::c_int
                || strncmp(
                    (zIn as *const libc::c_char).offset(in_0.i as isize),
                    ((*pRe).zInit).as_mut_ptr() as *const libc::c_char,
                    (*pRe).nInit as libc::c_ulong,
                ) != 0 as libc::c_int)
        {
            in_0.i += 1;
        }
        if in_0.i + (*pRe).nInit > in_0.mx {
            return 0 as libc::c_int;
        }
    }
    if (*pRe).nState as libc::c_ulong
        <= (::core::mem::size_of::<[ReStateNumber; 100]>() as libc::c_ulong)
            .wrapping_div(
                (::core::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                    .wrapping_mul(2 as libc::c_int as libc::c_ulong),
            )
    {
        pToFree = 0 as *mut ReStateNumber;
        aStateSet[0 as libc::c_int as usize].aState = aSpace.as_mut_ptr();
    } else {
        pToFree = sqlite3_malloc64(
            (::core::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                .wrapping_mul((*pRe).nState as libc::c_ulong) as sqlite3_uint64,
        ) as *mut ReStateNumber;
        if pToFree.is_null() {
            return -(1 as libc::c_int);
        }
        aStateSet[0 as libc::c_int as usize].aState = pToFree;
    }
    aStateSet[1 as libc::c_int as usize]
        .aState = &mut *((*aStateSet.as_mut_ptr().offset(0 as libc::c_int as isize))
        .aState)
        .offset((*pRe).nState as isize) as *mut ReStateNumber;
    pNext = &mut *aStateSet.as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut ReStateSet;
    (*pNext).nState = 0 as libc::c_int as libc::c_uint;
    re_add_state(pNext, 0 as libc::c_int);
    's_104: loop {
        if !(c != 0 as libc::c_int && (*pNext).nState > 0 as libc::c_int as libc::c_uint)
        {
            current_block = 576355610076403033;
            break;
        }
        cPrev = c;
        c = ((*pRe).xNextChar).expect("non-null function pointer")(&mut in_0)
            as libc::c_int;
        pThis = pNext;
        pNext = &mut *aStateSet.as_mut_ptr().offset(iSwap as isize) as *mut ReStateSet;
        iSwap = (1 as libc::c_int as libc::c_uint).wrapping_sub(iSwap);
        (*pNext).nState = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*pThis).nState {
            let mut x_0: libc::c_int = *((*pThis).aState).offset(i as isize)
                as libc::c_int;
            match *((*pRe).aOp).offset(x_0 as isize) as libc::c_int {
                1 => {
                    if *((*pRe).aArg).offset(x_0 as isize) == c {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                2 => {
                    if c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                11 => {
                    if re_word_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                12 => {
                    if re_word_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                13 => {
                    if re_digit_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                14 => {
                    if re_digit_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                15 => {
                    if re_space_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                16 => {
                    if re_space_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                17 => {
                    if re_word_char(c) != re_word_char(cPrev) {
                        re_add_state(pThis, x_0 + 1 as libc::c_int);
                    }
                    current_block = 7172762164747879670;
                }
                3 => {
                    re_add_state(pNext, x_0);
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 7172762164747879670;
                }
                4 => {
                    re_add_state(pThis, x_0 + *((*pRe).aArg).offset(x_0 as isize));
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 7172762164747879670;
                }
                5 => {
                    re_add_state(pThis, x_0 + *((*pRe).aArg).offset(x_0 as isize));
                    current_block = 7172762164747879670;
                }
                6 => {
                    rc = 1 as libc::c_int;
                    current_block = 5931832752456304075;
                    break 's_104;
                }
                8 => {
                    if c == 0 as libc::c_int {
                        current_block = 7172762164747879670;
                    } else {
                        current_block = 8835654301469918283;
                    }
                }
                7 => {
                    current_block = 8835654301469918283;
                }
                _ => {
                    current_block = 7172762164747879670;
                }
            }
            match current_block {
                8835654301469918283 => {
                    let mut j: libc::c_int = 1 as libc::c_int;
                    let mut n: libc::c_int = *((*pRe).aArg).offset(x_0 as isize);
                    let mut hit: libc::c_int = 0 as libc::c_int;
                    j = 1 as libc::c_int;
                    while j > 0 as libc::c_int && j < n {
                        if *((*pRe).aOp).offset((x_0 + j) as isize) as libc::c_int
                            == 9 as libc::c_int
                        {
                            if *((*pRe).aArg).offset((x_0 + j) as isize) == c {
                                hit = 1 as libc::c_int;
                                j = -(1 as libc::c_int);
                            }
                        } else if *((*pRe).aArg).offset((x_0 + j) as isize) <= c
                            && *((*pRe).aArg)
                                .offset((x_0 + j + 1 as libc::c_int) as isize) >= c
                        {
                            hit = 1 as libc::c_int;
                            j = -(1 as libc::c_int);
                        } else {
                            j += 1;
                        }
                        j += 1;
                    }
                    if *((*pRe).aOp).offset(x_0 as isize) as libc::c_int
                        == 8 as libc::c_int
                    {
                        hit = (hit == 0) as libc::c_int;
                    }
                    if hit != 0 {
                        re_add_state(pNext, x_0 + n);
                    }
                }
                _ => {}
            }
            i = i.wrapping_add(1);
        }
    }
    match current_block {
        576355610076403033 => {
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*pNext).nState {
                if *((*pRe).aOp).offset(*((*pNext).aState).offset(i as isize) as isize)
                    as libc::c_int == 6 as libc::c_int
                {
                    rc = 1 as libc::c_int;
                    break;
                } else {
                    i = i.wrapping_add(1);
                }
            }
        }
        _ => {}
    }
    sqlite3_free(pToFree as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn re_resize(
    mut p: *mut ReCompiled,
    mut N: libc::c_int,
) -> libc::c_int {
    let mut aOp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aArg: *mut libc::c_int = 0 as *mut libc::c_int;
    aOp = sqlite3_realloc64(
        (*p).aOp as *mut libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_char;
    if aOp.is_null() {
        return 1 as libc::c_int;
    }
    (*p).aOp = aOp;
    aArg = sqlite3_realloc64(
        (*p).aArg as *mut libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_int;
    if aArg.is_null() {
        return 1 as libc::c_int;
    }
    (*p).aArg = aArg;
    (*p).nAlloc = N as libc::c_uint;
    return 0 as libc::c_int;
}
unsafe extern "C" fn re_insert(
    mut p: *mut ReCompiled,
    mut iBefore: libc::c_int,
    mut op: libc::c_int,
    mut arg: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if (*p).nAlloc <= (*p).nState
        && re_resize(
            p,
            ((*p).nAlloc).wrapping_mul(2 as libc::c_int as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return 0 as libc::c_int;
    }
    i = (*p).nState as libc::c_int;
    while i > iBefore {
        *((*p).aOp)
            .offset(i as isize) = *((*p).aOp).offset((i - 1 as libc::c_int) as isize);
        *((*p).aArg)
            .offset(i as isize) = *((*p).aArg).offset((i - 1 as libc::c_int) as isize);
        i -= 1;
    }
    (*p).nState = ((*p).nState).wrapping_add(1);
    *((*p).aOp).offset(iBefore as isize) = op as libc::c_char;
    *((*p).aArg).offset(iBefore as isize) = arg;
    return iBefore;
}
unsafe extern "C" fn re_append(
    mut p: *mut ReCompiled,
    mut op: libc::c_int,
    mut arg: libc::c_int,
) -> libc::c_int {
    return re_insert(p, (*p).nState as libc::c_int, op, arg);
}
unsafe extern "C" fn re_copy(
    mut p: *mut ReCompiled,
    mut iStart: libc::c_int,
    mut N: libc::c_int,
) {
    if ((*p).nState).wrapping_add(N as libc::c_uint) >= (*p).nAlloc
        && re_resize(
            p,
            ((*p).nAlloc)
                .wrapping_mul(2 as libc::c_int as libc::c_uint)
                .wrapping_add(N as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return;
    }
    memcpy(
        &mut *((*p).aOp).offset((*p).nState as isize) as *mut libc::c_char
            as *mut libc::c_void,
        &mut *((*p).aOp).offset(iStart as isize) as *mut libc::c_char
            as *const libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    memcpy(
        &mut *((*p).aArg).offset((*p).nState as isize) as *mut libc::c_int
            as *mut libc::c_void,
        &mut *((*p).aArg).offset(iStart as isize) as *mut libc::c_int
            as *const libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*p).nState = ((*p).nState).wrapping_add(N as libc::c_uint);
}
unsafe extern "C" fn re_hex(
    mut c: libc::c_int,
    mut pV: *mut libc::c_int,
) -> libc::c_int {
    if c >= '0' as i32 && c <= '9' as i32 {
        c -= '0' as i32;
    } else if c >= 'a' as i32 && c <= 'f' as i32 {
        c -= 'a' as i32 - 10 as libc::c_int;
    } else if c >= 'A' as i32 && c <= 'F' as i32 {
        c -= 'A' as i32 - 10 as libc::c_int;
    } else {
        return 0 as libc::c_int
    }
    *pV = *pV * 16 as libc::c_int + (c & 0xff as libc::c_int);
    return 1 as libc::c_int;
}
unsafe extern "C" fn re_esc_char(mut p: *mut ReCompiled) -> libc::c_uint {
    static mut zEsc: [libc::c_char; 21] = unsafe {
        *::core::mem::transmute::<
            &[u8; 21],
            &[libc::c_char; 21],
        >(b"afnrtv\\()*.+?[$^{|}]\0")
    };
    static mut zTrans: [libc::c_char; 7] = unsafe {
        *::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"\x07\x0C\n\r\t\x0B\0")
    };
    let mut i: libc::c_int = 0;
    let mut v: libc::c_int = 0 as libc::c_int;
    let mut c: libc::c_char = 0;
    if (*p).sIn.i >= (*p).sIn.mx {
        return 0 as libc::c_int as libc::c_uint;
    }
    c = *((*p).sIn.z).offset((*p).sIn.i as isize) as libc::c_char;
    if c as libc::c_int == 'u' as i32 && ((*p).sIn.i + 4 as libc::c_int) < (*p).sIn.mx {
        let mut zIn: *const libc::c_uchar = ((*p).sIn.z).offset((*p).sIn.i as isize);
        if re_hex(*zIn.offset(1 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(2 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(3 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(4 as libc::c_int as isize) as libc::c_int, &mut v) != 0
        {
            (*p).sIn.i += 5 as libc::c_int;
            return v as libc::c_uint;
        }
    }
    if c as libc::c_int == 'x' as i32 && ((*p).sIn.i + 2 as libc::c_int) < (*p).sIn.mx {
        let mut zIn_0: *const libc::c_uchar = ((*p).sIn.z).offset((*p).sIn.i as isize);
        if re_hex(*zIn_0.offset(1 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn_0.offset(2 as libc::c_int as isize) as libc::c_int, &mut v)
                != 0
        {
            (*p).sIn.i += 3 as libc::c_int;
            return v as libc::c_uint;
        }
    }
    i = 0 as libc::c_int;
    while zEsc[i as usize] as libc::c_int != 0
        && zEsc[i as usize] as libc::c_int != c as libc::c_int
    {
        i += 1;
    }
    if zEsc[i as usize] != 0 {
        if i < 6 as libc::c_int {
            c = zTrans[i as usize];
        }
        (*p).sIn.i += 1;
    } else {
        (*p).zErr = b"unknown \\ escape\0" as *const u8 as *const libc::c_char;
    }
    return c as libc::c_uint;
}
unsafe extern "C" fn rePeek(mut p: *mut ReCompiled) -> libc::c_uchar {
    return (if (*p).sIn.i < (*p).sIn.mx {
        *((*p).sIn.z).offset((*p).sIn.i as isize) as libc::c_int
    } else {
        0 as libc::c_int
    }) as libc::c_uchar;
}
unsafe extern "C" fn re_subcompile_re(mut p: *mut ReCompiled) -> *const libc::c_char {
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut iStart: libc::c_int = 0;
    let mut iEnd: libc::c_int = 0;
    let mut iGoto: libc::c_int = 0;
    iStart = (*p).nState as libc::c_int;
    zErr = re_subcompile_string(p);
    if !zErr.is_null() {
        return zErr;
    }
    while rePeek(p) as libc::c_int == '|' as i32 {
        iEnd = (*p).nState as libc::c_int;
        re_insert(p, iStart, 4 as libc::c_int, iEnd + 2 as libc::c_int - iStart);
        iGoto = re_append(p, 5 as libc::c_int, 0 as libc::c_int);
        (*p).sIn.i += 1;
        zErr = re_subcompile_string(p);
        if !zErr.is_null() {
            return zErr;
        }
        *((*p).aArg)
            .offset(
                iGoto as isize,
            ) = ((*p).nState).wrapping_sub(iGoto as libc::c_uint) as libc::c_int;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn re_subcompile_string(
    mut p: *mut ReCompiled,
) -> *const libc::c_char {
    let mut iPrev: libc::c_int = -(1 as libc::c_int);
    let mut iStart: libc::c_int = 0;
    let mut c: libc::c_uint = 0;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        c = ((*p).xNextChar).expect("non-null function pointer")(&mut (*p).sIn);
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        iStart = (*p).nState as libc::c_int;
        match c {
            124 | 36 | 41 => {
                (*p).sIn.i -= 1;
                return 0 as *const libc::c_char;
            }
            40 => {
                zErr = re_subcompile_re(p);
                if !zErr.is_null() {
                    return zErr;
                }
                if rePeek(p) as libc::c_int != ')' as i32 {
                    return b"unmatched '('\0" as *const u8 as *const libc::c_char;
                }
                (*p).sIn.i += 1;
            }
            46 => {
                if rePeek(p) as libc::c_int == '*' as i32 {
                    re_append(p, 3 as libc::c_int, 0 as libc::c_int);
                    (*p).sIn.i += 1;
                } else {
                    re_append(p, 2 as libc::c_int, 0 as libc::c_int);
                }
            }
            42 => {
                if iPrev < 0 as libc::c_int {
                    return b"'*' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_insert(
                    p,
                    iPrev,
                    5 as libc::c_int,
                    ((*p).nState)
                        .wrapping_sub(iPrev as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
                re_append(
                    p,
                    4 as libc::c_int,
                    (iPrev as libc::c_uint)
                        .wrapping_sub((*p).nState)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
            }
            43 => {
                if iPrev < 0 as libc::c_int {
                    return b"'+' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_append(
                    p,
                    4 as libc::c_int,
                    (iPrev as libc::c_uint).wrapping_sub((*p).nState) as libc::c_int,
                );
            }
            63 => {
                if iPrev < 0 as libc::c_int {
                    return b"'?' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_insert(
                    p,
                    iPrev,
                    4 as libc::c_int,
                    ((*p).nState)
                        .wrapping_sub(iPrev as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
            }
            123 => {
                let mut m: libc::c_int = 0 as libc::c_int;
                let mut n: libc::c_int = 0 as libc::c_int;
                let mut sz: libc::c_int = 0;
                let mut j: libc::c_int = 0;
                if iPrev < 0 as libc::c_int {
                    return b"'{m,n}' without operand\0" as *const u8
                        as *const libc::c_char;
                }
                loop {
                    c = rePeek(p) as libc::c_uint;
                    if !(c >= '0' as i32 as libc::c_uint
                        && c <= '9' as i32 as libc::c_uint)
                    {
                        break;
                    }
                    m = ((m * 10 as libc::c_int) as libc::c_uint)
                        .wrapping_add(c)
                        .wrapping_sub('0' as i32 as libc::c_uint) as libc::c_int;
                    (*p).sIn.i += 1;
                }
                n = m;
                if c == ',' as i32 as libc::c_uint {
                    (*p).sIn.i += 1;
                    n = 0 as libc::c_int;
                    loop {
                        c = rePeek(p) as libc::c_uint;
                        if !(c >= '0' as i32 as libc::c_uint
                            && c <= '9' as i32 as libc::c_uint)
                        {
                            break;
                        }
                        n = ((n * 10 as libc::c_int) as libc::c_uint)
                            .wrapping_add(c)
                            .wrapping_sub('0' as i32 as libc::c_uint) as libc::c_int;
                        (*p).sIn.i += 1;
                    }
                }
                if c != '}' as i32 as libc::c_uint {
                    return b"unmatched '{'\0" as *const u8 as *const libc::c_char;
                }
                if n > 0 as libc::c_int && n < m {
                    return b"n less than m in '{m,n}'\0" as *const u8
                        as *const libc::c_char;
                }
                (*p).sIn.i += 1;
                sz = ((*p).nState).wrapping_sub(iPrev as libc::c_uint) as libc::c_int;
                if m == 0 as libc::c_int {
                    if n == 0 as libc::c_int {
                        return b"both m and n are zero in '{m,n}'\0" as *const u8
                            as *const libc::c_char;
                    }
                    re_insert(p, iPrev, 4 as libc::c_int, sz + 1 as libc::c_int);
                    n -= 1;
                } else {
                    j = 1 as libc::c_int;
                    while j < m {
                        re_copy(p, iPrev, sz);
                        j += 1;
                    }
                }
                j = m;
                while j < n {
                    re_append(p, 4 as libc::c_int, sz + 1 as libc::c_int);
                    re_copy(p, iPrev, sz);
                    j += 1;
                }
                if n == 0 as libc::c_int && m > 0 as libc::c_int {
                    re_append(p, 4 as libc::c_int, -sz);
                }
            }
            91 => {
                let mut iFirst: libc::c_int = (*p).nState as libc::c_int;
                if rePeek(p) as libc::c_int == '^' as i32 {
                    re_append(p, 8 as libc::c_int, 0 as libc::c_int);
                    (*p).sIn.i += 1;
                } else {
                    re_append(p, 7 as libc::c_int, 0 as libc::c_int);
                }
                loop {
                    c = ((*p).xNextChar)
                        .expect("non-null function pointer")(&mut (*p).sIn);
                    if !(c != 0 as libc::c_int as libc::c_uint) {
                        break;
                    }
                    if c == '[' as i32 as libc::c_uint
                        && rePeek(p) as libc::c_int == ':' as i32
                    {
                        return b"POSIX character classes not supported\0" as *const u8
                            as *const libc::c_char;
                    }
                    if c == '\\' as i32 as libc::c_uint {
                        c = re_esc_char(p);
                    }
                    if rePeek(p) as libc::c_int == '-' as i32 {
                        re_append(p, 10 as libc::c_int, c as libc::c_int);
                        (*p).sIn.i += 1;
                        c = ((*p).xNextChar)
                            .expect("non-null function pointer")(&mut (*p).sIn);
                        if c == '\\' as i32 as libc::c_uint {
                            c = re_esc_char(p);
                        }
                        re_append(p, 10 as libc::c_int, c as libc::c_int);
                    } else {
                        re_append(p, 9 as libc::c_int, c as libc::c_int);
                    }
                    if !(rePeek(p) as libc::c_int == ']' as i32) {
                        continue;
                    }
                    (*p).sIn.i += 1;
                    break;
                }
                if c == 0 as libc::c_int as libc::c_uint {
                    return b"unclosed '['\0" as *const u8 as *const libc::c_char;
                }
                *((*p).aArg)
                    .offset(
                        iFirst as isize,
                    ) = ((*p).nState).wrapping_sub(iFirst as libc::c_uint)
                    as libc::c_int;
            }
            92 => {
                let mut specialOp: libc::c_int = 0 as libc::c_int;
                match rePeek(p) as libc::c_int {
                    98 => {
                        specialOp = 17 as libc::c_int;
                    }
                    100 => {
                        specialOp = 13 as libc::c_int;
                    }
                    68 => {
                        specialOp = 14 as libc::c_int;
                    }
                    115 => {
                        specialOp = 15 as libc::c_int;
                    }
                    83 => {
                        specialOp = 16 as libc::c_int;
                    }
                    119 => {
                        specialOp = 11 as libc::c_int;
                    }
                    87 => {
                        specialOp = 12 as libc::c_int;
                    }
                    _ => {}
                }
                if specialOp != 0 {
                    (*p).sIn.i += 1;
                    re_append(p, specialOp, 0 as libc::c_int);
                } else {
                    c = re_esc_char(p);
                    re_append(p, 1 as libc::c_int, c as libc::c_int);
                }
            }
            _ => {
                re_append(p, 1 as libc::c_int, c as libc::c_int);
            }
        }
        iPrev = iStart;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn sqlite3re_free(mut pRe: *mut ReCompiled) {
    if !pRe.is_null() {
        sqlite3_free((*pRe).aOp as *mut libc::c_void);
        sqlite3_free((*pRe).aArg as *mut libc::c_void);
        sqlite3_free(pRe as *mut libc::c_void);
    }
}
unsafe extern "C" fn sqlite3re_compile(
    mut ppRe: *mut *mut ReCompiled,
    mut zIn: *const libc::c_char,
    mut noCase: libc::c_int,
) -> *const libc::c_char {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    *ppRe = 0 as *mut ReCompiled;
    pRe = sqlite3_malloc(
        ::core::mem::size_of::<ReCompiled>() as libc::c_ulong as libc::c_int,
    ) as *mut ReCompiled;
    if pRe.is_null() {
        return b"out of memory\0" as *const u8 as *const libc::c_char;
    }
    memset(
        pRe as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ReCompiled>() as libc::c_ulong,
    );
    (*pRe)
        .xNextChar = if noCase != 0 {
        Some(re_next_char_nocase as unsafe extern "C" fn(*mut ReInput) -> libc::c_uint)
    } else {
        Some(re_next_char as unsafe extern "C" fn(*mut ReInput) -> libc::c_uint)
    };
    if re_resize(pRe, 30 as libc::c_int) != 0 {
        sqlite3re_free(pRe);
        return b"out of memory\0" as *const u8 as *const libc::c_char;
    }
    if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '^' as i32 {
        zIn = zIn.offset(1);
    } else {
        re_append(pRe, 3 as libc::c_int, 0 as libc::c_int);
    }
    (*pRe).sIn.z = zIn as *mut libc::c_uchar;
    (*pRe).sIn.i = 0 as libc::c_int;
    (*pRe).sIn.mx = strlen(zIn) as libc::c_int;
    zErr = re_subcompile_re(pRe);
    if !zErr.is_null() {
        sqlite3re_free(pRe);
        return zErr;
    }
    if rePeek(pRe) as libc::c_int == '$' as i32
        && (*pRe).sIn.i + 1 as libc::c_int >= (*pRe).sIn.mx
    {
        re_append(pRe, 1 as libc::c_int, 0 as libc::c_int);
        re_append(pRe, 6 as libc::c_int, 0 as libc::c_int);
        *ppRe = pRe;
    } else if (*pRe).sIn.i >= (*pRe).sIn.mx {
        re_append(pRe, 6 as libc::c_int, 0 as libc::c_int);
        *ppRe = pRe;
    } else {
        sqlite3re_free(pRe);
        return b"unrecognized character\0" as *const u8 as *const libc::c_char;
    }
    if *((*pRe).aOp).offset(0 as libc::c_int as isize) as libc::c_int == 3 as libc::c_int
        && noCase == 0
    {
        j = 0 as libc::c_int;
        i = 1 as libc::c_int;
        while j
            < ::core::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong
                as libc::c_int - 2 as libc::c_int
            && *((*pRe).aOp).offset(i as isize) as libc::c_int == 1 as libc::c_int
        {
            let mut x: libc::c_uint = *((*pRe).aArg).offset(i as isize) as libc::c_uint;
            if x <= 127 as libc::c_int as libc::c_uint {
                let fresh17 = j;
                j = j + 1;
                (*pRe).zInit[fresh17 as usize] = x as libc::c_uchar;
            } else if x <= 0xfff as libc::c_int as libc::c_uint {
                let fresh18 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh18
                    as usize] = (0xc0 as libc::c_int as libc::c_uint
                    | x >> 6 as libc::c_int) as libc::c_uchar;
                let fresh19 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh19
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x & 0x3f as libc::c_int as libc::c_uint) as libc::c_uchar;
            } else {
                if !(x <= 0xffff as libc::c_int as libc::c_uint) {
                    break;
                }
                let fresh20 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh20
                    as usize] = (0xe0 as libc::c_int as libc::c_uint
                    | x >> 12 as libc::c_int) as libc::c_uchar;
                let fresh21 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh21
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                    as libc::c_uchar;
                let fresh22 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh22
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x & 0x3f as libc::c_int as libc::c_uint) as libc::c_uchar;
            }
            i += 1;
        }
        if j > 0 as libc::c_int
            && (*pRe).zInit[(j - 1 as libc::c_int) as usize] as libc::c_int
                == 0 as libc::c_int
        {
            j -= 1;
        }
        (*pRe).nInit = j;
    }
    return (*pRe).zErr;
}
unsafe extern "C" fn re_sql_func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zPattern: *const libc::c_char = 0 as *const libc::c_char;
    let mut zStr: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut setAux: libc::c_int = 0 as libc::c_int;
    pRe = sqlite3_get_auxdata(context, 0 as libc::c_int) as *mut ReCompiled;
    if pRe.is_null() {
        zPattern = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
            as *const libc::c_char;
        if zPattern.is_null() {
            return;
        }
        zErr = sqlite3re_compile(
            &mut pRe,
            zPattern,
            (sqlite3_user_data(context) != 0 as *mut libc::c_void) as libc::c_int,
        );
        if !zErr.is_null() {
            sqlite3re_free(pRe);
            sqlite3_result_error(context, zErr, -(1 as libc::c_int));
            return;
        }
        if pRe.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        }
        setAux = 1 as libc::c_int;
    }
    zStr = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize));
    if !zStr.is_null() {
        sqlite3_result_int(context, sqlite3re_match(pRe, zStr, -(1 as libc::c_int)));
    }
    if setAux != 0 {
        sqlite3_set_auxdata(
            context,
            0 as libc::c_int,
            pRe as *mut libc::c_void,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut ReCompiled) -> ()>,
                Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            >(Some(sqlite3re_free as unsafe extern "C" fn(*mut ReCompiled) -> ())),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_regexp_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"regexp\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            re_sql_func
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"regexpi\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            db as *mut libc::c_void,
            Some(
                re_sql_func
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn readFileContents(
    mut ctx: *mut sqlite3_context,
    mut zName: *const libc::c_char,
) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut nIn: sqlite3_int64 = 0;
    let mut pBuf: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut mxBlob: libc::c_int = 0;
    in_0 = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        return;
    }
    fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
    nIn = ftell(in_0) as sqlite3_int64;
    rewind(in_0);
    db = sqlite3_context_db_handle(ctx);
    mxBlob = sqlite3_limit(db, 0 as libc::c_int, -(1 as libc::c_int));
    if nIn > mxBlob as libc::c_longlong {
        sqlite3_result_error_code(ctx, 18 as libc::c_int);
        fclose(in_0);
        return;
    }
    pBuf = sqlite3_malloc64(
        (if nIn != 0 { nIn } else { 1 as libc::c_int as libc::c_longlong })
            as sqlite3_uint64,
    );
    if pBuf.is_null() {
        sqlite3_result_error_nomem(ctx);
        fclose(in_0);
        return;
    }
    if nIn
        == fread(pBuf, 1 as libc::c_int as libc::c_ulong, nIn as size_t, in_0)
            as sqlite3_int64
    {
        sqlite3_result_blob64(
            ctx,
            pBuf,
            nIn as sqlite3_uint64,
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
    } else {
        sqlite3_result_error_code(ctx, 10 as libc::c_int);
        sqlite3_free(pBuf);
    }
    fclose(in_0);
}
unsafe extern "C" fn readfileFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    zName = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zName.is_null() {
        return;
    }
    readFileContents(context, zName);
}
unsafe extern "C" fn ctxErrorMsg(
    mut ctx: *mut sqlite3_context,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
unsafe extern "C" fn fileStat(
    mut zPath: *const libc::c_char,
    mut pStatBuf: *mut stat,
) -> libc::c_int {
    return stat(zPath, pStatBuf);
}
unsafe extern "C" fn fileLinkStat(
    mut zPath: *const libc::c_char,
    mut pStatBuf: *mut stat,
) -> libc::c_int {
    return lstat(zPath, pStatBuf);
}
unsafe extern "C" fn makeDirectory(mut zFile: *const libc::c_char) -> libc::c_int {
    let mut zCopy: *mut libc::c_char = sqlite3_mprintf(
        b"%s\0" as *const u8 as *const libc::c_char,
        zFile,
    );
    let mut rc: libc::c_int = 0 as libc::c_int;
    if zCopy.is_null() {
        rc = 7 as libc::c_int;
    } else {
        let mut nCopy: libc::c_int = strlen(zCopy) as libc::c_int;
        let mut i: libc::c_int = 1 as libc::c_int;
        while rc == 0 as libc::c_int {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
                __glibc_reserved: [0; 3],
            };
            let mut rc2: libc::c_int = 0;
            while *zCopy.offset(i as isize) as libc::c_int != '/' as i32 && i < nCopy {
                i += 1;
            }
            if i == nCopy {
                break;
            }
            *zCopy.offset(i as isize) = '\0' as i32 as libc::c_char;
            rc2 = fileStat(zCopy, &mut sStat);
            if rc2 != 0 as libc::c_int {
                if mkdir(zCopy, 0o777 as libc::c_int as __mode_t) != 0 {
                    rc = 1 as libc::c_int;
                }
            } else if !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint)
            {
                rc = 1 as libc::c_int;
            }
            *zCopy.offset(i as isize) = '/' as i32 as libc::c_char;
            i += 1;
        }
        sqlite3_free(zCopy as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn writeFile(
    mut pCtx: *mut sqlite3_context,
    mut zFile: *const libc::c_char,
    mut pData: *mut sqlite3_value,
    mut mode: mode_t,
    mut mtime: sqlite3_int64,
) -> libc::c_int {
    if zFile.is_null() {
        return 1 as libc::c_int;
    }
    if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o120000 as libc::c_int as libc::c_uint
    {
        let mut zTo: *const libc::c_char = sqlite3_value_text(pData)
            as *const libc::c_char;
        if zTo.is_null() || symlink(zTo, zFile) < 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    } else if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        if mkdir(zFile, mode) != 0 {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
                __glibc_reserved: [0; 3],
            };
            if *__errno_location() != 17 as libc::c_int
                || 0 as libc::c_int != fileStat(zFile, &mut sStat)
                || !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint)
                || sStat.st_mode & 0o777 as libc::c_int as libc::c_uint
                    != mode & 0o777 as libc::c_int as libc::c_uint
                    && 0 as libc::c_int
                        != chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint)
            {
                return 1 as libc::c_int;
            }
        }
    } else {
        let mut nWrite: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut z: *const libc::c_char = 0 as *const libc::c_char;
        let mut rc: libc::c_int = 0 as libc::c_int;
        let mut out: *mut FILE = fopen(
            zFile,
            b"wb\0" as *const u8 as *const libc::c_char,
        );
        if out.is_null() {
            return 1 as libc::c_int;
        }
        z = sqlite3_value_blob(pData) as *const libc::c_char;
        if !z.is_null() {
            let mut n: sqlite3_int64 = fwrite(
                z as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                sqlite3_value_bytes(pData) as libc::c_ulong,
                out,
            ) as sqlite3_int64;
            nWrite = sqlite3_value_bytes(pData) as sqlite3_int64;
            if nWrite != n {
                rc = 1 as libc::c_int;
            }
        }
        fclose(out);
        if rc == 0 as libc::c_int && mode != 0
            && chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint) != 0
        {
            rc = 1 as libc::c_int;
        }
        if rc != 0 {
            return 2 as libc::c_int;
        }
        sqlite3_result_int64(pCtx, nWrite);
    }
    if mtime >= 0 as libc::c_int as libc::c_longlong {
        let mut times: [timeval; 2] = [timeval { tv_sec: 0, tv_usec: 0 }; 2];
        times[1 as libc::c_int as usize].tv_usec = 0 as libc::c_int as __suseconds_t;
        times[0 as libc::c_int as usize]
            .tv_usec = times[1 as libc::c_int as usize].tv_usec;
        times[0 as libc::c_int as usize].tv_sec = time(0 as *mut time_t);
        times[1 as libc::c_int as usize].tv_sec = mtime as __time_t;
        if utimes(zFile, times.as_mut_ptr() as *const timeval) != 0 {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn writefileFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut mode: mode_t = 0 as libc::c_int as mode_t;
    let mut res: libc::c_int = 0;
    let mut mtime: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    if argc < 2 as libc::c_int || argc > 4 as libc::c_int {
        sqlite3_result_error(
            context,
            b"wrong number of arguments to function writefile()\0" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zFile.is_null() {
        return;
    }
    if argc >= 3 as libc::c_int {
        mode = sqlite3_value_int(*argv.offset(2 as libc::c_int as isize)) as mode_t;
    }
    if argc == 4 as libc::c_int {
        mtime = sqlite3_value_int64(*argv.offset(3 as libc::c_int as isize));
    }
    res = writeFile(
        context,
        zFile,
        *argv.offset(1 as libc::c_int as isize),
        mode,
        mtime,
    );
    if res == 1 as libc::c_int && *__errno_location() == 2 as libc::c_int {
        if makeDirectory(zFile) == 0 as libc::c_int {
            res = writeFile(
                context,
                zFile,
                *argv.offset(1 as libc::c_int as isize),
                mode,
                mtime,
            );
        }
    }
    if argc > 2 as libc::c_int && res != 0 as libc::c_int {
        if mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o120000 as libc::c_int as libc::c_uint
        {
            ctxErrorMsg(
                context,
                b"failed to create symlink: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        } else if mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o40000 as libc::c_int as libc::c_uint
        {
            ctxErrorMsg(
                context,
                b"failed to create directory: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        } else {
            ctxErrorMsg(
                context,
                b"failed to write file: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
}
unsafe extern "C" fn lsModeFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut i: libc::c_int = 0;
    let mut iMode: libc::c_int = sqlite3_value_int(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut z: [libc::c_char; 16] = [0; 16];
    if iMode & 0o170000 as libc::c_int == 0o120000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'l' as i32 as libc::c_char;
    } else if iMode & 0o170000 as libc::c_int == 0o100000 as libc::c_int {
        z[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
    } else if iMode & 0o170000 as libc::c_int == 0o40000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'd' as i32 as libc::c_char;
    } else {
        z[0 as libc::c_int as usize] = '?' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        let mut m: libc::c_int = iMode >> (2 as libc::c_int - i) * 3 as libc::c_int;
        let mut a: *mut libc::c_char = &mut *z
            .as_mut_ptr()
            .offset((1 as libc::c_int + i * 3 as libc::c_int) as isize)
            as *mut libc::c_char;
        *a
            .offset(
                0 as libc::c_int as isize,
            ) = (if m & 0x4 as libc::c_int != 0 { 'r' as i32 } else { '-' as i32 })
            as libc::c_char;
        *a
            .offset(
                1 as libc::c_int as isize,
            ) = (if m & 0x2 as libc::c_int != 0 { 'w' as i32 } else { '-' as i32 })
            as libc::c_char;
        *a
            .offset(
                2 as libc::c_int as isize,
            ) = (if m & 0x1 as libc::c_int != 0 { 'x' as i32 } else { '-' as i32 })
            as libc::c_char;
        i += 1;
    }
    z[10 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    sqlite3_result_text(
        context,
        z.as_mut_ptr(),
        -(1 as libc::c_int),
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn fsdirConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut fsdir_tab = 0 as *mut fsdir_tab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\0" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::core::mem::size_of::<fsdir_tab>() as libc::c_ulong as libc::c_int,
        ) as *mut fsdir_tab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<fsdir_tab>() as libc::c_ulong,
        );
        sqlite3_vtab_config(db, 3 as libc::c_int);
    }
    *ppVtab = pNew as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn fsdirDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = 0 as *mut fsdir_cursor;
    pCur = sqlite3_malloc(
        ::core::mem::size_of::<fsdir_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut fsdir_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<fsdir_cursor>() as libc::c_ulong,
    );
    (*pCur).iLvl = -(1 as libc::c_int);
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirResetCursor(mut pCur: *mut fsdir_cursor) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i <= (*pCur).iLvl {
        let mut pLvl: *mut FsdirLevel = &mut *((*pCur).aLvl).offset(i as isize)
            as *mut FsdirLevel;
        if !((*pLvl).pDir).is_null() {
            closedir((*pLvl).pDir);
        }
        sqlite3_free((*pLvl).zDir as *mut libc::c_void);
        i += 1;
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    sqlite3_free((*pCur).aLvl as *mut libc::c_void);
    (*pCur).aLvl = 0 as *mut FsdirLevel;
    (*pCur).zPath = 0 as *mut libc::c_char;
    (*pCur).zBase = 0 as *const libc::c_char;
    (*pCur).nBase = 0 as libc::c_int;
    (*pCur).nLvl = 0 as libc::c_int;
    (*pCur).iLvl = -(1 as libc::c_int);
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
}
unsafe extern "C" fn fsdirClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    sqlite3_free(pCur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirSetErrmsg(
    mut pCur: *mut fsdir_cursor,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    (*(*pCur).base.pVtab).zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn fsdirNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    let mut m: mode_t = (*pCur).sStat.st_mode;
    (*pCur).iRowid += 1;
    if m & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        let mut iNew: libc::c_int = (*pCur).iLvl + 1 as libc::c_int;
        let mut pLvl: *mut FsdirLevel = 0 as *mut FsdirLevel;
        if iNew >= (*pCur).nLvl {
            let mut nNew: libc::c_int = iNew + 1 as libc::c_int;
            let mut nByte: sqlite3_int64 = (nNew as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                as sqlite3_int64;
            let mut aNew: *mut FsdirLevel = sqlite3_realloc64(
                (*pCur).aLvl as *mut libc::c_void,
                nByte as sqlite3_uint64,
            ) as *mut FsdirLevel;
            if aNew.is_null() {
                return 7 as libc::c_int;
            }
            memset(
                &mut *aNew.offset((*pCur).nLvl as isize) as *mut FsdirLevel
                    as *mut libc::c_void,
                0 as libc::c_int,
                (::core::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                    .wrapping_mul((nNew - (*pCur).nLvl) as libc::c_ulong),
            );
            (*pCur).aLvl = aNew;
            (*pCur).nLvl = nNew;
        }
        (*pCur).iLvl = iNew;
        pLvl = &mut *((*pCur).aLvl).offset(iNew as isize) as *mut FsdirLevel;
        (*pLvl).zDir = (*pCur).zPath;
        (*pCur).zPath = 0 as *mut libc::c_char;
        (*pLvl).pDir = opendir((*pLvl).zDir);
        if ((*pLvl).pDir).is_null() {
            fsdirSetErrmsg(
                pCur,
                b"cannot read directory: %s\0" as *const u8 as *const libc::c_char,
                (*pCur).zPath,
            );
            return 1 as libc::c_int;
        }
    }
    while (*pCur).iLvl >= 0 as libc::c_int {
        let mut pLvl_0: *mut FsdirLevel = &mut *((*pCur).aLvl)
            .offset((*pCur).iLvl as isize) as *mut FsdirLevel;
        let mut pEntry: *mut dirent = readdir((*pLvl_0).pDir);
        if !pEntry.is_null() {
            if (*pEntry).d_name[0 as libc::c_int as usize] as libc::c_int == '.' as i32 {
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int
                    == '.' as i32
                    && (*pEntry).d_name[2 as libc::c_int as usize] as libc::c_int
                        == '\0' as i32
                {
                    continue;
                }
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int
                    == '\0' as i32
                {
                    continue;
                }
            }
            sqlite3_free((*pCur).zPath as *mut libc::c_void);
            (*pCur)
                .zPath = sqlite3_mprintf(
                b"%s/%s\0" as *const u8 as *const libc::c_char,
                (*pLvl_0).zDir,
                ((*pEntry).d_name).as_mut_ptr(),
            );
            if ((*pCur).zPath).is_null() {
                return 7 as libc::c_int;
            }
            if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
                fsdirSetErrmsg(
                    pCur,
                    b"cannot stat file: %s\0" as *const u8 as *const libc::c_char,
                    (*pCur).zPath,
                );
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        } else {
            closedir((*pLvl_0).pDir);
            sqlite3_free((*pLvl_0).zDir as *mut libc::c_void);
            (*pLvl_0).pDir = 0 as *mut DIR;
            (*pLvl_0).zDir = 0 as *mut libc::c_char;
            (*pCur).iLvl -= 1;
        }
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    (*pCur).zPath = 0 as *mut libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                &mut *((*pCur).zPath).offset((*pCur).nBase as isize),
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        1 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mode as sqlite3_int64);
        }
        2 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mtim.tv_sec as sqlite3_int64);
        }
        3 => {
            let mut m: mode_t = (*pCur).sStat.st_mode;
            if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint
            {
                sqlite3_result_null(ctx);
            } else if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o120000 as libc::c_int as libc::c_uint
            {
                let mut aStatic: [libc::c_char; 64] = [0; 64];
                let mut aBuf: *mut libc::c_char = aStatic.as_mut_ptr();
                let mut nBuf: sqlite3_int64 = 64 as libc::c_int as sqlite3_int64;
                let mut n: libc::c_int = 0;
                loop {
                    n = readlink((*pCur).zPath, aBuf, nBuf as size_t) as libc::c_int;
                    if (n as libc::c_longlong) < nBuf {
                        break;
                    }
                    if aBuf != aStatic.as_mut_ptr() {
                        sqlite3_free(aBuf as *mut libc::c_void);
                    }
                    nBuf = nBuf * 2 as libc::c_int as libc::c_longlong;
                    aBuf = sqlite3_malloc64(nBuf as sqlite3_uint64) as *mut libc::c_char;
                    if aBuf.is_null() {
                        sqlite3_result_error_nomem(ctx);
                        return 7 as libc::c_int;
                    }
                }
                sqlite3_result_text(
                    ctx,
                    aBuf,
                    n,
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
                if aBuf != aStatic.as_mut_ptr() {
                    sqlite3_free(aBuf as *mut libc::c_void);
                }
            } else {
                readFileContents(ctx, (*pCur).zPath);
            }
        }
        4 | _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    return ((*pCur).zPath == 0 as *mut libc::c_char) as libc::c_int;
}
unsafe extern "C" fn fsdirFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut zDir: *const libc::c_char = 0 as *const libc::c_char;
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    if idxNum == 0 as libc::c_int {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires an argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc == idxNum && (argc == 1 as libc::c_int || argc == 2 as libc::c_int) {} else {
        __assert_fail(
            b"argc==idxNum && (argc==1 || argc==2)\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            5354 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 81],
                &[libc::c_char; 81],
            >(
                b"int fsdirFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
            ))
                .as_ptr(),
        );
    }
    zDir = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zDir.is_null() {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires a non-NULL argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        (*pCur)
            .zBase = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
            as *const libc::c_char;
    }
    if !((*pCur).zBase).is_null() {
        (*pCur).nBase = strlen((*pCur).zBase) as libc::c_int + 1 as libc::c_int;
        (*pCur)
            .zPath = sqlite3_mprintf(
            b"%s/%s\0" as *const u8 as *const libc::c_char,
            (*pCur).zBase,
            zDir,
        );
    } else {
        (*pCur)
            .zPath = sqlite3_mprintf(b"%s\0" as *const u8 as *const libc::c_char, zDir);
    }
    if ((*pCur).zPath).is_null() {
        return 7 as libc::c_int;
    }
    if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
        fsdirSetErrmsg(
            pCur,
            b"cannot stat file: %s\0" as *const u8 as *const libc::c_char,
            (*pCur).zPath,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idxPath: libc::c_int = -(1 as libc::c_int);
    let mut idxDir: libc::c_int = -(1 as libc::c_int);
    let mut seenPath: libc::c_int = 0 as libc::c_int;
    let mut seenDir: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
            match (*pConstraint).iColumn {
                4 => {
                    if (*pConstraint).usable != 0 {
                        idxPath = i;
                        seenPath = 0 as libc::c_int;
                    } else if idxPath < 0 as libc::c_int {
                        seenPath = 1 as libc::c_int;
                    }
                }
                5 => {
                    if (*pConstraint).usable != 0 {
                        idxDir = i;
                        seenDir = 0 as libc::c_int;
                    } else if idxDir < 0 as libc::c_int {
                        seenDir = 1 as libc::c_int;
                    }
                }
                _ => {}
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1);
    }
    if seenPath != 0 || seenDir != 0 {
        return 19 as libc::c_int;
    }
    if idxPath < 0 as libc::c_int {
        (*pIdxInfo).idxNum = 0 as libc::c_int;
        (*pIdxInfo).estimatedRows = 0x7fffffff as libc::c_int as sqlite3_int64;
    } else {
        (*((*pIdxInfo).aConstraintUsage).offset(idxPath as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*((*pIdxInfo).aConstraintUsage).offset(idxPath as isize))
            .argvIndex = 1 as libc::c_int;
        if idxDir >= 0 as libc::c_int {
            (*((*pIdxInfo).aConstraintUsage).offset(idxDir as isize))
                .omit = 1 as libc::c_int as libc::c_uchar;
            (*((*pIdxInfo).aConstraintUsage).offset(idxDir as isize))
                .argvIndex = 2 as libc::c_int;
            (*pIdxInfo).idxNum = 2 as libc::c_int;
            (*pIdxInfo).estimatedCost = 10.0f64;
        } else {
            (*pIdxInfo).idxNum = 1 as libc::c_int;
            (*pIdxInfo).estimatedCost = 100.0f64;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut fsdirModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    fsdirConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    fsdirBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    fsdirDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    fsdirOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    fsdirClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    fsdirFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    fsdirNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    fsdirEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    fsdirColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    fsdirRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"fsdir\0" as *const u8 as *const libc::c_char,
        &mut fsdirModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_fileio_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"readfile\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x80000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            readfileFunc
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"writefile\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                writefileFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"lsmode\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                lsModeFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = fsdirRegister(db);
    }
    return rc;
}
unsafe extern "C" fn completionConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut completion_vtab = 0 as *mut completion_vtab;
    let mut rc: libc::c_int = 0;
    sqlite3_vtab_config(db, 2 as libc::c_int);
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(  candidate TEXT,  prefix TEXT HIDDEN,  wholeline TEXT HIDDEN,  phase INT HIDDEN)\0"
            as *const u8 as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::core::mem::size_of::<completion_vtab>() as libc::c_ulong as libc::c_int,
        ) as *mut completion_vtab;
        *ppVtab = pNew as *mut sqlite3_vtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<completion_vtab>() as libc::c_ulong,
        );
        (*pNew).db = db;
    }
    return rc;
}
unsafe extern "C" fn completionDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = 0 as *mut completion_cursor;
    pCur = sqlite3_malloc(
        ::core::mem::size_of::<completion_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut completion_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<completion_cursor>() as libc::c_ulong,
    );
    (*pCur).db = (*(p as *mut completion_vtab)).db;
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionCursorReset(mut pCur: *mut completion_cursor) {
    sqlite3_free((*pCur).zPrefix as *mut libc::c_void);
    (*pCur).zPrefix = 0 as *mut libc::c_char;
    (*pCur).nPrefix = 0 as libc::c_int;
    sqlite3_free((*pCur).zLine as *mut libc::c_void);
    (*pCur).zLine = 0 as *mut libc::c_char;
    (*pCur).nLine = 0 as libc::c_int;
    sqlite3_finalize((*pCur).pStmt);
    (*pCur).pStmt = 0 as *mut sqlite3_stmt;
    (*pCur).j = 0 as libc::c_int;
}
unsafe extern "C" fn completionClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    completionCursorReset(cur as *mut completion_cursor);
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    let mut eNextPhase: libc::c_int = 0 as libc::c_int;
    let mut iCol: libc::c_int = -(1 as libc::c_int);
    (*pCur).iRowid += 1;
    while (*pCur).ePhase != 11 as libc::c_int {
        match (*pCur).ePhase {
            1 => {
                if (*pCur).j >= sqlite3_keyword_count() {
                    (*pCur).zCurrentRow = 0 as *const libc::c_char;
                    (*pCur).ePhase = 7 as libc::c_int;
                } else {
                    let fresh23 = (*pCur).j;
                    (*pCur).j = (*pCur).j + 1;
                    sqlite3_keyword_name(
                        fresh23,
                        &mut (*pCur).zCurrentRow,
                        &mut (*pCur).szRow,
                    );
                }
                iCol = -(1 as libc::c_int);
            }
            7 => {
                if ((*pCur).pStmt).is_null() {
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                }
                iCol = 1 as libc::c_int;
                eNextPhase = 8 as libc::c_int;
            }
            8 => {
                if ((*pCur).pStmt).is_null() {
                    let mut pS2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep: *const libc::c_char = b"\0" as *const u8
                        as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2) == 100 as libc::c_int {
                        let mut zDb: *const libc::c_char = sqlite3_column_text(
                            pS2,
                            1 as libc::c_int,
                        ) as *const libc::c_char;
                        zSql = sqlite3_mprintf(
                            b"%z%sSELECT name FROM \"%w\".sqlite_schema\0" as *const u8
                                as *const libc::c_char,
                            zSql,
                            zSep,
                            zDb,
                        );
                        if zSql.is_null() {
                            return 7 as libc::c_int;
                        }
                        zSep = b" UNION \0" as *const u8 as *const libc::c_char;
                    }
                    sqlite3_finalize(pS2);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 9 as libc::c_int;
            }
            9 => {
                if ((*pCur).pStmt).is_null() {
                    let mut pS2_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep_0: *const libc::c_char = b"\0" as *const u8
                        as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2_0,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2_0) == 100 as libc::c_int {
                        let mut zDb_0: *const libc::c_char = sqlite3_column_text(
                            pS2_0,
                            1 as libc::c_int,
                        ) as *const libc::c_char;
                        zSql_0 = sqlite3_mprintf(
                            b"%z%sSELECT pti.name FROM \"%w\".sqlite_schema AS sm JOIN pragma_table_info(sm.name,%Q) AS pti WHERE sm.type='table'\0"
                                as *const u8 as *const libc::c_char,
                            zSql_0,
                            zSep_0,
                            zDb_0,
                            zDb_0,
                        );
                        if zSql_0.is_null() {
                            return 7 as libc::c_int;
                        }
                        zSep_0 = b" UNION \0" as *const u8 as *const libc::c_char;
                    }
                    sqlite3_finalize(pS2_0);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql_0,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_0 as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 11 as libc::c_int;
            }
            _ => {}
        }
        if iCol < 0 as libc::c_int {
            if ((*pCur).zCurrentRow).is_null() {
                continue;
            }
        } else if sqlite3_step((*pCur).pStmt) == 100 as libc::c_int {
            (*pCur)
                .zCurrentRow = sqlite3_column_text((*pCur).pStmt, iCol)
                as *const libc::c_char;
            (*pCur).szRow = sqlite3_column_bytes((*pCur).pStmt, iCol);
        } else {
            sqlite3_finalize((*pCur).pStmt);
            (*pCur).pStmt = 0 as *mut sqlite3_stmt;
            (*pCur).ePhase = eNextPhase;
            continue;
        }
        if (*pCur).nPrefix == 0 as libc::c_int {
            break;
        }
        if (*pCur).nPrefix <= (*pCur).szRow
            && sqlite3_strnicmp((*pCur).zPrefix, (*pCur).zCurrentRow, (*pCur).nPrefix)
                == 0 as libc::c_int
        {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zCurrentRow,
                (*pCur).szRow,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        1 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zPrefix,
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        2 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zLine,
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        3 => {
            sqlite3_result_int(ctx, (*pCur).ePhase);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    return ((*pCur).ePhase >= 11 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn completionFilter(
    mut pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = pVtabCursor as *mut completion_cursor;
    let mut iArg: libc::c_int = 0 as libc::c_int;
    completionCursorReset(pCur);
    if idxNum & 1 as libc::c_int != 0 {
        (*pCur).nPrefix = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nPrefix > 0 as libc::c_int {
            (*pCur)
                .zPrefix = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if ((*pCur).zPrefix).is_null() {
                return 7 as libc::c_int;
            }
        }
        iArg = 1 as libc::c_int;
    }
    if idxNum & 2 as libc::c_int != 0 {
        (*pCur).nLine = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nLine > 0 as libc::c_int {
            (*pCur)
                .zLine = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if ((*pCur).zLine).is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    if !((*pCur).zLine).is_null() && ((*pCur).zPrefix).is_null() {
        let mut i: libc::c_int = (*pCur).nLine;
        while i > 0 as libc::c_int
            && (*(*__ctype_b_loc())
                .offset(
                    *((*pCur).zLine).offset((i - 1 as libc::c_int) as isize)
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int != 0
                || *((*pCur).zLine).offset((i - 1 as libc::c_int) as isize)
                    as libc::c_int == '_' as i32)
        {
            i -= 1;
        }
        (*pCur).nPrefix = (*pCur).nLine - i;
        if (*pCur).nPrefix > 0 as libc::c_int {
            (*pCur)
                .zPrefix = sqlite3_mprintf(
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (*pCur).nPrefix,
                ((*pCur).zLine).offset(i as isize),
            );
            if ((*pCur).zPrefix).is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    (*pCur).iRowid = 0 as libc::c_int as sqlite3_int64;
    (*pCur).ePhase = 1 as libc::c_int;
    return completionNext(pVtabCursor);
}
unsafe extern "C" fn completionBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idxNum: libc::c_int = 0 as libc::c_int;
    let mut prefixIdx: libc::c_int = -(1 as libc::c_int);
    let mut wholelineIdx: libc::c_int = -(1 as libc::c_int);
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).usable as libc::c_int == 0 as libc::c_int) {
            if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
                match (*pConstraint).iColumn {
                    1 => {
                        prefixIdx = i;
                        idxNum |= 1 as libc::c_int;
                    }
                    2 => {
                        wholelineIdx = i;
                        idxNum |= 2 as libc::c_int;
                    }
                    _ => {}
                }
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1);
    }
    if prefixIdx >= 0 as libc::c_int {
        nArg += 1;
        (*((*pIdxInfo).aConstraintUsage).offset(prefixIdx as isize)).argvIndex = nArg;
        (*((*pIdxInfo).aConstraintUsage).offset(prefixIdx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    if wholelineIdx >= 0 as libc::c_int {
        nArg += 1;
        (*((*pIdxInfo).aConstraintUsage).offset(wholelineIdx as isize)).argvIndex = nArg;
        (*((*pIdxInfo).aConstraintUsage).offset(wholelineIdx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    (*pIdxInfo).idxNum = idxNum;
    (*pIdxInfo)
        .estimatedCost = 5000 as libc::c_int as libc::c_double
        - (1000 as libc::c_int * nArg) as libc::c_double;
    (*pIdxInfo)
        .estimatedRows = (500 as libc::c_int - 100 as libc::c_int * nArg)
        as sqlite3_int64;
    return 0 as libc::c_int;
}
static mut completionModule: sqlite3_module = unsafe {
    {
        let mut init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                completionConnect
                    as unsafe extern "C" fn(
                        *mut sqlite3,
                        *mut libc::c_void,
                        libc::c_int,
                        *const *const libc::c_char,
                        *mut *mut sqlite3_vtab,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                completionBestIndex
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                completionDisconnect
                    as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                completionOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                completionClose
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                completionFilter
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        libc::c_int,
                        *const libc::c_char,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                completionNext
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                completionEof
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                completionColumn
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite3_context,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                completionRowid
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3CompletionVtabInit(mut db: *mut sqlite3) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_module(
        db,
        b"completion\0" as *const u8 as *const libc::c_char,
        &mut completionModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_completion_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3CompletionVtabInit(db);
    return rc;
}
static mut apnd_vfs: sqlite3_vfs = unsafe {
    {
        let mut init = sqlite3_vfs {
            iVersion: 3 as libc::c_int,
            szOsFile: 0 as libc::c_int,
            mxPathname: 1024 as libc::c_int,
            pNext: 0 as *const sqlite3_vfs as *mut sqlite3_vfs,
            zName: b"apndvfs\0" as *const u8 as *const libc::c_char,
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
            xOpen: Some(
                apndOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xDelete: Some(
                apndDelete
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xAccess: Some(
                apndAccess
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFullPathname: Some(
                apndFullPathname
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xDlOpen: Some(
                apndDlOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> *mut libc::c_void,
            ),
            xDlError: Some(
                apndDlError
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> (),
            ),
            xDlSym: Some(
                apndDlSym
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut libc::c_void,
                        *const libc::c_char,
                    ) -> Option::<unsafe extern "C" fn() -> ()>,
            ),
            xDlClose: Some(
                apndDlClose
                    as unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_void) -> (),
            ),
            xRandomness: Some(
                apndRandomness
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xSleep: Some(
                apndSleep
                    as unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int) -> libc::c_int,
            ),
            xCurrentTime: Some(
                apndCurrentTime
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut libc::c_double,
                    ) -> libc::c_int,
            ),
            xGetLastError: Some(
                apndGetLastError
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xCurrentTimeInt64: Some(
                apndCurrentTimeInt64
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSetSystemCall: Some(
                apndSetSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        sqlite3_syscall_ptr,
                    ) -> libc::c_int,
            ),
            xGetSystemCall: Some(
                apndGetSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> sqlite3_syscall_ptr,
            ),
            xNextSystemCall: Some(
                apndNextSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> *const libc::c_char,
            ),
        };
        init
    }
};
static mut apnd_io_methods: sqlite3_io_methods = unsafe {
    {
        let mut init = sqlite3_io_methods {
            iVersion: 3 as libc::c_int,
            xClose: Some(
                apndClose as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xRead: Some(
                apndRead
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xWrite: Some(
                apndWrite
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *const libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xTruncate: Some(
                apndTruncate
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSync: Some(
                apndSync
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileSize: Some(
                apndFileSize
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xLock: Some(
                apndLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xUnlock: Some(
                apndUnlock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xCheckReservedLock: Some(
                apndCheckReservedLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileControl: Some(
                apndFileControl
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xSectorSize: Some(
                apndSectorSize as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xDeviceCharacteristics: Some(
                apndDeviceCharacteristics
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xShmMap: Some(
                apndShmMap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xShmLock: Some(
                apndShmLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xShmBarrier: Some(
                apndShmBarrier as unsafe extern "C" fn(*mut sqlite3_file) -> (),
            ),
            xShmUnmap: Some(
                apndShmUnmap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFetch: Some(
                apndFetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xUnfetch: Some(
                apndUnfetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
unsafe extern "C" fn apndClose(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xClose).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndRead(
    mut pFile: *mut sqlite3_file,
    mut zBuf: *mut libc::c_void,
    mut iAmt: libc::c_int,
    mut iOfst: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xRead)
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
unsafe extern "C" fn apndWriteMark(
    mut paf: *mut ApndFile,
    mut pFile: *mut sqlite3_file,
    mut iWriteEnd: sqlite_int64,
) -> libc::c_int {
    let mut iPgOne: sqlite_int64 = (*paf).iPgOne;
    let mut a: [libc::c_uchar; 25] = [0; 25];
    let mut i: libc::c_int = 8 as libc::c_int;
    let mut rc: libc::c_int = 0;
    if pFile == paf.offset(1 as libc::c_int as isize) as *mut sqlite3_file {} else {
        __assert_fail(
            b"pFile == ORIGFILE(paf)\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            6298 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 60],
                &[libc::c_char; 60],
            >(b"int apndWriteMark(ApndFile *, sqlite3_file *, sqlite_int64)\0"))
                .as_ptr(),
        );
    }
    memcpy(
        a.as_mut_ptr() as *mut libc::c_void,
        b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
            as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    );
    loop {
        i -= 1;
        if !(i >= 0 as libc::c_int) {
            break;
        }
        a[(17 as libc::c_int + i)
            as usize] = (iPgOne & 0xff as libc::c_int as libc::c_longlong)
            as libc::c_uchar;
        iPgOne >>= 8 as libc::c_int;
    }
    iWriteEnd += (*paf).iPgOne;
    rc = ((*(*pFile).pMethods).xWrite)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        a.as_mut_ptr() as *const libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        iWriteEnd,
    );
    if 0 as libc::c_int == rc {
        (*paf).iMark = iWriteEnd;
    }
    return rc;
}
unsafe extern "C" fn apndWrite(
    mut pFile: *mut sqlite3_file,
    mut zBuf: *const libc::c_void,
    mut iAmt: libc::c_int,
    mut iOfst: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut iWriteEnd: sqlite_int64 = iOfst + iAmt as libc::c_longlong;
    if iWriteEnd >= 0x40000000 as libc::c_int as libc::c_longlong {
        return 13 as libc::c_int;
    }
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if (*paf).iMark < 0 as libc::c_int as libc::c_longlong
        || (*paf).iPgOne + iWriteEnd > (*paf).iMark
    {
        let mut rc: libc::c_int = apndWriteMark(paf, pFile, iWriteEnd);
        if 0 as libc::c_int != rc {
            return rc;
        }
    }
    return ((*(*pFile).pMethods).xWrite)
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
unsafe extern "C" fn apndTruncate(
    mut pFile: *mut sqlite3_file,
    mut size: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if 0 as libc::c_int != apndWriteMark(paf, pFile, size) {
        return 10 as libc::c_int;
    }
    return ((*(*pFile).pMethods).xTruncate)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        (*paf).iMark + (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
    );
}
unsafe extern "C" fn apndSync(
    mut pFile: *mut sqlite3_file,
    mut flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xSync)
        .expect("non-null function pointer")(pFile, flags);
}
unsafe extern "C" fn apndFileSize(
    mut pFile: *mut sqlite3_file,
    mut pSize: *mut sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    *pSize = if (*paf).iMark >= 0 as libc::c_int as libc::c_longlong {
        (*paf).iMark - (*paf).iPgOne
    } else {
        0 as libc::c_int as libc::c_longlong
    };
    return 0 as libc::c_int;
}
unsafe extern "C" fn apndLock(
    mut pFile: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xLock)
        .expect("non-null function pointer")(pFile, eLock);
}
unsafe extern "C" fn apndUnlock(
    mut pFile: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xUnlock)
        .expect("non-null function pointer")(pFile, eLock);
}
unsafe extern "C" fn apndCheckReservedLock(
    mut pFile: *mut sqlite3_file,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xCheckReservedLock)
        .expect("non-null function pointer")(pFile, pResOut);
}
unsafe extern "C" fn apndFileControl(
    mut pFile: *mut sqlite3_file,
    mut op: libc::c_int,
    mut pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut rc: libc::c_int = 0;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if op == 5 as libc::c_int {
        let ref mut fresh24 = *(pArg as *mut sqlite3_int64);
        *fresh24 += (*paf).iPgOne;
    }
    rc = ((*(*pFile).pMethods).xFileControl)
        .expect("non-null function pointer")(pFile, op, pArg);
    if rc == 0 as libc::c_int && op == 12 as libc::c_int {
        let ref mut fresh25 = *(pArg as *mut *mut libc::c_char);
        *fresh25 = sqlite3_mprintf(
            b"apnd(%lld)/%z\0" as *const u8 as *const libc::c_char,
            (*paf).iPgOne,
            *(pArg as *mut *mut libc::c_char),
        );
    }
    return rc;
}
unsafe extern "C" fn apndSectorSize(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xSectorSize).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndDeviceCharacteristics(
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xDeviceCharacteristics)
        .expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndShmMap(
    mut pFile: *mut sqlite3_file,
    mut iPg: libc::c_int,
    mut pgsz: libc::c_int,
    mut bExtend: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmMap)
        .expect("non-null function pointer")(pFile, iPg, pgsz, bExtend, pp);
}
unsafe extern "C" fn apndShmLock(
    mut pFile: *mut sqlite3_file,
    mut offset: libc::c_int,
    mut n: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmLock)
        .expect("non-null function pointer")(pFile, offset, n, flags);
}
unsafe extern "C" fn apndShmBarrier(mut pFile: *mut sqlite3_file) {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    ((*(*pFile).pMethods).xShmBarrier).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndShmUnmap(
    mut pFile: *mut sqlite3_file,
    mut deleteFlag: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmUnmap)
        .expect("non-null function pointer")(pFile, deleteFlag);
}
unsafe extern "C" fn apndFetch(
    mut pFile: *mut sqlite3_file,
    mut iOfst: sqlite3_int64,
    mut iAmt: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ApndFile = pFile as *mut ApndFile;
    if (*p).iMark < 0 as libc::c_int as libc::c_longlong
        || iOfst + iAmt as libc::c_longlong > (*p).iMark
    {
        return 10 as libc::c_int;
    }
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xFetch)
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, iAmt, pp);
}
unsafe extern "C" fn apndUnfetch(
    mut pFile: *mut sqlite3_file,
    mut iOfst: sqlite3_int64,
    mut pPage: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xUnfetch)
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, pPage);
}
unsafe extern "C" fn apndReadMark(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> sqlite3_int64 {
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iMark: sqlite3_int64 = 0;
    let mut msbs: libc::c_int = 8 as libc::c_int * (8 as libc::c_int - 1 as libc::c_int);
    let mut a: [libc::c_uchar; 25] = [0; 25];
    if (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
        != sz & 0x1ff as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    rc = ((*(*pFile).pMethods).xRead)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        a.as_mut_ptr() as *mut libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
    );
    if rc != 0 {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    if memcmp(
        a.as_mut_ptr() as *const libc::c_void,
        b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
            as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    iMark = ((a[17 as libc::c_int as usize] as libc::c_int & 0x7f as libc::c_int)
        as sqlite3_int64) << msbs;
    i = 1 as libc::c_int;
    while i < 8 as libc::c_int {
        msbs -= 8 as libc::c_int;
        iMark |= (a[(17 as libc::c_int + i) as usize] as sqlite3_int64) << msbs;
        i += 1;
    }
    if iMark
        > sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            - 512 as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    if iMark & 0x1ff as libc::c_int as libc::c_longlong != 0 {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    return iMark;
}
static mut apvfsSqliteHdr: [libc::c_char; 16] = unsafe {
    *::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SQLite format 3\0")
};
unsafe extern "C" fn apndIsAppendvfsDatabase(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    let mut iMark: sqlite3_int64 = apndReadMark(sz, pFile);
    if iMark >= 0 as libc::c_int as libc::c_longlong {
        rc = ((*(*pFile).pMethods).xRead)
            .expect(
                "non-null function pointer",
            )(
            pFile,
            zHdr.as_mut_ptr() as *mut libc::c_void,
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as libc::c_int,
            iMark,
        );
        if 0 as libc::c_int == rc
            && memcmp(
                zHdr.as_mut_ptr() as *const libc::c_void,
                apvfsSqliteHdr.as_ptr() as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            && sz & 0x1ff as libc::c_int as libc::c_longlong
                == (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            && sz
                >= (512 as libc::c_int + (17 as libc::c_int + 8 as libc::c_int))
                    as libc::c_longlong
        {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn apndIsOrdinaryDatabaseFile(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    if apndIsAppendvfsDatabase(sz, pFile) != 0
        || sz & 0x1ff as libc::c_int as libc::c_longlong
            != 0 as libc::c_int as libc::c_longlong
        || 0 as libc::c_int
            != ((*(*pFile).pMethods).xRead)
                .expect(
                    "non-null function pointer",
                )(
                pFile,
                zHdr.as_mut_ptr() as *mut libc::c_void,
                ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong
                    as libc::c_int,
                0 as libc::c_int as sqlite3_int64,
            )
        || memcmp(
            zHdr.as_mut_ptr() as *const libc::c_void,
            apvfsSqliteHdr.as_ptr() as *const libc::c_void,
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        ) != 0 as libc::c_int
    {
        return 0 as libc::c_int
    } else {
        return 1 as libc::c_int
    };
}
unsafe extern "C" fn apndOpen(
    mut pApndVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
    mut pFile: *mut sqlite3_file,
    mut flags: libc::c_int,
    mut pOutFlags: *mut libc::c_int,
) -> libc::c_int {
    let mut pApndFile: *mut ApndFile = pFile as *mut ApndFile;
    let mut pBaseFile: *mut sqlite3_file = (pFile as *mut ApndFile)
        .offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    let mut pBaseVfs: *mut sqlite3_vfs = (*pApndVfs).pAppData as *mut sqlite3_vfs;
    let mut rc: libc::c_int = 0;
    let mut sz: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    if flags & 0x100 as libc::c_int == 0 as libc::c_int {
        return ((*pBaseVfs).xOpen)
            .expect(
                "non-null function pointer",
            )(pBaseVfs, zName, pFile, flags, pOutFlags);
    }
    memset(
        pApndFile as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ApndFile>() as libc::c_ulong,
    );
    (*pFile).pMethods = &apnd_io_methods;
    (*pApndFile).iMark = -(1 as libc::c_int) as sqlite3_int64;
    rc = ((*pBaseVfs).xOpen)
        .expect(
            "non-null function pointer",
        )(pBaseVfs, zName, pBaseFile, flags, pOutFlags);
    if rc == 0 as libc::c_int {
        rc = ((*(*pBaseFile).pMethods).xFileSize)
            .expect("non-null function pointer")(pBaseFile, &mut sz);
        if rc != 0 {
            ((*(*pBaseFile).pMethods).xClose)
                .expect("non-null function pointer")(pBaseFile);
        }
    }
    if rc != 0 {
        (*pFile).pMethods = 0 as *const sqlite3_io_methods;
        return rc;
    }
    if apndIsOrdinaryDatabaseFile(sz, pBaseFile) != 0 {
        memmove(
            pApndFile as *mut libc::c_void,
            pBaseFile as *const libc::c_void,
            (*pBaseVfs).szOsFile as libc::c_ulong,
        );
        return 0 as libc::c_int;
    }
    (*pApndFile).iPgOne = apndReadMark(sz, pFile);
    if (*pApndFile).iPgOne >= 0 as libc::c_int as libc::c_longlong {
        (*pApndFile)
            .iMark = sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong;
        return 0 as libc::c_int;
    }
    if flags & 0x4 as libc::c_int == 0 as libc::c_int {
        ((*(*pBaseFile).pMethods).xClose).expect("non-null function pointer")(pBaseFile);
        rc = 14 as libc::c_int;
        (*pFile).pMethods = 0 as *const sqlite3_io_methods;
    } else {
        (*pApndFile)
            .iPgOne = sz + (4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64
            & !((4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64);
    }
    return rc;
}
unsafe extern "C" fn apndDelete(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut dirSync: libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDelete)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, dirSync);
}
unsafe extern "C" fn apndAccess(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut flags: libc::c_int,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xAccess)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, flags, pResOut);
}
unsafe extern "C" fn apndFullPathname(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut nOut: libc::c_int,
    mut zOut: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xFullPathname)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, nOut, zOut);
}
unsafe extern "C" fn apndDlOpen(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
) -> *mut libc::c_void {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlOpen)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath);
}
unsafe extern "C" fn apndDlError(
    mut pVfs: *mut sqlite3_vfs,
    mut nByte: libc::c_int,
    mut zErrMsg: *mut libc::c_char,
) {
    ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlError)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nByte, zErrMsg);
}
unsafe extern "C" fn apndDlSym(
    mut pVfs: *mut sqlite3_vfs,
    mut p: *mut libc::c_void,
    mut zSym: *const libc::c_char,
) -> Option::<unsafe extern "C" fn() -> ()> {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlSym)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, p, zSym);
}
unsafe extern "C" fn apndDlClose(
    mut pVfs: *mut sqlite3_vfs,
    mut pHandle: *mut libc::c_void,
) {
    ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlClose)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, pHandle);
}
unsafe extern "C" fn apndRandomness(
    mut pVfs: *mut sqlite3_vfs,
    mut nByte: libc::c_int,
    mut zBufOut: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xRandomness)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nByte, zBufOut);
}
unsafe extern "C" fn apndSleep(
    mut pVfs: *mut sqlite3_vfs,
    mut nMicro: libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xSleep)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nMicro);
}
unsafe extern "C" fn apndCurrentTime(
    mut pVfs: *mut sqlite3_vfs,
    mut pTimeOut: *mut libc::c_double,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xCurrentTime)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, pTimeOut);
}
unsafe extern "C" fn apndGetLastError(
    mut pVfs: *mut sqlite3_vfs,
    mut a: libc::c_int,
    mut b: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xGetLastError)
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, a, b);
}
unsafe extern "C" fn apndCurrentTimeInt64(
    mut pVfs: *mut sqlite3_vfs,
    mut p: *mut sqlite3_int64,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xCurrentTimeInt64)
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, p);
}
unsafe extern "C" fn apndSetSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
    mut pCall: sqlite3_syscall_ptr,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xSetSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName, pCall);
}
unsafe extern "C" fn apndGetSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
) -> sqlite3_syscall_ptr {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xGetSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName);
}
unsafe extern "C" fn apndNextSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
) -> *const libc::c_char {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xNextSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_appendvfs_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pOrig: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
    pOrig = sqlite3_vfs_find(0 as *const libc::c_char);
    if pOrig.is_null() {
        return 1 as libc::c_int;
    }
    apnd_vfs.iVersion = (*pOrig).iVersion;
    apnd_vfs.pAppData = pOrig as *mut libc::c_void;
    apnd_vfs
        .szOsFile = ((*pOrig).szOsFile as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<ApndFile>() as libc::c_ulong)
        as libc::c_int;
    rc = sqlite3_vfs_register(&mut apnd_vfs, 0 as libc::c_int);
    if rc == 0 as libc::c_int {
        rc = 0 as libc::c_int | (1 as libc::c_int) << 8 as libc::c_int;
    }
    return rc;
}
unsafe extern "C" fn idxMalloc(
    mut pRc: *mut libc::c_int,
    mut nByte: libc::c_int,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    if *pRc == 0 as libc::c_int {} else {
        __assert_fail(
            b"*pRc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9406 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 28],
                &[libc::c_char; 28],
            >(b"void *idxMalloc(int *, int)\0"))
                .as_ptr(),
        );
    }
    if nByte > 0 as libc::c_int {} else {
        __assert_fail(
            b"nByte>0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9407 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 28],
                &[libc::c_char; 28],
            >(b"void *idxMalloc(int *, int)\0"))
                .as_ptr(),
        );
    }
    pRet = sqlite3_malloc(nByte);
    if !pRet.is_null() {
        memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
    } else {
        *pRc = 7 as libc::c_int;
    }
    return pRet;
}
unsafe extern "C" fn idxHashInit(mut pHash: *mut IdxHash) {
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
unsafe extern "C" fn idxHashClear(mut pHash: *mut IdxHash) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1023 as libc::c_int {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pNext: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        pEntry = (*pHash).aHash[i as usize];
        while !pEntry.is_null() {
            pNext = (*pEntry).pHashNext;
            sqlite3_free((*pEntry).zVal2 as *mut libc::c_void);
            sqlite3_free(pEntry as *mut libc::c_void);
            pEntry = pNext;
        }
        i += 1;
    }
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
unsafe extern "C" fn idxHashString(
    mut z: *const libc::c_char,
    mut n: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < n {
        ret = ret
            .wrapping_add(
                (ret << 3 as libc::c_int)
                    .wrapping_add(*z.offset(i as isize) as libc::c_uchar as libc::c_uint),
            );
        i += 1;
    }
    return ret.wrapping_rem(1023 as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn idxHashAdd(
    mut pRc: *mut libc::c_int,
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut zVal: *const libc::c_char,
) -> libc::c_int {
    let mut nKey: libc::c_int = strlen(zKey) as libc::c_int;
    let mut iHash: libc::c_int = idxHashString(zKey, nKey);
    let mut nVal: libc::c_int = if !zVal.is_null() {
        strlen(zVal) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    if iHash >= 0 as libc::c_int {} else {
        __assert_fail(
            b"iHash>=0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9469 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 61],
                &[libc::c_char; 61],
            >(b"int idxHashAdd(int *, IdxHash *, const char *, const char *)\0"))
                .as_ptr(),
        );
    }
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return 1 as libc::c_int;
        }
        pEntry = (*pEntry).pHashNext;
    }
    pEntry = idxMalloc(
        pRc,
        (::core::mem::size_of::<IdxHashEntry>() as libc::c_ulong)
            .wrapping_add(nKey as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(nVal as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxHashEntry;
    if !pEntry.is_null() {
        (*pEntry)
            .zKey = &mut *pEntry.offset(1 as libc::c_int as isize) as *mut IdxHashEntry
            as *mut libc::c_char;
        memcpy(
            (*pEntry).zKey as *mut libc::c_void,
            zKey as *const libc::c_void,
            nKey as libc::c_ulong,
        );
        if !zVal.is_null() {
            (*pEntry)
                .zVal = &mut *((*pEntry).zKey).offset((nKey + 1 as libc::c_int) as isize)
                as *mut libc::c_char;
            memcpy(
                (*pEntry).zVal as *mut libc::c_void,
                zVal as *const libc::c_void,
                nVal as libc::c_ulong,
            );
        }
        (*pEntry).pHashNext = (*pHash).aHash[iHash as usize];
        (*pHash).aHash[iHash as usize] = pEntry;
        (*pEntry).pNext = (*pHash).pFirst;
        (*pHash).pFirst = pEntry;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxHashFind(
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *mut IdxHashEntry {
    let mut iHash: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    if nKey < 0 as libc::c_int {
        nKey = strlen(zKey) as libc::c_int;
    }
    iHash = idxHashString(zKey, nKey);
    if iHash >= 0 as libc::c_int {} else {
        __assert_fail(
            b"iHash>=0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9501 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"IdxHashEntry *idxHashFind(IdxHash *, const char *, int)\0"))
                .as_ptr(),
        );
    }
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return pEntry;
        }
        pEntry = (*pEntry).pHashNext;
    }
    return 0 as *mut IdxHashEntry;
}
unsafe extern "C" fn idxHashSearch(
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *const libc::c_char {
    let mut pEntry: *mut IdxHashEntry = idxHashFind(pHash, zKey, nKey);
    if !pEntry.is_null() {
        return (*pEntry).zVal;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn idxNewConstraint(
    mut pRc: *mut libc::c_int,
    mut zColl: *const libc::c_char,
) -> *mut IdxConstraint {
    let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nColl: libc::c_int = strlen(zColl) as libc::c_int;
    if *pRc == 0 as libc::c_int {} else {
        __assert_fail(
            b"*pRc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9530 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 53],
                &[libc::c_char; 53],
            >(b"IdxConstraint *idxNewConstraint(int *, const char *)\0"))
                .as_ptr(),
        );
    }
    pNew = idxMalloc(
        pRc,
        (::core::mem::size_of::<IdxConstraint>() as libc::c_ulong)
            .wrapping_mul(nColl as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxConstraint;
    if !pNew.is_null() {
        (*pNew)
            .zColl = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxConstraint
            as *mut libc::c_char;
        memcpy(
            (*pNew).zColl as *mut libc::c_void,
            zColl as *const libc::c_void,
            (nColl + 1 as libc::c_int) as libc::c_ulong,
        );
    }
    return pNew;
}
unsafe extern "C" fn idxDatabaseError(
    mut db: *mut sqlite3,
    mut pzErrmsg: *mut *mut libc::c_char,
) {
    *pzErrmsg = sqlite3_mprintf(
        b"%s\0" as *const u8 as *const libc::c_char,
        sqlite3_errmsg(db),
    );
}
unsafe extern "C" fn idxPrepareStmt(
    mut db: *mut sqlite3,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut pzErrmsg: *mut *mut libc::c_char,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        ppStmt,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int {
        *ppStmt = 0 as *mut sqlite3_stmt;
        idxDatabaseError(db, pzErrmsg);
    }
    return rc;
}
unsafe extern "C" fn idxPrintfPrepareStmt(
    mut db: *mut sqlite3,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut pzErrmsg: *mut *mut libc::c_char,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    zSql = sqlite3_vmprintf(zFmt, ap.as_va_list());
    if zSql.is_null() {
        rc = 7 as libc::c_int;
    } else {
        rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn expertDequote(mut zIn: *const libc::c_char) -> *mut libc::c_char {
    let mut n: libc::c_int = strlen(zIn) as libc::c_int;
    let mut zRet: *mut libc::c_char = sqlite3_malloc(n) as *mut libc::c_char;
    if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32 {} else {
        __assert_fail(
            b"zIn[0]=='\\''\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9613 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 34],
                &[libc::c_char; 34],
            >(b"char *expertDequote(const char *)\0"))
                .as_ptr(),
        );
    }
    if *zIn.offset((n - 1 as libc::c_int) as isize) as libc::c_int == '\'' as i32
    {} else {
        __assert_fail(
            b"zIn[n-1]=='\\''\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9614 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 34],
                &[libc::c_char; 34],
            >(b"char *expertDequote(const char *)\0"))
                .as_ptr(),
        );
    }
    if !zRet.is_null() {
        let mut iOut: libc::c_int = 0 as libc::c_int;
        let mut iIn: libc::c_int = 0 as libc::c_int;
        iIn = 1 as libc::c_int;
        while iIn < n - 1 as libc::c_int {
            if *zIn.offset(iIn as isize) as libc::c_int == '\'' as i32 {
                if *zIn.offset((iIn + 1 as libc::c_int) as isize) as libc::c_int
                    == '\'' as i32
                {} else {
                    __assert_fail(
                        b"zIn[iIn+1]=='\\''\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        9621 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 34],
                            &[libc::c_char; 34],
                        >(b"char *expertDequote(const char *)\0"))
                            .as_ptr(),
                    );
                }
                iIn += 1;
            }
            let fresh26 = iOut;
            iOut = iOut + 1;
            *zRet.offset(fresh26 as isize) = *zIn.offset(iIn as isize);
            iIn += 1;
        }
        *zRet.offset(iOut as isize) = '\0' as i32 as libc::c_char;
    }
    return zRet;
}
unsafe extern "C" fn expertConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pExpert: *mut sqlite3expert = pAux as *mut sqlite3expert;
    let mut p: *mut ExpertVtab = 0 as *mut ExpertVtab;
    let mut rc: libc::c_int = 0;
    if argc != 4 as libc::c_int {
        *pzErr = sqlite3_mprintf(
            b"internal error!\0" as *const u8 as *const libc::c_char,
        );
        rc = 1 as libc::c_int;
    } else {
        let mut zCreateTable: *mut libc::c_char = expertDequote(
            *argv.offset(3 as libc::c_int as isize),
        );
        if !zCreateTable.is_null() {
            rc = sqlite3_declare_vtab(db, zCreateTable);
            if rc == 0 as libc::c_int {
                p = idxMalloc(
                    &mut rc,
                    ::core::mem::size_of::<ExpertVtab>() as libc::c_ulong as libc::c_int,
                ) as *mut ExpertVtab;
            }
            if rc == 0 as libc::c_int {
                (*p).pExpert = pExpert;
                (*p).pTab = (*pExpert).pTable;
                if sqlite3_stricmp(
                    (*(*p).pTab).zName,
                    *argv.offset(2 as libc::c_int as isize),
                ) == 0 as libc::c_int
                {} else {
                    __assert_fail(
                        b"sqlite3_stricmp(p->pTab->zName, argv[2])==0\0" as *const u8
                            as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        9665 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 89],
                            &[libc::c_char; 89],
                        >(
                            b"int expertConnect(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)\0",
                        ))
                            .as_ptr(),
                    );
                }
            }
            sqlite3_free(zCreateTable as *mut libc::c_void);
        } else {
            rc = 7 as libc::c_int;
        }
    }
    *ppVtab = p as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn expertDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    sqlite3_free(p as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertBestIndex(
    mut pVtab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pScan: *mut IdxScan = 0 as *mut IdxScan;
    let opmask: libc::c_int = 2 as libc::c_int | 4 as libc::c_int | 16 as libc::c_int
        | 32 as libc::c_int | 8 as libc::c_int;
    pScan = idxMalloc(
        &mut rc,
        ::core::mem::size_of::<IdxScan>() as libc::c_ulong as libc::c_int,
    ) as *mut IdxScan;
    if !pScan.is_null() {
        let mut i: libc::c_int = 0;
        (*pScan).pTab = (*p).pTab;
        (*pScan).pNextScan = (*(*p).pExpert).pScan;
        (*(*p).pExpert).pScan = pScan;
        i = 0 as libc::c_int;
        while i < (*pIdxInfo).nConstraint {
            let mut pCons: *mut sqlite3_index_constraint = &mut *((*pIdxInfo)
                .aConstraint)
                .offset(i as isize) as *mut sqlite3_index_constraint;
            if (*pCons).usable as libc::c_int != 0
                && (*pCons).iColumn >= 0 as libc::c_int
                && (*((*(*p).pTab).aCol).offset((*pCons).iColumn as isize)).iPk
                    == 0 as libc::c_int && (*pCons).op as libc::c_int & opmask != 0
            {
                let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
                let mut zColl: *const libc::c_char = sqlite3_vtab_collation(pIdxInfo, i);
                pNew = idxNewConstraint(&mut rc, zColl);
                if !pNew.is_null() {
                    (*pNew).iCol = (*pCons).iColumn;
                    if (*pCons).op as libc::c_int == 2 as libc::c_int {
                        (*pNew).pNext = (*pScan).pEq;
                        (*pScan).pEq = pNew;
                    } else {
                        (*pNew).bRange = 1 as libc::c_int;
                        (*pNew).pNext = (*pScan).pRange;
                        (*pScan).pRange = pNew;
                    }
                }
                n += 1;
                (*((*pIdxInfo).aConstraintUsage).offset(i as isize)).argvIndex = n;
            }
            i += 1;
        }
        i = (*pIdxInfo).nOrderBy - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut iCol: libc::c_int = (*((*pIdxInfo).aOrderBy).offset(i as isize))
                .iColumn;
            if iCol >= 0 as libc::c_int {
                let mut pNew_0: *mut IdxConstraint = idxNewConstraint(
                    &mut rc,
                    (*((*(*p).pTab).aCol).offset(iCol as isize)).zColl,
                );
                if !pNew_0.is_null() {
                    (*pNew_0).iCol = iCol;
                    (*pNew_0)
                        .bDesc = (*((*pIdxInfo).aOrderBy).offset(i as isize)).desc
                        as libc::c_int;
                    (*pNew_0).pNext = (*pScan).pOrder;
                    (*pNew_0).pLink = (*pScan).pOrder;
                    (*pScan).pOrder = pNew_0;
                    n += 1;
                }
            }
            i -= 1;
        }
    }
    (*pIdxInfo).estimatedCost = 1000000.0f64 / (n + 1 as libc::c_int) as libc::c_double;
    return rc;
}
unsafe extern "C" fn expertUpdate(
    mut pVtab: *mut sqlite3_vtab,
    mut nData: libc::c_int,
    mut azData: *mut *mut sqlite3_value,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertOpen(
    mut pVTab: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pCsr: *mut ExpertCsr = 0 as *mut ExpertCsr;
    pCsr = idxMalloc(
        &mut rc,
        ::core::mem::size_of::<ExpertCsr>() as libc::c_ulong as libc::c_int,
    ) as *mut ExpertCsr;
    *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
    return rc;
}
unsafe extern "C" fn expertClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    sqlite3_finalize((*pCsr).pData);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    return ((*pCsr).pData == 0 as *mut sqlite3_stmt) as libc::c_int;
}
unsafe extern "C" fn expertNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !((*pCsr).pData).is_null() {} else {
        __assert_fail(
            b"pCsr->pData\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9803 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 38],
                &[libc::c_char; 38],
            >(b"int expertNext(sqlite3_vtab_cursor *)\0"))
                .as_ptr(),
        );
    }
    rc = sqlite3_step((*pCsr).pData);
    if rc != 100 as libc::c_int {
        rc = sqlite3_finalize((*pCsr).pData);
        (*pCsr).pData = 0 as *mut sqlite3_stmt;
    } else {
        rc = 0 as libc::c_int;
    }
    return rc;
}
unsafe extern "C" fn expertRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    *pRowid = 0 as libc::c_int as sqlite_int64;
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVal: *mut sqlite3_value = 0 as *mut sqlite3_value;
    pVal = sqlite3_column_value((*pCsr).pData, i);
    if !pVal.is_null() {
        sqlite3_result_value(ctx, pVal);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVtab: *mut ExpertVtab = (*cur).pVtab as *mut ExpertVtab;
    let mut pExpert: *mut sqlite3expert = (*pVtab).pExpert;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_finalize((*pCsr).pData);
    (*pCsr).pData = 0 as *mut sqlite3_stmt;
    if rc == 0 as libc::c_int {
        rc = idxPrintfPrepareStmt(
            (*pExpert).db,
            &mut (*pCsr).pData as *mut *mut sqlite3_stmt,
            &mut (*pVtab).base.zErrMsg as *mut *mut libc::c_char,
            b"SELECT * FROM main.%Q WHERE sample()\0" as *const u8
                as *const libc::c_char,
            (*(*pVtab).pTab).zName,
        );
    }
    if rc == 0 as libc::c_int {
        rc = expertNext(cur);
    }
    return rc;
}
unsafe extern "C" fn idxRegisterVtab(mut p: *mut sqlite3expert) -> libc::c_int {
    static mut expertModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 2 as libc::c_int,
                xCreate: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    expertBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    expertDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    expertDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    expertOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    expertClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    expertFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    expertNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    expertEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    expertColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    expertRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: Some(
                    expertUpdate
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    return sqlite3_create_module(
        (*p).dbv,
        b"expert\0" as *const u8 as *const libc::c_char,
        &mut expertModule,
        p as *mut libc::c_void,
    );
}
unsafe extern "C" fn idxFinalize(
    mut pRc: *mut libc::c_int,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = sqlite3_finalize(pStmt);
    if *pRc == 0 as libc::c_int {
        *pRc = rc;
    }
}
unsafe extern "C" fn idxGetTableInfo(
    mut db: *mut sqlite3,
    mut zTab: *const libc::c_char,
    mut ppOut: *mut *mut IdxTable,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut p1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nTab: libc::c_int = 0;
    let mut nByte: libc::c_int = 0;
    let mut pNew: *mut IdxTable = 0 as *mut IdxTable;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut pCsr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nPk: libc::c_int = 0 as libc::c_int;
    *ppOut = 0 as *mut IdxTable;
    if zTab.is_null() {
        return 1 as libc::c_int;
    }
    nTab = strlen(zTab) as libc::c_int;
    nByte = (::core::mem::size_of::<IdxTable>() as libc::c_ulong)
        .wrapping_add(nTab as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    rc = idxPrintfPrepareStmt(
        db,
        &mut p1 as *mut *mut sqlite3_stmt,
        pzErrmsg,
        b"PRAGMA table_xinfo=%Q\0" as *const u8 as *const libc::c_char,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let mut zCol: *const libc::c_char = sqlite3_column_text(p1, 1 as libc::c_int)
            as *const libc::c_char;
        let mut zColSeq: *const libc::c_char = 0 as *const libc::c_char;
        if zCol.is_null() {
            rc = 1 as libc::c_int;
            break;
        } else {
            nByte += 1 as libc::c_int + strlen(zCol) as libc::c_int;
            rc = sqlite3_table_column_metadata(
                db,
                b"main\0" as *const u8 as *const libc::c_char,
                zTab,
                zCol,
                0 as *mut *const libc::c_char,
                &mut zColSeq,
                0 as *mut libc::c_int,
                0 as *mut libc::c_int,
                0 as *mut libc::c_int,
            );
            if zColSeq.is_null() {
                zColSeq = b"binary\0" as *const u8 as *const libc::c_char;
            }
            nByte += 1 as libc::c_int + strlen(zColSeq) as libc::c_int;
            nCol += 1;
            nPk
                += (sqlite3_column_int(p1, 5 as libc::c_int) > 0 as libc::c_int)
                    as libc::c_int;
        }
    }
    rc2 = sqlite3_reset(p1);
    if rc == 0 as libc::c_int {
        rc = rc2;
    }
    nByte = (nByte as libc::c_ulong)
        .wrapping_add(
            (::core::mem::size_of::<IdxColumn>() as libc::c_ulong)
                .wrapping_mul(nCol as libc::c_ulong),
        ) as libc::c_int as libc::c_int;
    if rc == 0 as libc::c_int {
        pNew = idxMalloc(&mut rc, nByte) as *mut IdxTable;
    }
    if rc == 0 as libc::c_int {
        (*pNew)
            .aCol = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxTable
            as *mut IdxColumn;
        (*pNew).nCol = nCol;
        pCsr = &mut *((*pNew).aCol).offset(nCol as isize) as *mut IdxColumn
            as *mut libc::c_char;
    }
    nCol = 0 as libc::c_int;
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let mut zCol_0: *const libc::c_char = sqlite3_column_text(p1, 1 as libc::c_int)
            as *const libc::c_char;
        let mut zColSeq_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCopy: libc::c_int = 0;
        if zCol_0.is_null() {
            continue;
        }
        nCopy = strlen(zCol_0) as libc::c_int + 1 as libc::c_int;
        let ref mut fresh27 = (*((*pNew).aCol).offset(nCol as isize)).zName;
        *fresh27 = pCsr;
        (*((*pNew).aCol).offset(nCol as isize))
            .iPk = (sqlite3_column_int(p1, 5 as libc::c_int) == 1 as libc::c_int
            && nPk == 1 as libc::c_int) as libc::c_int;
        memcpy(
            pCsr as *mut libc::c_void,
            zCol_0 as *const libc::c_void,
            nCopy as libc::c_ulong,
        );
        pCsr = pCsr.offset(nCopy as isize);
        rc = sqlite3_table_column_metadata(
            db,
            b"main\0" as *const u8 as *const libc::c_char,
            zTab,
            zCol_0,
            0 as *mut *const libc::c_char,
            &mut zColSeq_0,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
        if rc == 0 as libc::c_int {
            if zColSeq_0.is_null() {
                zColSeq_0 = b"binary\0" as *const u8 as *const libc::c_char;
            }
            nCopy = strlen(zColSeq_0) as libc::c_int + 1 as libc::c_int;
            let ref mut fresh28 = (*((*pNew).aCol).offset(nCol as isize)).zColl;
            *fresh28 = pCsr;
            memcpy(
                pCsr as *mut libc::c_void,
                zColSeq_0 as *const libc::c_void,
                nCopy as libc::c_ulong,
            );
            pCsr = pCsr.offset(nCopy as isize);
        }
        nCol += 1;
    }
    idxFinalize(&mut rc, p1);
    if rc != 0 as libc::c_int {
        sqlite3_free(pNew as *mut libc::c_void);
        pNew = 0 as *mut IdxTable;
    } else if if !pNew.is_null() {
        1 as libc::c_int
    } else {
        __assert_fail(
            b"0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10000 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 67],
                &[libc::c_char; 67],
            >(b"int idxGetTableInfo(sqlite3 *, const char *, IdxTable **, char **)\0"))
                .as_ptr(),
        );
        0 as libc::c_int
    } != 0
    {
        (*pNew).zName = pCsr;
        if if !((*pNew).zName).is_null() {
            1 as libc::c_int
        } else {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10002 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 67],
                    &[libc::c_char; 67],
                >(
                    b"int idxGetTableInfo(sqlite3 *, const char *, IdxTable **, char **)\0",
                ))
                    .as_ptr(),
            );
            0 as libc::c_int
        } != 0
        {
            memcpy(
                (*pNew).zName as *mut libc::c_void,
                zTab as *const libc::c_void,
                (nTab + 1 as libc::c_int) as libc::c_ulong,
            );
        }
    }
    *ppOut = pNew;
    return rc;
}
unsafe extern "C" fn idxAppendText(
    mut pRc: *mut libc::c_int,
    mut zIn: *mut libc::c_char,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut ap: ::core::ffi::VaListImpl;
    let mut zAppend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nIn: libc::c_int = if !zIn.is_null() {
        strlen(zIn) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut nAppend: libc::c_int = 0 as libc::c_int;
    ap = args.clone();
    if *pRc == 0 as libc::c_int {
        zAppend = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if !zAppend.is_null() {
            nAppend = strlen(zAppend) as libc::c_int;
            zRet = sqlite3_malloc(nIn + nAppend + 1 as libc::c_int) as *mut libc::c_char;
        }
        if !zAppend.is_null() && !zRet.is_null() {
            if nIn != 0 {
                memcpy(
                    zRet as *mut libc::c_void,
                    zIn as *const libc::c_void,
                    nIn as libc::c_ulong,
                );
            }
            memcpy(
                &mut *zRet.offset(nIn as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                zAppend as *const libc::c_void,
                (nAppend + 1 as libc::c_int) as libc::c_ulong,
            );
        } else {
            sqlite3_free(zRet as *mut libc::c_void);
            zRet = 0 as *mut libc::c_char;
            *pRc = 7 as libc::c_int;
        }
        sqlite3_free(zAppend as *mut libc::c_void);
        sqlite3_free(zIn as *mut libc::c_void);
    }
    return zRet;
}
unsafe extern "C" fn idxIdentifierRequiresQuotes(
    mut zId: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while *zId.offset(i as isize) != 0 {
        if !(*zId.offset(i as isize) as libc::c_int == '_' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= '0' as i32
                && *zId.offset(i as isize) as libc::c_int <= '9' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'a' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'z' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'A' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'Z' as i32)
        {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxAppendColDefn(
    mut pRc: *mut libc::c_int,
    mut zIn: *mut libc::c_char,
    mut pTab: *mut IdxTable,
    mut pCons: *mut IdxConstraint,
) -> *mut libc::c_char {
    let mut zRet: *mut libc::c_char = zIn;
    let mut p: *mut IdxColumn = &mut *((*pTab).aCol).offset((*pCons).iCol as isize)
        as *mut IdxColumn;
    if !zRet.is_null() {
        zRet = idxAppendText(pRc, zRet, b", \0" as *const u8 as *const libc::c_char);
    }
    if idxIdentifierRequiresQuotes((*p).zName) != 0 {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%Q\0" as *const u8 as *const libc::c_char,
            (*p).zName,
        );
    } else {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%s\0" as *const u8 as *const libc::c_char,
            (*p).zName,
        );
    }
    if sqlite3_stricmp((*p).zColl, (*pCons).zColl) != 0 {
        if idxIdentifierRequiresQuotes((*pCons).zColl) != 0 {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %Q\0" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            );
        } else {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %s\0" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            );
        }
    }
    if (*pCons).bDesc != 0 {
        zRet = idxAppendText(pRc, zRet, b" DESC\0" as *const u8 as *const libc::c_char);
    }
    return zRet;
}
unsafe extern "C" fn idxFindCompatible(
    mut pRc: *mut libc::c_int,
    mut dbm: *mut sqlite3,
    mut pScan: *mut IdxScan,
    mut pEq: *mut IdxConstraint,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut zTbl: *const libc::c_char = (*(*pScan).pTab).zName;
    let mut pIdxList: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIter: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nEq: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0;
    pIter = pEq;
    while !pIter.is_null() {
        nEq += 1;
        pIter = (*pIter).pLink;
    }
    rc = idxPrintfPrepareStmt(
        dbm,
        &mut pIdxList as *mut *mut sqlite3_stmt,
        0 as *mut *mut libc::c_char,
        b"PRAGMA index_list=%Q\0" as *const u8 as *const libc::c_char,
        zTbl,
    );
    while rc == 0 as libc::c_int && sqlite3_step(pIdxList) == 100 as libc::c_int {
        let mut bMatch: libc::c_int = 1 as libc::c_int;
        let mut pT: *mut IdxConstraint = pTail;
        let mut pInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zIdx: *const libc::c_char = sqlite3_column_text(
            pIdxList,
            1 as libc::c_int,
        ) as *const libc::c_char;
        if zIdx.is_null() {
            continue;
        }
        pIter = pEq;
        while !pIter.is_null() {
            (*pIter).bFlag = 0 as libc::c_int;
            pIter = (*pIter).pLink;
        }
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pInfo as *mut *mut sqlite3_stmt,
            0 as *mut *mut libc::c_char,
            b"PRAGMA index_xInfo=%Q\0" as *const u8 as *const libc::c_char,
            zIdx,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pInfo) == 100 as libc::c_int {
            let mut iIdx: libc::c_int = sqlite3_column_int(pInfo, 0 as libc::c_int);
            let mut iCol: libc::c_int = sqlite3_column_int(pInfo, 1 as libc::c_int);
            let mut zColl: *const libc::c_char = sqlite3_column_text(
                pInfo,
                4 as libc::c_int,
            ) as *const libc::c_char;
            if iIdx < nEq {
                pIter = pEq;
                while !pIter.is_null() {
                    if !((*pIter).bFlag != 0) {
                        if !((*pIter).iCol != iCol) {
                            if !(sqlite3_stricmp((*pIter).zColl, zColl) != 0) {
                                (*pIter).bFlag = 1 as libc::c_int;
                                break;
                            }
                        }
                    }
                    pIter = (*pIter).pLink;
                }
                if !pIter.is_null() {
                    continue;
                }
                bMatch = 0 as libc::c_int;
                break;
            } else {
                if pT.is_null() {
                    continue;
                }
                if (*pT).iCol != iCol || sqlite3_stricmp((*pT).zColl, zColl) != 0 {
                    bMatch = 0 as libc::c_int;
                    break;
                } else {
                    pT = (*pT).pLink;
                }
            }
        }
        idxFinalize(&mut rc, pInfo);
        if rc == 0 as libc::c_int && bMatch != 0 {
            sqlite3_finalize(pIdxList);
            return 1 as libc::c_int;
        }
    }
    idxFinalize(&mut rc, pIdxList);
    *pRc = rc;
    return 0 as libc::c_int;
}
unsafe extern "C" fn countNonzeros(
    mut pCount: *mut libc::c_void,
    mut nc: libc::c_int,
    mut azResults: *mut *mut libc::c_char,
    mut azColumns: *mut *mut libc::c_char,
) -> libc::c_int {
    if nc > 0 as libc::c_int
        && (*(*azResults.offset(0 as libc::c_int as isize))
            .offset(0 as libc::c_int as isize) as libc::c_int != '0' as i32
            || *(*azResults.offset(0 as libc::c_int as isize))
                .offset(1 as libc::c_int as isize) as libc::c_int != 0 as libc::c_int)
    {
        *(pCount as *mut libc::c_int) += 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromCons(
    mut p: *mut sqlite3expert,
    mut pScan: *mut IdxScan,
    mut pEq: *mut IdxConstraint,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (!pEq.is_null() || !pTail.is_null())
        && 0 as libc::c_int == idxFindCompatible(&mut rc, dbm, pScan, pEq, pTail)
    {
        let mut pTab: *mut IdxTable = (*pScan).pTab;
        let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zIdx: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pCons: *mut IdxConstraint = 0 as *mut IdxConstraint;
        let mut h: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut zFmt: *const libc::c_char = 0 as *const libc::c_char;
        pCons = pEq;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink;
        }
        pCons = pTail;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink;
        }
        if rc == 0 as libc::c_int {
            let mut zTable: *const libc::c_char = (*(*pScan).pTab).zName;
            let mut quoteTable: libc::c_int = idxIdentifierRequiresQuotes(zTable);
            let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut collisions: libc::c_int = 0 as libc::c_int;
            loop {
                let mut i: libc::c_int = 0;
                let mut zFind: *mut libc::c_char = 0 as *mut libc::c_char;
                i = 0 as libc::c_int;
                while *zCols.offset(i as isize) != 0 {
                    h = h
                        .wrapping_add(
                            (h << 3 as libc::c_int)
                                .wrapping_add(*zCols.offset(i as isize) as libc::c_uint),
                        );
                    i += 1;
                }
                sqlite3_free(zName as *mut libc::c_void);
                zName = sqlite3_mprintf(
                    b"%s_idx_%08x\0" as *const u8 as *const libc::c_char,
                    zTable,
                    h,
                );
                if zName.is_null() {
                    break;
                }
                zFmt = b"SELECT count(*) FROM sqlite_schema WHERE name=%Q AND type in ('index','table','view')\0"
                    as *const u8 as *const libc::c_char;
                zFind = sqlite3_mprintf(zFmt, zName);
                i = 0 as libc::c_int;
                rc = sqlite3_exec(
                    dbm,
                    zFind,
                    Some(
                        countNonzeros
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *mut *mut libc::c_char,
                                *mut *mut libc::c_char,
                            ) -> libc::c_int,
                    ),
                    &mut i as *mut libc::c_int as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                if rc == 0 as libc::c_int {} else {
                    __assert_fail(
                        b"rc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        10231 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 84],
                            &[libc::c_char; 84],
                        >(
                            b"int idxCreateFromCons(sqlite3expert *, IdxScan *, IdxConstraint *, IdxConstraint *)\0",
                        ))
                            .as_ptr(),
                    );
                }
                sqlite3_free(zFind as *mut libc::c_void);
                if i == 0 as libc::c_int {
                    collisions = 0 as libc::c_int;
                    break;
                } else {
                    collisions += 1;
                    if !(collisions < 50 as libc::c_int && !zName.is_null()) {
                        break;
                    }
                }
            }
            if collisions != 0 {
                rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int;
            } else if zName.is_null() {
                rc = 7 as libc::c_int;
            } else {
                if quoteTable != 0 {
                    zFmt = b"CREATE INDEX \"%w\" ON \"%w\"(%s)\0" as *const u8
                        as *const libc::c_char;
                } else {
                    zFmt = b"CREATE INDEX %s ON %s(%s)\0" as *const u8
                        as *const libc::c_char;
                }
                zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
                if zIdx.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    rc = sqlite3_exec(
                        dbm,
                        zIdx,
                        None,
                        0 as *mut libc::c_void,
                        (*p).pzErrmsg,
                    );
                    if rc != 0 as libc::c_int {
                        rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int;
                    } else {
                        idxHashAdd(&mut rc, &mut (*p).hIdx, zName, zIdx);
                    }
                }
                sqlite3_free(zName as *mut libc::c_void);
                sqlite3_free(zIdx as *mut libc::c_void);
            }
        }
        sqlite3_free(zCols as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn idxFindConstraint(
    mut pList: *mut IdxConstraint,
    mut p: *mut IdxConstraint,
) -> libc::c_int {
    let mut pCmp: *mut IdxConstraint = 0 as *mut IdxConstraint;
    pCmp = pList;
    while !pCmp.is_null() {
        if (*p).iCol == (*pCmp).iCol {
            return 1 as libc::c_int;
        }
        pCmp = (*pCmp).pLink;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromWhere(
    mut p: *mut sqlite3expert,
    mut pScan: *mut IdxScan,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut p1: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut pCon: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut rc: libc::c_int = 0;
    pCon = (*pScan).pEq;
    while !pCon.is_null() {
        if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
            (*pCon).pLink = p1;
            p1 = pCon;
        }
        pCon = (*pCon).pNext;
    }
    rc = idxCreateFromCons(p, pScan, p1, pTail);
    if pTail.is_null() {
        pCon = (*pScan).pRange;
        while rc == 0 as libc::c_int && !pCon.is_null() {
            if ((*pCon).pLink).is_null() {} else {
                __assert_fail(
                    b"pCon->pLink==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    10308 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 68],
                        &[libc::c_char; 68],
                    >(
                        b"int idxCreateFromWhere(sqlite3expert *, IdxScan *, IdxConstraint *)\0",
                    ))
                        .as_ptr(),
                );
            }
            if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
                rc = idxCreateFromCons(p, pScan, p1, pCon);
            }
            pCon = (*pCon).pNext;
        }
    }
    return rc;
}
unsafe extern "C" fn idxCreateCandidates(mut p: *mut sqlite3expert) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pIter: *mut IdxScan = 0 as *mut IdxScan;
    pIter = (*p).pScan;
    while !pIter.is_null() && rc == 0 as libc::c_int {
        rc = idxCreateFromWhere(p, pIter, 0 as *mut IdxConstraint);
        if rc == 0 as libc::c_int && !((*pIter).pOrder).is_null() {
            rc = idxCreateFromWhere(p, pIter, (*pIter).pOrder);
        }
        pIter = (*pIter).pNextScan;
    }
    return rc;
}
unsafe extern "C" fn idxConstraintFree(mut pConstraint: *mut IdxConstraint) {
    let mut pNext: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut p: *mut IdxConstraint = 0 as *mut IdxConstraint;
    p = pConstraint;
    while !p.is_null() {
        pNext = (*p).pNext;
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxScanFree(mut pScan: *mut IdxScan, mut pLast: *mut IdxScan) {
    let mut p: *mut IdxScan = 0 as *mut IdxScan;
    let mut pNext: *mut IdxScan = 0 as *mut IdxScan;
    p = pScan;
    while p != pLast {
        pNext = (*p).pNextScan;
        idxConstraintFree((*p).pOrder);
        idxConstraintFree((*p).pEq);
        idxConstraintFree((*p).pRange);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxStatementFree(
    mut pStatement: *mut IdxStatement,
    mut pLast: *mut IdxStatement,
) {
    let mut p: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut pNext: *mut IdxStatement = 0 as *mut IdxStatement;
    p = pStatement;
    while p != pLast {
        pNext = (*p).pNext;
        sqlite3_free((*p).zEQP as *mut libc::c_void);
        sqlite3_free((*p).zIdx as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxTableFree(mut pTab: *mut IdxTable) {
    let mut pIter: *mut IdxTable = 0 as *mut IdxTable;
    let mut pNext: *mut IdxTable = 0 as *mut IdxTable;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext;
    }
}
unsafe extern "C" fn idxWriteFree(mut pTab: *mut IdxWrite) {
    let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pNext: *mut IdxWrite = 0 as *mut IdxWrite;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext;
    }
}
unsafe extern "C" fn idxFindIndexes(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut hIdx: IdxHash = IdxHash {
        pFirst: 0 as *mut IdxHashEntry,
        aHash: [0 as *mut IdxHashEntry; 1023],
    };
    idxHashInit(&mut hIdx);
    pStmt = (*p).pStatement;
    's_13: while rc == 0 as libc::c_int && !pStmt.is_null() {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        idxHashClear(&mut hIdx);
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pExplain as *mut *mut sqlite3_stmt,
            pzErr,
            b"EXPLAIN QUERY PLAN %s\0" as *const u8 as *const libc::c_char,
            (*pStmt).zSql,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pExplain) == 100 as libc::c_int {
            let mut zDetail: *const libc::c_char = sqlite3_column_text(
                pExplain,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut nDetail: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            if zDetail.is_null() {
                continue;
            }
            nDetail = strlen(zDetail) as libc::c_int;
            i = 0 as libc::c_int;
            while i < nDetail {
                let mut zIdx: *const libc::c_char = 0 as *const libc::c_char;
                if (i + 13 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char
                            as *const libc::c_void,
                        b" USING INDEX \0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        13 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 13 as libc::c_int) as isize)
                        as *const libc::c_char;
                } else if (i + 22 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char
                            as *const libc::c_void,
                        b" USING COVERING INDEX \0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        22 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 22 as libc::c_int) as isize)
                        as *const libc::c_char;
                }
                if !zIdx.is_null() {
                    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
                    let mut nIdx: libc::c_int = 0 as libc::c_int;
                    while *zIdx.offset(nIdx as isize) as libc::c_int != '\0' as i32
                        && (*zIdx.offset(nIdx as isize) as libc::c_int != ' ' as i32
                            || *zIdx.offset((nIdx + 1 as libc::c_int) as isize)
                                as libc::c_int != '(' as i32)
                    {
                        nIdx += 1;
                    }
                    zSql = idxHashSearch(&mut (*p).hIdx, zIdx, nIdx);
                    if zSql.is_null() {
                        break;
                    }
                    idxHashAdd(&mut rc, &mut hIdx, zSql, 0 as *const libc::c_char);
                    if rc != 0 {
                        break 's_13;
                    } else {
                        break;
                    }
                } else {
                    i += 1;
                }
            }
            if *zDetail.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                (*pStmt)
                    .zEQP = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    (*pStmt).zEQP,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    zDetail,
                );
            }
        }
        pEntry = hIdx.pFirst;
        while !pEntry.is_null() {
            (*pStmt)
                .zIdx = idxAppendText(
                &mut rc as *mut libc::c_int,
                (*pStmt).zIdx,
                b"%s;\n\0" as *const u8 as *const libc::c_char,
                (*pEntry).zKey,
            );
            pEntry = (*pEntry).pNext;
        }
        idxFinalize(&mut rc, pExplain);
        pStmt = (*pStmt).pNext;
    }
    idxHashClear(&mut hIdx);
    return rc;
}
unsafe extern "C" fn idxAuthCallback(
    mut pCtx: *mut libc::c_void,
    mut eOp: libc::c_int,
    mut z3: *const libc::c_char,
    mut z4: *const libc::c_char,
    mut zDb: *const libc::c_char,
    mut zTrigger: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if eOp == 18 as libc::c_int || eOp == 23 as libc::c_int || eOp == 9 as libc::c_int {
        if sqlite3_stricmp(zDb, b"main\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut p: *mut sqlite3expert = pCtx as *mut sqlite3expert;
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            pTab = (*p).pTable;
            while !pTab.is_null() {
                if 0 as libc::c_int == sqlite3_stricmp(z3, (*pTab).zName) {
                    break;
                }
                pTab = (*pTab).pNext;
            }
            if !pTab.is_null() {
                let mut pWrite: *mut IdxWrite = 0 as *mut IdxWrite;
                pWrite = (*p).pWrite;
                while !pWrite.is_null() {
                    if (*pWrite).pTab == pTab && (*pWrite).eOp == eOp {
                        break;
                    }
                    pWrite = (*pWrite).pNext;
                }
                if pWrite.is_null() {
                    pWrite = idxMalloc(
                        &mut rc,
                        ::core::mem::size_of::<IdxWrite>() as libc::c_ulong
                            as libc::c_int,
                    ) as *mut IdxWrite;
                    if rc == 0 as libc::c_int {
                        (*pWrite).pTab = pTab;
                        (*pWrite).eOp = eOp;
                        (*pWrite).pNext = (*p).pWrite;
                        (*p).pWrite = pWrite;
                    }
                }
            }
        }
    }
    return rc;
}
unsafe extern "C" fn idxProcessOneTrigger(
    mut p: *mut sqlite3expert,
    mut pWrite: *mut IdxWrite,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut zInt: *const libc::c_char = b"t592690916721053953805701627921227776\0"
        as *const u8 as *const libc::c_char;
    static mut zDrop: *const libc::c_char = b"DROP TABLE t592690916721053953805701627921227776\0"
        as *const u8 as *const libc::c_char;
    let mut pTab: *mut IdxTable = (*pWrite).pTab;
    let mut zTab: *const libc::c_char = (*pTab).zName;
    let mut zSql: *const libc::c_char = b"SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\0"
        as *const u8 as *const libc::c_char;
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zWrite: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = idxPrintfPrepareStmt(
        (*p).db,
        &mut pSelect as *mut *mut sqlite3_stmt,
        pzErr,
        zSql,
        zTab,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSelect) {
        let mut zCreate: *const libc::c_char = sqlite3_column_text(
            pSelect,
            0 as libc::c_int,
        ) as *const libc::c_char;
        if zCreate.is_null() {
            continue;
        }
        rc = sqlite3_exec((*p).dbv, zCreate, None, 0 as *mut libc::c_void, pzErr);
    }
    idxFinalize(&mut rc, pSelect);
    if rc == 0 as libc::c_int {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b"ALTER TABLE temp.%Q RENAME TO %Q\0" as *const u8 as *const libc::c_char,
            zTab,
            zInt,
        );
        if z.is_null() {
            rc = 7 as libc::c_int;
        } else {
            rc = sqlite3_exec((*p).dbv, z, None, 0 as *mut libc::c_void, pzErr);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
    match (*pWrite).eOp {
        18 => {
            let mut i: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"INSERT INTO %Q VALUES(\0" as *const u8 as *const libc::c_char,
                zInt,
            );
            i = 0 as libc::c_int;
            while i < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s?\0" as *const u8 as *const libc::c_char,
                    if i == 0 as libc::c_int {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b", \0" as *const u8 as *const libc::c_char
                    },
                );
                i += 1;
            }
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b")\0" as *const u8 as *const libc::c_char,
            );
        }
        23 => {
            let mut i_0: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"UPDATE %Q SET \0" as *const u8 as *const libc::c_char,
                zInt,
            );
            i_0 = 0 as libc::c_int;
            while i_0 < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s%Q=?\0" as *const u8 as *const libc::c_char,
                    if i_0 == 0 as libc::c_int {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b", \0" as *const u8 as *const libc::c_char
                    },
                    (*((*pTab).aCol).offset(i_0 as isize)).zName,
                );
                i_0 += 1;
            }
        }
        _ => {
            if (*pWrite).eOp == 9 as libc::c_int {} else {
                __assert_fail(
                    b"pWrite->eOp==SQLITE_DELETE\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    10577 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 63],
                        &[libc::c_char; 63],
                    >(
                        b"int idxProcessOneTrigger(sqlite3expert *, IdxWrite *, char **)\0",
                    ))
                        .as_ptr(),
                );
            }
            if rc == 0 as libc::c_int {
                zWrite = sqlite3_mprintf(
                    b"DELETE FROM %Q\0" as *const u8 as *const libc::c_char,
                    zInt,
                );
                if zWrite.is_null() {
                    rc = 7 as libc::c_int;
                }
            }
        }
    }
    if rc == 0 as libc::c_int {
        let mut pX: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zWrite,
            -(1 as libc::c_int),
            &mut pX,
            0 as *mut *const libc::c_char,
        );
        idxFinalize(&mut rc, pX);
        if rc != 0 as libc::c_int {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    sqlite3_free(zWrite as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec((*p).dbv, zDrop, None, 0 as *mut libc::c_void, pzErr);
    }
    return rc;
}
unsafe extern "C" fn idxProcessTriggers(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pEnd: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pFirst: *mut IdxWrite = (*p).pWrite;
    while rc == 0 as libc::c_int && pFirst != pEnd {
        let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
        pIter = pFirst;
        while rc == 0 as libc::c_int && pIter != pEnd {
            rc = idxProcessOneTrigger(p, pIter, pzErr);
            pIter = (*pIter).pNext;
        }
        pEnd = pFirst;
        pFirst = (*p).pWrite;
    }
    return rc;
}
unsafe extern "C" fn idxCreateVtabSchema(
    mut p: *mut sqlite3expert,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = idxRegisterVtab(p);
    let mut pSchema: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    rc = idxPrepareStmt(
        (*p).db,
        &mut pSchema,
        pzErrmsg,
        b"SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') ORDER BY 4, 1\0"
            as *const u8 as *const libc::c_char,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSchema) {
        let mut zType: *const libc::c_char = sqlite3_column_text(
            pSchema,
            0 as libc::c_int,
        ) as *const libc::c_char;
        let mut zName: *const libc::c_char = sqlite3_column_text(
            pSchema,
            1 as libc::c_int,
        ) as *const libc::c_char;
        let mut zSql: *const libc::c_char = sqlite3_column_text(
            pSchema,
            2 as libc::c_int,
        ) as *const libc::c_char;
        if zType.is_null() || zName.is_null() {
            continue;
        }
        if *zType.offset(0 as libc::c_int as isize) as libc::c_int == 'v' as i32
            || *zType.offset(1 as libc::c_int as isize) as libc::c_int == 'r' as i32
        {
            if !zSql.is_null() {
                rc = sqlite3_exec(
                    (*p).dbv,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    pzErrmsg,
                );
            }
        } else {
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            rc = idxGetTableInfo((*p).db, zName, &mut pTab, pzErrmsg);
            if rc == 0 as libc::c_int {
                let mut i: libc::c_int = 0;
                let mut zInner: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zOuter: *mut libc::c_char = 0 as *mut libc::c_char;
                (*pTab).pNext = (*p).pTable;
                (*p).pTable = pTab;
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    0 as *mut libc::c_char,
                    b"CREATE TABLE x(\0" as *const u8 as *const libc::c_char,
                );
                i = 0 as libc::c_int;
                while i < (*pTab).nCol {
                    zInner = idxAppendText(
                        &mut rc as *mut libc::c_int,
                        zInner,
                        b"%s%Q COLLATE %s\0" as *const u8 as *const libc::c_char,
                        if i == 0 as libc::c_int {
                            b"\0" as *const u8 as *const libc::c_char
                        } else {
                            b", \0" as *const u8 as *const libc::c_char
                        },
                        (*((*pTab).aCol).offset(i as isize)).zName,
                        (*((*pTab).aCol).offset(i as isize)).zColl,
                    );
                    i += 1;
                }
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zInner,
                    b")\0" as *const u8 as *const libc::c_char,
                );
                zOuter = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    0 as *mut libc::c_char,
                    b"CREATE VIRTUAL TABLE %Q USING expert(%Q)\0" as *const u8
                        as *const libc::c_char,
                    zName,
                    zInner,
                );
                if rc == 0 as libc::c_int {
                    rc = sqlite3_exec(
                        (*p).dbv,
                        zOuter,
                        None,
                        0 as *mut libc::c_void,
                        pzErrmsg,
                    );
                }
                sqlite3_free(zInner as *mut libc::c_void);
                sqlite3_free(zOuter as *mut libc::c_void);
            }
        }
    }
    idxFinalize(&mut rc, pSchema);
    return rc;
}
unsafe extern "C" fn idxSampleFunc(
    mut pCtx: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut IdxSampleCtx = sqlite3_user_data(pCtx) as *mut IdxSampleCtx;
    let mut bRet: libc::c_int = 0;
    if argc == 0 as libc::c_int {} else {
        __assert_fail(
            b"argc==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10697 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 61],
                &[libc::c_char; 61],
            >(b"void idxSampleFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    if (*p).nRow == 0.0f64 {
        bRet = 1 as libc::c_int;
    } else {
        bRet = ((*p).nRet / (*p).nRow <= (*p).target) as libc::c_int;
        if bRet == 0 as libc::c_int {
            let mut rnd: libc::c_ushort = 0;
            sqlite3_randomness(
                2 as libc::c_int,
                &mut rnd as *mut libc::c_ushort as *mut libc::c_void,
            );
            bRet = (rnd as libc::c_int % 100 as libc::c_int <= (*p).iTarget)
                as libc::c_int;
        }
    }
    sqlite3_result_int(pCtx, bRet);
    (*p).nRow += 1.0f64;
    (*p).nRet += bRet as libc::c_double;
}
unsafe extern "C" fn idxRemFunc(
    mut pCtx: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut IdxRemCtx = sqlite3_user_data(pCtx) as *mut IdxRemCtx;
    let mut pSlot: *mut IdxRemSlot = 0 as *mut IdxRemSlot;
    let mut iSlot: libc::c_int = 0;
    if argc == 2 as libc::c_int {} else {
        __assert_fail(
            b"argc==2\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10737 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"void idxRemFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    iSlot = sqlite3_value_int(*argv.offset(0 as libc::c_int as isize));
    if iSlot <= (*p).nSlot {} else {
        __assert_fail(
            b"iSlot<=p->nSlot\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10740 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"void idxRemFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    pSlot = &mut *((*p).aSlot).as_mut_ptr().offset(iSlot as isize) as *mut IdxRemSlot;
    match (*pSlot).eType {
        1 => {
            sqlite3_result_int64(pCtx, (*pSlot).iVal);
        }
        2 => {
            sqlite3_result_double(pCtx, (*pSlot).rVal);
        }
        4 => {
            sqlite3_result_blob(
                pCtx,
                (*pSlot).z as *const libc::c_void,
                (*pSlot).n,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        3 => {
            sqlite3_result_text(
                pCtx,
                (*pSlot).z,
                (*pSlot).n,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        5 | _ => {}
    }
    (*pSlot).eType = sqlite3_value_type(*argv.offset(1 as libc::c_int as isize));
    match (*pSlot).eType {
        1 => {
            (*pSlot).iVal = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        }
        2 => {
            (*pSlot)
                .rVal = sqlite3_value_double(*argv.offset(1 as libc::c_int as isize));
        }
        4 | 3 => {
            let mut nByte: libc::c_int = sqlite3_value_bytes(
                *argv.offset(1 as libc::c_int as isize),
            );
            let mut pData: *const libc::c_void = 0 as *const libc::c_void;
            if nByte > (*pSlot).nByte {
                let mut zNew: *mut libc::c_char = sqlite3_realloc(
                    (*pSlot).z as *mut libc::c_void,
                    nByte * 2 as libc::c_int,
                ) as *mut libc::c_char;
                if zNew.is_null() {
                    sqlite3_result_error_nomem(pCtx);
                    return;
                }
                (*pSlot).nByte = nByte * 2 as libc::c_int;
                (*pSlot).z = zNew;
            }
            (*pSlot).n = nByte;
            if (*pSlot).eType == 4 as libc::c_int {
                pData = sqlite3_value_blob(*argv.offset(1 as libc::c_int as isize));
                if !pData.is_null() {
                    memcpy(
                        (*pSlot).z as *mut libc::c_void,
                        pData,
                        nByte as libc::c_ulong,
                    );
                }
            } else {
                pData = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
                    as *const libc::c_void;
                memcpy((*pSlot).z as *mut libc::c_void, pData, nByte as libc::c_ulong);
            }
        }
        5 | _ => {}
    };
}
unsafe extern "C" fn idxLargestIndex(
    mut db: *mut sqlite3,
    mut pnMax: *mut libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zMax: *const libc::c_char = b"SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\0"
        as *const u8 as *const libc::c_char;
    let mut pMax: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    *pnMax = 0 as libc::c_int;
    rc = idxPrepareStmt(db, &mut pMax, pzErr, zMax);
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pMax) {
        *pnMax = sqlite3_column_int(pMax, 0 as libc::c_int) + 1 as libc::c_int;
    }
    idxFinalize(&mut rc, pMax);
    return rc;
}
unsafe extern "C" fn idxPopulateOneStat1(
    mut p: *mut sqlite3expert,
    mut pIndexXInfo: *mut sqlite3_stmt,
    mut pWriteStat: *mut sqlite3_stmt,
    mut zTab: *const libc::c_char,
    mut zIdx: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zOrder: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aStat: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*p).iSample > 0 as libc::c_int {} else {
        __assert_fail(
            b"p->iSample>0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10842 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 110],
                &[libc::c_char; 110],
            >(
                b"int idxPopulateOneStat1(sqlite3expert *, sqlite3_stmt *, sqlite3_stmt *, const char *, const char *, char **)\0",
            ))
                .as_ptr(),
        );
    }
    sqlite3_bind_text(pIndexXInfo, 1 as libc::c_int, zIdx, -(1 as libc::c_int), None);
    while 0 as libc::c_int == rc && 100 as libc::c_int == sqlite3_step(pIndexXInfo) {
        let mut zComma: *const libc::c_char = if zCols.is_null() {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b", \0" as *const u8 as *const libc::c_char
        };
        let mut zName: *const libc::c_char = sqlite3_column_text(
            pIndexXInfo,
            0 as libc::c_int,
        ) as *const libc::c_char;
        let mut zColl: *const libc::c_char = sqlite3_column_text(
            pIndexXInfo,
            1 as libc::c_int,
        ) as *const libc::c_char;
        zCols = idxAppendText(
            &mut rc as *mut libc::c_int,
            zCols,
            b"%sx.%Q IS rem(%d, x.%Q) COLLATE %s\0" as *const u8 as *const libc::c_char,
            zComma,
            zName,
            nCol,
            zName,
            zColl,
        );
        nCol += 1;
        zOrder = idxAppendText(
            &mut rc as *mut libc::c_int,
            zOrder,
            b"%s%d\0" as *const u8 as *const libc::c_char,
            zComma,
            nCol,
        );
    }
    sqlite3_reset(pIndexXInfo);
    if rc == 0 as libc::c_int {
        if (*p).iSample == 100 as libc::c_int {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM %Q x ORDER BY %s\0" as *const u8 as *const libc::c_char,
                zCols,
                zTab,
                zOrder,
            );
        } else {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\0"
                    as *const u8 as *const libc::c_char,
                zCols,
                zOrder,
            );
        }
    }
    sqlite3_free(zCols as *mut libc::c_void);
    sqlite3_free(zOrder as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        let mut dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = idxPrepareStmt(dbrem, &mut pQuery, pzErr, zQuery);
    }
    sqlite3_free(zQuery as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        aStat = idxMalloc(
            &mut rc,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul((nCol + 1 as libc::c_int) as libc::c_ulong) as libc::c_int,
        ) as *mut libc::c_int;
    }
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut zStat: *mut libc::c_char = 0 as *mut libc::c_char;
        i = 0 as libc::c_int;
        while i <= nCol {
            *aStat.offset(i as isize) = 1 as libc::c_int;
            i += 1;
        }
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
            let ref mut fresh29 = *aStat.offset(0 as libc::c_int as isize);
            *fresh29 += 1;
            i = 0 as libc::c_int;
            while i < nCol {
                if sqlite3_column_int(pQuery, i) == 0 as libc::c_int {
                    break;
                }
                i += 1;
            }
            while i < nCol {
                let ref mut fresh30 = *aStat.offset((i + 1 as libc::c_int) as isize);
                *fresh30 += 1;
                i += 1;
            }
        }
        if rc == 0 as libc::c_int {
            let mut s0: libc::c_int = *aStat.offset(0 as libc::c_int as isize);
            zStat = sqlite3_mprintf(b"%d\0" as *const u8 as *const libc::c_char, s0);
            if zStat.is_null() {
                rc = 7 as libc::c_int;
            }
            i = 1 as libc::c_int;
            while rc == 0 as libc::c_int && i <= nCol {
                zStat = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zStat,
                    b" %d\0" as *const u8 as *const libc::c_char,
                    (s0 + *aStat.offset(i as isize) / 2 as libc::c_int)
                        / *aStat.offset(i as isize),
                );
                i += 1;
            }
        }
        if rc == 0 as libc::c_int {
            sqlite3_bind_text(
                pWriteStat,
                1 as libc::c_int,
                zTab,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                2 as libc::c_int,
                zIdx,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                3 as libc::c_int,
                zStat,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_step(pWriteStat);
            rc = sqlite3_reset(pWriteStat);
        }
        pEntry = idxHashFind(&mut (*p).hIdx, zIdx, strlen(zIdx) as libc::c_int);
        if !pEntry.is_null() {
            if ((*pEntry).zVal2).is_null() {} else {
                __assert_fail(
                    b"pEntry->zVal2==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    10913 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 110],
                        &[libc::c_char; 110],
                    >(
                        b"int idxPopulateOneStat1(sqlite3expert *, sqlite3_stmt *, sqlite3_stmt *, const char *, const char *, char **)\0",
                    ))
                        .as_ptr(),
                );
            }
            (*pEntry).zVal2 = zStat;
        } else {
            sqlite3_free(zStat as *mut libc::c_void);
        }
    }
    sqlite3_free(aStat as *mut libc::c_void);
    idxFinalize(&mut rc, pQuery);
    return rc;
}
unsafe extern "C" fn idxBuildSampleTable(
    mut p: *mut sqlite3expert,
    mut zTab: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).dbv,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc != 0 as libc::c_int {
        return rc;
    }
    zSql = sqlite3_mprintf(
        b"CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\0"
            as *const u8 as *const libc::c_char,
        zTab,
    );
    if zSql.is_null() {
        return 7 as libc::c_int;
    }
    rc = sqlite3_exec(
        (*p).dbv,
        zSql,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn idxPopulateStat1(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nMax: libc::c_int = 0 as libc::c_int;
    let mut pCtx: *mut IdxRemCtx = 0 as *mut IdxRemCtx;
    let mut samplectx: IdxSampleCtx = IdxSampleCtx {
        iTarget: 0,
        target: 0.,
        nRow: 0.,
        nRet: 0.,
    };
    let mut i: libc::c_int = 0;
    let mut iPrev: i64_0 = -(100000 as libc::c_int) as i64_0;
    let mut pAllIndex: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIndexXInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pWrite: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zAllIndex: *const libc::c_char = b"SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\0"
        as *const u8 as *const libc::c_char;
    let mut zIndexXInfo: *const libc::c_char = b"SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\0"
        as *const u8 as *const libc::c_char;
    let mut zWrite: *const libc::c_char = b"INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\0"
        as *const u8 as *const libc::c_char;
    if (*p).iSample == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    rc = idxLargestIndex((*p).dbm, &mut nMax, pzErr);
    if nMax <= 0 as libc::c_int || rc != 0 as libc::c_int {
        return rc;
    }
    rc = sqlite3_exec(
        (*p).dbm,
        b"ANALYZE; PRAGMA writable_schema=1\0" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc == 0 as libc::c_int {
        let mut nByte: libc::c_int = (::core::mem::size_of::<IdxRemCtx>()
            as libc::c_ulong)
            .wrapping_add(
                (::core::mem::size_of::<IdxRemSlot>() as libc::c_ulong)
                    .wrapping_mul(nMax as libc::c_ulong),
            ) as libc::c_int;
        pCtx = idxMalloc(&mut rc, nByte) as *mut IdxRemCtx;
    }
    if rc == 0 as libc::c_int {
        let mut dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = sqlite3_create_function(
            dbrem,
            b"rem\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            pCtx as *mut libc::c_void,
            Some(
                idxRemFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            (*p).db,
            b"sample\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            1 as libc::c_int,
            &mut samplectx as *mut IdxSampleCtx as *mut libc::c_void,
            Some(
                idxSampleFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        (*pCtx).nSlot = nMax + 1 as libc::c_int;
        rc = idxPrepareStmt((*p).dbm, &mut pAllIndex, pzErr, zAllIndex);
    }
    if rc == 0 as libc::c_int {
        rc = idxPrepareStmt((*p).dbm, &mut pIndexXInfo, pzErr, zIndexXInfo);
    }
    if rc == 0 as libc::c_int {
        rc = idxPrepareStmt((*p).dbm, &mut pWrite, pzErr, zWrite);
    }
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pAllIndex) {
        let mut iRowid: i64_0 = sqlite3_column_int64(pAllIndex, 0 as libc::c_int);
        let mut zTab: *const libc::c_char = sqlite3_column_text(
            pAllIndex,
            1 as libc::c_int,
        ) as *const libc::c_char;
        let mut zIdx: *const libc::c_char = sqlite3_column_text(
            pAllIndex,
            2 as libc::c_int,
        ) as *const libc::c_char;
        if zTab.is_null() || zIdx.is_null() {
            continue;
        }
        if (*p).iSample < 100 as libc::c_int && iPrev != iRowid {
            samplectx.target = (*p).iSample as libc::c_double / 100.0f64;
            samplectx.iTarget = (*p).iSample;
            samplectx.nRow = 0.0f64;
            samplectx.nRet = 0.0f64;
            rc = idxBuildSampleTable(p, zTab);
            if rc != 0 as libc::c_int {
                break;
            }
        }
        rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
        iPrev = iRowid;
    }
    if rc == 0 as libc::c_int && (*p).iSample < 100 as libc::c_int {
        rc = sqlite3_exec(
            (*p).dbv,
            b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0"
                as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    idxFinalize(&mut rc, pAllIndex);
    idxFinalize(&mut rc, pIndexXInfo);
    idxFinalize(&mut rc, pWrite);
    if !pCtx.is_null() {
        i = 0 as libc::c_int;
        while i < (*pCtx).nSlot {
            sqlite3_free(
                (*((*pCtx).aSlot).as_mut_ptr().offset(i as isize)).z as *mut libc::c_void,
            );
            i += 1;
        }
        sqlite3_free(pCtx as *mut libc::c_void);
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec(
            (*p).dbm,
            b"ANALYZE sqlite_schema\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    sqlite3_exec(
        (*p).db,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_new(
    mut db: *mut sqlite3,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> *mut sqlite3expert {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pNew: *mut sqlite3expert = 0 as *mut sqlite3expert;
    pNew = idxMalloc(
        &mut rc,
        ::core::mem::size_of::<sqlite3expert>() as libc::c_ulong as libc::c_int,
    ) as *mut sqlite3expert;
    if rc == 0 as libc::c_int {
        (*pNew).db = db;
        (*pNew).iSample = 100 as libc::c_int;
        rc = sqlite3_open(
            b":memory:\0" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbv,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_open(
            b":memory:\0" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbm,
        );
        if rc == 0 as libc::c_int {
            sqlite3_db_config(
                (*pNew).dbm,
                1008 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_int,
            );
        }
    }
    if rc == 0 as libc::c_int {
        let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = idxPrintfPrepareStmt(
            (*pNew).db,
            &mut pSql as *mut *mut sqlite3_stmt,
            pzErrmsg,
            b"SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\0"
                as *const u8 as *const libc::c_char,
        );
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            let mut zSql: *const libc::c_char = sqlite3_column_text(
                pSql,
                0 as libc::c_int,
            ) as *const libc::c_char;
            if !zSql.is_null() {
                rc = sqlite3_exec(
                    (*pNew).dbm,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    pzErrmsg,
                );
            }
        }
        idxFinalize(&mut rc, pSql);
    }
    if rc == 0 as libc::c_int {
        rc = idxCreateVtabSchema(pNew, pzErrmsg);
    }
    if rc == 0 as libc::c_int {
        sqlite3_set_authorizer(
            (*pNew).dbv,
            Some(
                idxAuthCallback
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> libc::c_int,
            ),
            pNew as *mut libc::c_void,
        );
    }
    if rc != 0 as libc::c_int {
        sqlite3_expert_destroy(pNew);
        pNew = 0 as *mut sqlite3expert;
    }
    return pNew;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_config(
    mut p: *mut sqlite3expert,
    mut op: libc::c_int,
    mut args: ...
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    match op {
        1 => {
            let mut iVal: libc::c_int = ap.arg::<libc::c_int>();
            if iVal < 0 as libc::c_int {
                iVal = 0 as libc::c_int;
            }
            if iVal > 100 as libc::c_int {
                iVal = 100 as libc::c_int;
            }
            (*p).iSample = iVal;
        }
        _ => {
            rc = 12 as libc::c_int;
        }
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_sql(
    mut p: *mut sqlite3expert,
    mut zSql: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pScanOrig: *mut IdxScan = (*p).pScan;
    let mut pStmtOrig: *mut IdxStatement = (*p).pStatement;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zStmt: *const libc::c_char = zSql;
    if (*p).bRun != 0 {
        return 21 as libc::c_int;
    }
    while rc == 0 as libc::c_int && !zStmt.is_null()
        && *zStmt.offset(0 as libc::c_int as isize) as libc::c_int != 0
    {
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zStmt,
            -(1 as libc::c_int),
            &mut pStmt,
            &mut zStmt,
        );
        if rc == 0 as libc::c_int {
            if !pStmt.is_null() {
                let mut pNew: *mut IdxStatement = 0 as *mut IdxStatement;
                let mut z: *const libc::c_char = sqlite3_sql(pStmt);
                let mut n: libc::c_int = strlen(z) as libc::c_int;
                pNew = idxMalloc(
                    &mut rc,
                    (::core::mem::size_of::<IdxStatement>() as libc::c_ulong)
                        .wrapping_add(n as libc::c_ulong)
                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
                ) as *mut IdxStatement;
                if rc == 0 as libc::c_int {
                    (*pNew)
                        .zSql = &mut *pNew.offset(1 as libc::c_int as isize)
                        as *mut IdxStatement as *mut libc::c_char;
                    memcpy(
                        (*pNew).zSql as *mut libc::c_void,
                        z as *const libc::c_void,
                        (n + 1 as libc::c_int) as libc::c_ulong,
                    );
                    (*pNew).pNext = (*p).pStatement;
                    if !((*p).pStatement).is_null() {
                        (*pNew).iId = (*(*p).pStatement).iId + 1 as libc::c_int;
                    }
                    (*p).pStatement = pNew;
                }
                sqlite3_finalize(pStmt);
            }
        } else {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    if rc != 0 as libc::c_int {
        idxScanFree((*p).pScan, pScanOrig);
        idxStatementFree((*p).pStatement, pStmtOrig);
        (*p).pScan = pScanOrig;
        (*p).pStatement = pStmtOrig;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_analyze(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    rc = idxProcessTriggers(p, pzErr);
    if rc == 0 as libc::c_int {
        rc = idxCreateCandidates(p);
    } else if rc == 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int {
        if !pzErr.is_null() {
            *pzErr = sqlite3_mprintf(
                b"Cannot find a unique index name to propose.\0" as *const u8
                    as *const libc::c_char,
            );
        }
        return rc;
    }
    if rc == 0 as libc::c_int {
        rc = idxPopulateStat1(p, pzErr);
    }
    pEntry = (*p).hIdx.pFirst;
    while !pEntry.is_null() {
        (*p)
            .zCandidates = idxAppendText(
            &mut rc as *mut libc::c_int,
            (*p).zCandidates,
            b"%s;%s%s\n\0" as *const u8 as *const libc::c_char,
            (*pEntry).zVal,
            if !((*pEntry).zVal2).is_null() {
                b" -- stat1: \0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
            (*pEntry).zVal2,
        );
        pEntry = (*pEntry).pNext;
    }
    if rc == 0 as libc::c_int {
        rc = idxFindIndexes(p, pzErr);
    }
    if rc == 0 as libc::c_int {
        (*p).bRun = 1 as libc::c_int;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_count(mut p: *mut sqlite3expert) -> libc::c_int {
    let mut nRet: libc::c_int = 0 as libc::c_int;
    if !((*p).pStatement).is_null() {
        nRet = (*(*p).pStatement).iId + 1 as libc::c_int;
    }
    return nRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_report(
    mut p: *mut sqlite3expert,
    mut iStmt: libc::c_int,
    mut eReport: libc::c_int,
) -> *const libc::c_char {
    let mut zRet: *const libc::c_char = 0 as *const libc::c_char;
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    if (*p).bRun == 0 as libc::c_int {
        return 0 as *const libc::c_char;
    }
    pStmt = (*p).pStatement;
    while !pStmt.is_null() && (*pStmt).iId != iStmt {
        pStmt = (*pStmt).pNext;
    }
    match eReport {
        1 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zSql;
            }
        }
        2 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zIdx;
            }
        }
        3 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zEQP;
            }
        }
        4 => {
            zRet = (*p).zCandidates;
        }
        _ => {}
    }
    return zRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_destroy(mut p: *mut sqlite3expert) {
    if !p.is_null() {
        sqlite3_close((*p).dbm);
        sqlite3_close((*p).dbv);
        idxScanFree((*p).pScan, 0 as *mut IdxScan);
        idxStatementFree((*p).pStatement, 0 as *mut IdxStatement);
        idxTableFree((*p).pTable);
        idxWriteFree((*p).pWrite);
        idxHashClear(&mut (*p).hIdx);
        sqlite3_free((*p).zCandidates as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
}
static mut modeDescr: [*const libc::c_char; 19] = [
    b"line\0" as *const u8 as *const libc::c_char,
    b"column\0" as *const u8 as *const libc::c_char,
    b"list\0" as *const u8 as *const libc::c_char,
    b"semi\0" as *const u8 as *const libc::c_char,
    b"html\0" as *const u8 as *const libc::c_char,
    b"insert\0" as *const u8 as *const libc::c_char,
    b"quote\0" as *const u8 as *const libc::c_char,
    b"tcl\0" as *const u8 as *const libc::c_char,
    b"csv\0" as *const u8 as *const libc::c_char,
    b"explain\0" as *const u8 as *const libc::c_char,
    b"ascii\0" as *const u8 as *const libc::c_char,
    b"prettyprint\0" as *const u8 as *const libc::c_char,
    b"eqp\0" as *const u8 as *const libc::c_char,
    b"json\0" as *const u8 as *const libc::c_char,
    b"markdown\0" as *const u8 as *const libc::c_char,
    b"table\0" as *const u8 as *const libc::c_char,
    b"box\0" as *const u8 as *const libc::c_char,
    b"count\0" as *const u8 as *const libc::c_char,
    b"off\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn shellLog(
    mut pArg: *mut libc::c_void,
    mut iErrCode: libc::c_int,
    mut zMsg: *const libc::c_char,
) {
    let mut p: *mut ShellState = pArg as *mut ShellState;
    if ((*p).pLog).is_null() {
        return;
    }
    fprintf(
        (*p).pLog,
        b"(%d) %s\n\0" as *const u8 as *const libc::c_char,
        iErrCode,
        zMsg,
    );
    fflush((*p).pLog);
}
unsafe extern "C" fn shellPutsFunc(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut p: *mut ShellState = sqlite3_user_data(pCtx) as *mut ShellState;
    fprintf(
        (*p).out,
        b"%s\n\0" as *const u8 as *const libc::c_char,
        sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)),
    );
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn failIfSafeMode(
    mut p: *mut ShellState,
    mut zErrMsg: *const libc::c_char,
    mut args: ...
) {
    if (*p).bSafeMode != 0 {
        let mut ap: ::core::ffi::VaListImpl;
        let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        zMsg = sqlite3_vmprintf(zErrMsg, ap.as_va_list());
        fprintf(stderr, b"line %d: \0" as *const u8 as *const libc::c_char, (*p).lineno);
        fprintf(stderr, b"%s\n\0" as *const u8 as *const libc::c_char, zMsg);
        exit(1 as libc::c_int);
    }
}
unsafe extern "C" fn editFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zEditor: *const libc::c_char = 0 as *const libc::c_char;
    let mut zTempFile: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bBin: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut hasCRNL: libc::c_int = 0 as libc::c_int;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut sz: sqlite3_int64 = 0;
    let mut x: sqlite3_int64 = 0;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if argc == 2 as libc::c_int {
        zEditor = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
            as *const libc::c_char;
    } else {
        zEditor = getenv(b"VISUAL\0" as *const u8 as *const libc::c_char);
    }
    if zEditor.is_null() {
        sqlite3_result_error(
            context,
            b"no editor for edit()\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        sqlite3_result_error(
            context,
            b"NULL input to edit()\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    db = sqlite3_context_db_handle(context);
    zTempFile = 0 as *mut libc::c_char;
    sqlite3_file_control(
        db,
        0 as *const libc::c_char,
        16 as libc::c_int,
        &mut zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
    );
    if zTempFile.is_null() {
        let mut r: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        sqlite3_randomness(
            ::core::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTempFile = sqlite3_mprintf(
            b"temp%llx\0" as *const u8 as *const libc::c_char,
            r,
        );
        if zTempFile.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        }
    }
    bBin = (sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
        == 4 as libc::c_int) as libc::c_int;
    f = fopen(
        zTempFile,
        if bBin != 0 {
            b"wb\0" as *const u8 as *const libc::c_char
        } else {
            b"w\0" as *const u8 as *const libc::c_char
        },
    );
    if f.is_null() {
        sqlite3_result_error(
            context,
            b"edit() cannot open temp file\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
    } else {
        sz = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
            as sqlite3_int64;
        if bBin != 0 {
            x = fwrite(
                sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)),
                1 as libc::c_int as libc::c_ulong,
                sz as size_t,
                f,
            ) as sqlite3_int64;
        } else {
            let mut z: *const libc::c_char = sqlite3_value_text(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const libc::c_char;
            if !z.is_null()
                && !(strstr(z, b"\r\n\0" as *const u8 as *const libc::c_char)).is_null()
            {
                hasCRNL = 1 as libc::c_int;
            }
            x = fwrite(
                sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
                    as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                sz as size_t,
                f,
            ) as sqlite3_int64;
        }
        fclose(f);
        f = 0 as *mut FILE;
        if x != sz {
            sqlite3_result_error(
                context,
                b"edit() could not write the whole file\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            zCmd = sqlite3_mprintf(
                b"%s \"%s\"\0" as *const u8 as *const libc::c_char,
                zEditor,
                zTempFile,
            );
            if zCmd.is_null() {
                sqlite3_result_error_nomem(context);
            } else {
                rc = system(zCmd);
                sqlite3_free(zCmd as *mut libc::c_void);
                if rc != 0 {
                    sqlite3_result_error(
                        context,
                        b"EDITOR returned non-zero\0" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                    );
                } else {
                    f = fopen(zTempFile, b"rb\0" as *const u8 as *const libc::c_char);
                    if f.is_null() {
                        sqlite3_result_error(
                            context,
                            b"edit() cannot reopen temp file after edit\0" as *const u8
                                as *const libc::c_char,
                            -(1 as libc::c_int),
                        );
                    } else {
                        fseek(f, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
                        sz = ftell(f) as sqlite3_int64;
                        rewind(f);
                        p = sqlite3_malloc64(
                            (sz + 1 as libc::c_int as libc::c_longlong) as sqlite3_uint64,
                        ) as *mut libc::c_uchar;
                        if p.is_null() {
                            sqlite3_result_error_nomem(context);
                        } else {
                            x = fread(
                                p as *mut libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                sz as size_t,
                                f,
                            ) as sqlite3_int64;
                            fclose(f);
                            f = 0 as *mut FILE;
                            if x != sz {
                                sqlite3_result_error(
                                    context,
                                    b"could not read back the whole file\0" as *const u8
                                        as *const libc::c_char,
                                    -(1 as libc::c_int),
                                );
                            } else {
                                if bBin != 0 {
                                    sqlite3_result_blob64(
                                        context,
                                        p as *const libc::c_void,
                                        sz as sqlite3_uint64,
                                        Some(
                                            sqlite3_free
                                                as unsafe extern "C" fn(*mut libc::c_void) -> (),
                                        ),
                                    );
                                } else {
                                    let mut i: sqlite3_int64 = 0;
                                    let mut j: sqlite3_int64 = 0;
                                    if !(hasCRNL != 0) {
                                        j = 0 as libc::c_int as sqlite3_int64;
                                        i = j;
                                        while i < sz {
                                            if *p.offset(i as isize) as libc::c_int == '\r' as i32
                                                && *p
                                                    .offset((i + 1 as libc::c_int as libc::c_longlong) as isize)
                                                    as libc::c_int == '\n' as i32
                                            {
                                                i += 1;
                                            }
                                            let fresh31 = j;
                                            j = j + 1;
                                            *p.offset(fresh31 as isize) = *p.offset(i as isize);
                                            i += 1;
                                        }
                                        sz = j;
                                        *p.offset(sz as isize) = 0 as libc::c_int as libc::c_uchar;
                                    }
                                    sqlite3_result_text64(
                                        context,
                                        p as *const libc::c_char,
                                        sz as sqlite3_uint64,
                                        Some(
                                            sqlite3_free
                                                as unsafe extern "C" fn(*mut libc::c_void) -> (),
                                        ),
                                        1 as libc::c_int as libc::c_uchar,
                                    );
                                }
                                p = 0 as *mut libc::c_uchar;
                            }
                        }
                    }
                }
            }
        }
    }
    if !f.is_null() {
        fclose(f);
    }
    unlink(zTempFile);
    sqlite3_free(zTempFile as *mut libc::c_void);
    sqlite3_free(p as *mut libc::c_void);
}
unsafe extern "C" fn outputModePush(mut p: *mut ShellState) {
    (*p).modePrior = (*p).mode;
    (*p).priorShFlgs = (*p).shellFlgs;
    memcpy(
        ((*p).colSepPrior).as_mut_ptr() as *mut libc::c_void,
        ((*p).colSeparator).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        ((*p).rowSepPrior).as_mut_ptr() as *mut libc::c_void,
        ((*p).rowSeparator).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn outputModePop(mut p: *mut ShellState) {
    (*p).mode = (*p).modePrior;
    (*p).shellFlgs = (*p).priorShFlgs;
    memcpy(
        ((*p).colSeparator).as_mut_ptr() as *mut libc::c_void,
        ((*p).colSepPrior).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        ((*p).rowSeparator).as_mut_ptr() as *mut libc::c_void,
        ((*p).rowSepPrior).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn output_hex_blob(
    mut out: *mut FILE,
    mut pBlob: *const libc::c_void,
    mut nBlob: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut zBlob: *mut libc::c_char = pBlob as *mut libc::c_char;
    fprintf(out, b"X'\0" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int;
    while i < nBlob {
        fprintf(
            out,
            b"%02x\0" as *const u8 as *const libc::c_char,
            *zBlob.offset(i as isize) as libc::c_int & 0xff as libc::c_int,
        );
        i += 1;
    }
    fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn unused_string(
    mut z: *const libc::c_char,
    mut zA: *const libc::c_char,
    mut zB: *const libc::c_char,
    mut zBuf: *mut libc::c_char,
) -> *const libc::c_char {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if (strstr(z, zA)).is_null() {
        return zA;
    }
    if (strstr(z, zB)).is_null() {
        return zB;
    }
    loop {
        let fresh32 = i;
        i = i.wrapping_add(1);
        sqlite3_snprintf(
            20 as libc::c_int,
            zBuf,
            b"(%s%u)\0" as *const u8 as *const libc::c_char,
            zA,
            fresh32,
        );
        if (strstr(z, zBuf)).is_null() {
            break;
        }
    }
    return zBuf;
}
unsafe extern "C" fn output_quoted_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32) {
            break;
        }
        i += 1;
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"'%s'\0" as *const u8 as *const libc::c_char, z);
    } else {
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1;
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1;
            }
            if i != 0 {
                fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize);
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
            }
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
    };
}
unsafe extern "C" fn output_quoted_escaped_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32
            && c as libc::c_int != '\n' as i32 && c as libc::c_int != '\r' as i32)
        {
            break;
        }
        i += 1;
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"'%s'\0" as *const u8 as *const libc::c_char, z);
    } else {
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        i = 0 as libc::c_int;
        while *z.offset(i as isize) != 0 {
            if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
                nNL += 1;
            }
            if *z.offset(i as isize) as libc::c_int == '\r' as i32 {
                nCR += 1;
            }
            i += 1;
        }
        if nNL != 0 {
            fprintf(out, b"replace(\0" as *const u8 as *const libc::c_char);
            zNL = unused_string(
                z,
                b"\\n\0" as *const u8 as *const libc::c_char,
                b"\\012\0" as *const u8 as *const libc::c_char,
                zBuf1.as_mut_ptr(),
            );
        }
        if nCR != 0 {
            fprintf(out, b"replace(\0" as *const u8 as *const libc::c_char);
            zCR = unused_string(
                z,
                b"\\r\0" as *const u8 as *const libc::c_char,
                b"\\015\0" as *const u8 as *const libc::c_char,
                zBuf2.as_mut_ptr(),
            );
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\n' as i32 && c as libc::c_int != '\r' as i32
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1;
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1;
            }
            if i != 0 {
                fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize);
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
                if c as libc::c_int == '\n' as i32 {
                    fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zNL);
                } else {
                    fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zCR);
                }
            }
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        if nCR != 0 {
            fprintf(out, b",'%s',char(13))\0" as *const u8 as *const libc::c_char, zCR);
        }
        if nNL != 0 {
            fprintf(out, b",'%s',char(10))\0" as *const u8 as *const libc::c_char, zNL);
        }
    };
}
unsafe extern "C" fn output_c_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut c: libc::c_uint = 0;
    fputc('"' as i32, out);
    loop {
        let fresh33 = z;
        z = z.offset(1);
        c = *fresh33 as libc::c_uint;
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        if c == '\\' as i32 as libc::c_uint {
            fputc(c as libc::c_int, out);
            fputc(c as libc::c_int, out);
        } else if c == '"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('"' as i32, out);
        } else if c == '\t' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('t' as i32, out);
        } else if c == '\n' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('n' as i32, out);
        } else if c == '\r' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('r' as i32, out);
        } else if *(*__ctype_b_loc())
            .offset((c & 0xff as libc::c_int as libc::c_uint) as libc::c_int as isize)
            as libc::c_int & _ISprint as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            fprintf(
                out,
                b"\\%03o\0" as *const u8 as *const libc::c_char,
                c & 0xff as libc::c_int as libc::c_uint,
            );
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('"' as i32, out);
}
unsafe extern "C" fn output_json_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
    mut n: libc::c_int,
) {
    let mut c: libc::c_uint = 0;
    if n < 0 as libc::c_int {
        n = strlen(z) as libc::c_int;
    }
    fputc('"' as i32, out);
    loop {
        let fresh34 = n;
        n = n - 1;
        if !(fresh34 != 0) {
            break;
        }
        let fresh35 = z;
        z = z.offset(1);
        c = *fresh35 as libc::c_uint;
        if c == '\\' as i32 as libc::c_uint || c == '"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc(c as libc::c_int, out);
        } else if c <= 0x1f as libc::c_int as libc::c_uint {
            fputc('\\' as i32, out);
            if c == '\u{8}' as i32 as libc::c_uint {
                fputc('b' as i32, out);
            } else if c == '\u{c}' as i32 as libc::c_uint {
                fputc('f' as i32, out);
            } else if c == '\n' as i32 as libc::c_uint {
                fputc('n' as i32, out);
            } else if c == '\r' as i32 as libc::c_uint {
                fputc('r' as i32, out);
            } else if c == '\t' as i32 as libc::c_uint {
                fputc('t' as i32, out);
            } else {
                fprintf(out, b"u%04x\0" as *const u8 as *const libc::c_char, c);
            }
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('"' as i32, out);
}
unsafe extern "C" fn output_html_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    if z.is_null() {
        z = b"\0" as *const u8 as *const libc::c_char;
    }
    while *z != 0 {
        i = 0 as libc::c_int;
        while *z.offset(i as isize) as libc::c_int != 0
            && *z.offset(i as isize) as libc::c_int != '<' as i32
            && *z.offset(i as isize) as libc::c_int != '&' as i32
            && *z.offset(i as isize) as libc::c_int != '>' as i32
            && *z.offset(i as isize) as libc::c_int != '"' as i32
            && *z.offset(i as isize) as libc::c_int != '\'' as i32
        {
            i += 1;
        }
        if i > 0 as libc::c_int {
            fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
        }
        if *z.offset(i as isize) as libc::c_int == '<' as i32 {
            fprintf(out, b"&lt;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '&' as i32 {
            fprintf(out, b"&amp;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '>' as i32 {
            fprintf(out, b"&gt;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '"' as i32 {
            fprintf(out, b"&quot;\0" as *const u8 as *const libc::c_char);
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\'' as i32) {
                break;
            }
            fprintf(out, b"&#39;\0" as *const u8 as *const libc::c_char);
        }
        z = z.offset((i + 1 as libc::c_int) as isize);
    }
}
static mut needCsvQuote: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
unsafe extern "C" fn output_csv(
    mut p: *mut ShellState,
    mut z: *const libc::c_char,
    mut bSep: libc::c_int,
) {
    let mut out: *mut FILE = (*p).out;
    if z.is_null() {
        fprintf(
            out,
            b"%s\0" as *const u8 as *const libc::c_char,
            ((*p).nullValue).as_mut_ptr(),
        );
    } else {
        let mut i: libc::c_uint = 0;
        i = 0 as libc::c_int as libc::c_uint;
        while *z.offset(i as isize) != 0 {
            if needCsvQuote[*(z as *mut libc::c_uchar).offset(i as isize) as usize] != 0
            {
                i = 0 as libc::c_int as libc::c_uint;
                break;
            } else {
                i = i.wrapping_add(1);
            }
        }
        if i == 0 as libc::c_int as libc::c_uint
            || !(strstr(z, ((*p).colSeparator).as_mut_ptr())).is_null()
        {
            let mut zQuoted: *mut libc::c_char = sqlite3_mprintf(
                b"\"%w\"\0" as *const u8 as *const libc::c_char,
                z,
            );
            shell_check_oom(zQuoted as *mut libc::c_void);
            fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zQuoted);
            sqlite3_free(zQuoted as *mut libc::c_void);
        } else {
            fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, z);
        }
    }
    if bSep != 0 {
        fprintf(
            (*p).out,
            b"%s\0" as *const u8 as *const libc::c_char,
            ((*p).colSeparator).as_mut_ptr(),
        );
    }
}
unsafe extern "C" fn interrupt_handler(mut NotUsed: libc::c_int) {
    ::core::ptr::write_volatile(
        &mut seenInterrupt as *mut libc::c_int,
        ::core::ptr::read_volatile::<libc::c_int>(&seenInterrupt as *const libc::c_int)
            + 1,
    );
    if seenInterrupt > 2 as libc::c_int {
        exit(1 as libc::c_int);
    }
    if !globalDb.is_null() {
        sqlite3_interrupt(globalDb);
    }
}
unsafe extern "C" fn safeModeAuth(
    mut pClientData: *mut libc::c_void,
    mut op: libc::c_int,
    mut zA1: *const libc::c_char,
    mut zA2: *const libc::c_char,
    mut zA3: *const libc::c_char,
    mut zA4: *const libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    static mut azProhibitedFunctions: [*const libc::c_char; 7] = [
        b"edit\0" as *const u8 as *const libc::c_char,
        b"fts3_tokenizer\0" as *const u8 as *const libc::c_char,
        b"load_extension\0" as *const u8 as *const libc::c_char,
        b"readfile\0" as *const u8 as *const libc::c_char,
        b"writefile\0" as *const u8 as *const libc::c_char,
        b"zipfile\0" as *const u8 as *const libc::c_char,
        b"zipfile_cds\0" as *const u8 as *const libc::c_char,
    ];
    match op {
        24 => {
            failIfSafeMode(
                p,
                b"cannot run ATTACH in safe mode\0" as *const u8 as *const libc::c_char,
            );
        }
        31 => {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::core::mem::size_of::<[*const libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int
            {
                if sqlite3_stricmp(zA1, azProhibitedFunctions[i as usize])
                    == 0 as libc::c_int
                {
                    failIfSafeMode(
                        p,
                        b"cannot use the %s() function in safe mode\0" as *const u8
                            as *const libc::c_char,
                        azProhibitedFunctions[i as usize],
                    );
                }
                i += 1;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn shellAuth(
    mut pClientData: *mut libc::c_void,
    mut op: libc::c_int,
    mut zA1: *const libc::c_char,
    mut zA2: *const libc::c_char,
    mut zA3: *const libc::c_char,
    mut zA4: *const libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    static mut azAction: [*const libc::c_char; 34] = [
        0 as *const libc::c_char,
        b"CREATE_INDEX\0" as *const u8 as *const libc::c_char,
        b"CREATE_TABLE\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_INDEX\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TABLE\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_VIEW\0" as *const u8 as *const libc::c_char,
        b"CREATE_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"CREATE_VIEW\0" as *const u8 as *const libc::c_char,
        b"DELETE\0" as *const u8 as *const libc::c_char,
        b"DROP_INDEX\0" as *const u8 as *const libc::c_char,
        b"DROP_TABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_INDEX\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_VIEW\0" as *const u8 as *const libc::c_char,
        b"DROP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"DROP_VIEW\0" as *const u8 as *const libc::c_char,
        b"INSERT\0" as *const u8 as *const libc::c_char,
        b"PRAGMA\0" as *const u8 as *const libc::c_char,
        b"READ\0" as *const u8 as *const libc::c_char,
        b"SELECT\0" as *const u8 as *const libc::c_char,
        b"TRANSACTION\0" as *const u8 as *const libc::c_char,
        b"UPDATE\0" as *const u8 as *const libc::c_char,
        b"ATTACH\0" as *const u8 as *const libc::c_char,
        b"DETACH\0" as *const u8 as *const libc::c_char,
        b"ALTER_TABLE\0" as *const u8 as *const libc::c_char,
        b"REINDEX\0" as *const u8 as *const libc::c_char,
        b"ANALYZE\0" as *const u8 as *const libc::c_char,
        b"CREATE_VTABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_VTABLE\0" as *const u8 as *const libc::c_char,
        b"FUNCTION\0" as *const u8 as *const libc::c_char,
        b"SAVEPOINT\0" as *const u8 as *const libc::c_char,
        b"RECURSIVE\0" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let mut az: [*const libc::c_char; 4] = [0 as *const libc::c_char; 4];
    az[0 as libc::c_int as usize] = zA1;
    az[1 as libc::c_int as usize] = zA2;
    az[2 as libc::c_int as usize] = zA3;
    az[3 as libc::c_int as usize] = zA4;
    fprintf(
        (*p).out,
        b"authorizer: %s\0" as *const u8 as *const libc::c_char,
        azAction[op as usize],
    );
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        fprintf((*p).out, b" \0" as *const u8 as *const libc::c_char);
        if !(az[i as usize]).is_null() {
            output_c_string((*p).out, az[i as usize]);
        } else {
            fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
        }
        i += 1;
    }
    fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
    if (*p).bSafeMode != 0 {
        safeModeAuth(pClientData, op, zA1, zA2, zA3, zA4);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn printSchemaLine(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
    mut zTail: *const libc::c_char,
) {
    if z.is_null() {
        return;
    }
    if zTail.is_null() {
        return;
    }
    if sqlite3_strglob(b"CREATE TABLE ['\"]*\0" as *const u8 as *const libc::c_char, z)
        == 0 as libc::c_int
    {
        fprintf(
            out,
            b"CREATE TABLE IF NOT EXISTS %s%s\0" as *const u8 as *const libc::c_char,
            z.offset(13 as libc::c_int as isize),
            zTail,
        );
    } else {
        fprintf(out, b"%s%s\0" as *const u8 as *const libc::c_char, z, zTail);
    };
}
unsafe extern "C" fn printSchemaLineN(
    mut out: *mut FILE,
    mut z: *mut libc::c_char,
    mut n: libc::c_int,
    mut zTail: *const libc::c_char,
) {
    let mut c: libc::c_char = *z.offset(n as isize);
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
    printSchemaLine(out, z, zTail);
    *z.offset(n as isize) = c;
}
unsafe extern "C" fn wsToEol(mut z: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while *z.offset(i as isize) != 0 {
        if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
            return 1 as libc::c_int;
        }
        if *(*__ctype_b_loc())
            .offset(*z.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            i += 1;
        } else {
            if *z.offset(i as isize) as libc::c_int == '-' as i32
                && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    == '-' as i32
            {
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn eqp_append(
    mut p: *mut ShellState,
    mut iEqpId: libc::c_int,
    mut p2: libc::c_int,
    mut zText: *const libc::c_char,
) {
    let mut pNew: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut nText: libc::c_int = strlen30(zText);
    if (*p).autoEQPtest != 0 {
        fprintf(
            (*p).out,
            b"%d,%d,%s\n\0" as *const u8 as *const libc::c_char,
            iEqpId,
            p2,
            zText,
        );
    }
    pNew = sqlite3_malloc64(
        (::core::mem::size_of::<EQPGraphRow>() as libc::c_ulong)
            .wrapping_add(nText as libc::c_ulong) as sqlite3_uint64,
    ) as *mut EQPGraphRow;
    shell_check_oom(pNew as *mut libc::c_void);
    (*pNew).iEqpId = iEqpId;
    (*pNew).iParentId = p2;
    memcpy(
        ((*pNew).zText).as_mut_ptr() as *mut libc::c_void,
        zText as *const libc::c_void,
        (nText + 1 as libc::c_int) as libc::c_ulong,
    );
    (*pNew).pNext = 0 as *mut EQPGraphRow;
    if !((*p).sGraph.pLast).is_null() {
        (*(*p).sGraph.pLast).pNext = pNew;
    } else {
        (*p).sGraph.pRow = pNew;
    }
    (*p).sGraph.pLast = pNew;
}
unsafe extern "C" fn eqp_reset(mut p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    pRow = (*p).sGraph.pRow;
    while !pRow.is_null() {
        pNext = (*pRow).pNext;
        sqlite3_free(pRow as *mut libc::c_void);
        pRow = pNext;
    }
    memset(
        &mut (*p).sGraph as *mut EQPGraph as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<EQPGraph>() as libc::c_ulong,
    );
}
unsafe extern "C" fn eqp_next_row(
    mut p: *mut ShellState,
    mut iEqpId: libc::c_int,
    mut pOld: *mut EQPGraphRow,
) -> *mut EQPGraphRow {
    let mut pRow: *mut EQPGraphRow = if !pOld.is_null() {
        (*pOld).pNext
    } else {
        (*p).sGraph.pRow
    };
    while !pRow.is_null() && (*pRow).iParentId != iEqpId {
        pRow = (*pRow).pNext;
    }
    return pRow;
}
unsafe extern "C" fn eqp_render_level(mut p: *mut ShellState, mut iEqpId: libc::c_int) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut n: libc::c_int = strlen30(((*p).sGraph.zPrefix).as_mut_ptr());
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    pRow = eqp_next_row(p, iEqpId, 0 as *mut EQPGraphRow);
    while !pRow.is_null() {
        pNext = eqp_next_row(p, iEqpId, pRow);
        z = ((*pRow).zText).as_mut_ptr();
        fprintf(
            (*p).out,
            b"%s%s%s\n\0" as *const u8 as *const libc::c_char,
            ((*p).sGraph.zPrefix).as_mut_ptr(),
            if !pNext.is_null() {
                b"|--\0" as *const u8 as *const libc::c_char
            } else {
                b"`--\0" as *const u8 as *const libc::c_char
            },
            z,
        );
        if n
            < ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                as libc::c_int - 7 as libc::c_int
        {
            memcpy(
                &mut *((*p).sGraph.zPrefix).as_mut_ptr().offset(n as isize)
                    as *mut libc::c_char as *mut libc::c_void,
                (if !pNext.is_null() {
                    b"|  \0" as *const u8 as *const libc::c_char
                } else {
                    b"   \0" as *const u8 as *const libc::c_char
                }) as *const libc::c_void,
                4 as libc::c_int as libc::c_ulong,
            );
            eqp_render_level(p, (*pRow).iEqpId);
            (*p).sGraph.zPrefix[n as usize] = 0 as libc::c_int as libc::c_char;
        }
        pRow = pNext;
    }
}
unsafe extern "C" fn eqp_render(mut p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = (*p).sGraph.pRow;
    if !pRow.is_null() {
        if *((*pRow).zText).as_mut_ptr().offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
        {
            if ((*pRow).pNext).is_null() {
                eqp_reset(p);
                return;
            }
            fprintf(
                (*p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                ((*pRow).zText).as_mut_ptr().offset(3 as libc::c_int as isize),
            );
            (*p).sGraph.pRow = (*pRow).pNext;
            sqlite3_free(pRow as *mut libc::c_void);
        } else {
            fprintf((*p).out, b"QUERY PLAN\n\0" as *const u8 as *const libc::c_char);
        }
        (*p)
            .sGraph
            .zPrefix[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        eqp_render_level(p, 0 as libc::c_int);
        eqp_reset(p);
    }
}
unsafe extern "C" fn progress_handler(
    mut pClientData: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    (*p).nProgress = ((*p).nProgress).wrapping_add(1);
    if (*p).nProgress >= (*p).mxProgress
        && (*p).mxProgress > 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            (*p).out,
            b"Progress limit reached (%u)\n\0" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
        if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
            (*p).nProgress = 0 as libc::c_int as libc::c_uint;
        }
        if (*p).flgProgress & 0x4 as libc::c_int as libc::c_uint != 0 {
            (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
        }
        return 1 as libc::c_int;
    }
    if (*p).flgProgress & 0x1 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            (*p).out,
            b"Progress %u\n\0" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn print_dashes(mut out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 51] = *::core::mem::transmute::<
        &[u8; 51],
        &[libc::c_char; 51],
    >(b"--------------------------------------------------\0");
    let nDash: libc::c_int = (::core::mem::size_of::<[libc::c_char; 51]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    while N > nDash {
        fputs(zDash.as_ptr(), out);
        N -= nDash;
    }
    fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, N, zDash.as_ptr());
}
unsafe extern "C" fn print_row_separator(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut zSep: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fputs(zSep, (*p).out);
        print_dashes(
            (*p).out,
            *((*p).actualWidth).offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fputs(zSep, (*p).out);
            print_dashes(
                (*p).out,
                *((*p).actualWidth).offset(i as isize) + 2 as libc::c_int,
            );
            i += 1;
        }
        fputs(zSep, (*p).out);
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, (*p).out);
}
unsafe extern "C" fn shell_callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azCol: *mut *mut libc::c_char,
    mut aiType: *mut libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut p: *mut ShellState = pArg as *mut ShellState;
    if azArg.is_null() {
        return 0 as libc::c_int;
    }
    match (*p).cMode {
        0 => {
            let mut w: libc::c_int = 5 as libc::c_int;
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut len: libc::c_int = strlen30(
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if len > w {
                        w = len;
                    }
                    i += 1;
                }
                let fresh36 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh36 > 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        ((*p).rowSeparator).as_mut_ptr(),
                    );
                }
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        b"%*s = %s%s\0" as *const u8 as *const libc::c_char,
                        w,
                        *azCol.offset(i as isize),
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                        ((*p).rowSeparator).as_mut_ptr(),
                    );
                    i += 1;
                }
            }
        }
        9 => {
            static mut aExplainWidth: [libc::c_int; 8] = [
                4 as libc::c_int,
                13 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                13 as libc::c_int,
                2 as libc::c_int,
                13 as libc::c_int,
            ];
            if nArg
                > (::core::mem::size_of::<[libc::c_int; 8]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as libc::c_int
            {
                nArg = (::core::mem::size_of::<[libc::c_int; 8]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as libc::c_int;
            }
            let fresh37 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh37 == 0 as libc::c_int {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut w_0: libc::c_int = aExplainWidth[i as usize];
                    utf8_width_print((*p).out, w_0, *azCol.offset(i as isize));
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                }
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut w_1: libc::c_int = aExplainWidth[i as usize];
                    print_dashes((*p).out, w_1);
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                }
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut w_2: libc::c_int = aExplainWidth[i as usize];
                    if i == nArg - 1 as libc::c_int {
                        w_2 = 0 as libc::c_int;
                    }
                    if !(*azArg.offset(i as isize)).is_null()
                        && strlenChar(*azArg.offset(i as isize)) > w_2
                    {
                        w_2 = strlenChar(*azArg.offset(i as isize));
                    }
                    if i == 1 as libc::c_int && !((*p).aiIndent).is_null()
                        && !((*p).pStmt).is_null()
                    {
                        if (*p).iIndent < (*p).nIndent {
                            fprintf(
                                (*p).out,
                                b"%*.s\0" as *const u8 as *const libc::c_char,
                                *((*p).aiIndent).offset((*p).iIndent as isize),
                                b"\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        (*p).iIndent += 1;
                    }
                    utf8_width_print(
                        (*p).out,
                        w_2,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                }
            }
        }
        3 => {
            printSchemaLine(
                (*p).out,
                *azArg.offset(0 as libc::c_int as isize),
                b";\n\0" as *const u8 as *const libc::c_char,
            );
        }
        11 => {
            let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut j: libc::c_int = 0;
            let mut nParen: libc::c_int = 0 as libc::c_int;
            let mut cEnd: libc::c_char = 0 as libc::c_int as libc::c_char;
            let mut c: libc::c_char = 0;
            let mut nLine: libc::c_int = 0 as libc::c_int;
            if nArg == 1 as libc::c_int {} else {
                __assert_fail(
                    b"nArg==1\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    13256 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 57],
                        &[libc::c_char; 57],
                    >(b"int shell_callback(void *, int, char **, char **, int *)\0"))
                        .as_ptr(),
                );
            }
            if !(*azArg.offset(0 as libc::c_int as isize)).is_null() {
                if sqlite3_strlike(
                    b"CREATE VIEW%\0" as *const u8 as *const libc::c_char,
                    *azArg.offset(0 as libc::c_int as isize),
                    0 as libc::c_int as libc::c_uint,
                ) == 0 as libc::c_int
                    || sqlite3_strlike(
                        b"CREATE TRIG%\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                        0 as libc::c_int as libc::c_uint,
                    ) == 0 as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"%s;\n\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                    );
                } else {
                    z = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                    );
                    shell_check_oom(z as *mut libc::c_void);
                    j = 0 as libc::c_int;
                    i = 0 as libc::c_int;
                    while *(*__ctype_b_loc())
                        .offset(
                            *z.offset(i as isize) as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int
                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                    {
                        i += 1;
                    }
                    let mut current_block_58: u64;
                    loop {
                        c = *z.offset(i as isize);
                        if !(c as libc::c_int != 0 as libc::c_int) {
                            break;
                        }
                        if *(*__ctype_b_loc())
                            .offset(c as libc::c_uchar as libc::c_int as isize)
                            as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                        {
                            if *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                == '\r' as i32
                            {
                                *z
                                    .offset(
                                        (j - 1 as libc::c_int) as isize,
                                    ) = '\n' as i32 as libc::c_char;
                            }
                            if *(*__ctype_b_loc())
                                .offset(
                                    *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                        as libc::c_int as isize,
                                ) as libc::c_int
                                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                != 0
                                || *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                    == '(' as i32
                            {
                                current_block_58 = 168769493162332264;
                            } else {
                                current_block_58 = 7494008139977416618;
                            }
                        } else {
                            if (c as libc::c_int == '(' as i32
                                || c as libc::c_int == ')' as i32) && j > 0 as libc::c_int
                                && *(*__ctype_b_loc())
                                    .offset(
                                        *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int as isize,
                                    ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                            {
                                j -= 1;
                            }
                            current_block_58 = 7494008139977416618;
                        }
                        match current_block_58 {
                            7494008139977416618 => {
                                let fresh38 = j;
                                j = j + 1;
                                *z.offset(fresh38 as isize) = c;
                            }
                            _ => {}
                        }
                        i += 1;
                    }
                    while j > 0 as libc::c_int
                        && *(*__ctype_b_loc())
                            .offset(
                                *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                    as libc::c_int as isize,
                            ) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        j -= 1;
                    }
                    *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                    if strlen30(z) >= 79 as libc::c_int {
                        j = 0 as libc::c_int;
                        i = j;
                        loop {
                            c = *z.offset(i as isize);
                            if !(c as libc::c_int != 0 as libc::c_int) {
                                break;
                            }
                            if c as libc::c_int == cEnd as libc::c_int {
                                cEnd = 0 as libc::c_int as libc::c_char;
                            } else if c as libc::c_int == '"' as i32
                                || c as libc::c_int == '\'' as i32
                                || c as libc::c_int == '`' as i32
                            {
                                cEnd = c;
                            } else if c as libc::c_int == '[' as i32 {
                                cEnd = ']' as i32 as libc::c_char;
                            } else if c as libc::c_int == '-' as i32
                                && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                                    == '-' as i32
                            {
                                cEnd = '\n' as i32 as libc::c_char;
                            } else if c as libc::c_int == '(' as i32 {
                                nParen += 1;
                            } else if c as libc::c_int == ')' as i32 {
                                nParen -= 1;
                                if nLine > 0 as libc::c_int && nParen == 0 as libc::c_int
                                    && j > 0 as libc::c_int
                                {
                                    printSchemaLineN(
                                        (*p).out,
                                        z,
                                        j,
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                    j = 0 as libc::c_int;
                                }
                            }
                            let fresh39 = j;
                            j = j + 1;
                            *z.offset(fresh39 as isize) = c;
                            if nParen == 1 as libc::c_int
                                && cEnd as libc::c_int == 0 as libc::c_int
                                && (c as libc::c_int == '(' as i32
                                    || c as libc::c_int == '\n' as i32
                                    || c as libc::c_int == ',' as i32
                                        && wsToEol(
                                            z.offset(i as isize).offset(1 as libc::c_int as isize),
                                        ) == 0)
                            {
                                if c as libc::c_int == '\n' as i32 {
                                    j -= 1;
                                }
                                printSchemaLineN(
                                    (*p).out,
                                    z,
                                    j,
                                    b"\n  \0" as *const u8 as *const libc::c_char,
                                );
                                j = 0 as libc::c_int;
                                nLine += 1;
                                while *(*__ctype_b_loc())
                                    .offset(
                                        *z.offset((i + 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int as isize,
                                    ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                                {
                                    i += 1;
                                }
                            }
                            i += 1;
                        }
                        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                    }
                    printSchemaLine(
                        (*p).out,
                        z,
                        b";\n\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_free(z as *mut libc::c_void);
                }
            }
        }
        2 => {
            let fresh40 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh40 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        b"%s%s\0" as *const u8 as *const libc::c_char,
                        *azCol.offset(i as isize),
                        if i == nArg - 1 as libc::c_int {
                            ((*p).rowSeparator).as_mut_ptr()
                        } else {
                            ((*p).colSeparator).as_mut_ptr()
                        },
                    );
                    i += 1;
                }
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut z_0: *mut libc::c_char = *azArg.offset(i as isize);
                    if z_0.is_null() {
                        z_0 = ((*p).nullValue).as_mut_ptr();
                    }
                    fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, z_0);
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).rowSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                }
            }
        }
        4 => {
            let fresh41 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh41 == 0 as libc::c_int && (*p).showHeader != 0 {
                fprintf((*p).out, b"<TR>\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf((*p).out, b"<TH>\0" as *const u8 as *const libc::c_char);
                    output_html_string((*p).out, *azCol.offset(i as isize));
                    fprintf((*p).out, b"</TH>\n\0" as *const u8 as *const libc::c_char);
                    i += 1;
                }
                fprintf((*p).out, b"</TR>\n\0" as *const u8 as *const libc::c_char);
            }
            if !azArg.is_null() {
                fprintf((*p).out, b"<TR>\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf((*p).out, b"<TD>\0" as *const u8 as *const libc::c_char);
                    output_html_string(
                        (*p).out,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    fprintf((*p).out, b"</TD>\n\0" as *const u8 as *const libc::c_char);
                    i += 1;
                }
                fprintf((*p).out, b"</TR>\n\0" as *const u8 as *const libc::c_char);
            }
        }
        7 => {
            let fresh42 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh42 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_c_string(
                        (*p).out,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_c_string(
                        (*p).out,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        8 => {
            let fresh43 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh43 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_csv(
                        p,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                        (i < nArg - 1 as libc::c_int) as libc::c_int,
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if nArg > 0 as libc::c_int {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_csv(
                        p,
                        *azArg.offset(i as isize),
                        (i < nArg - 1 as libc::c_int) as libc::c_int,
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        5 => {
            if !azArg.is_null() {
                fprintf(
                    (*p).out,
                    b"INSERT INTO %s\0" as *const u8 as *const libc::c_char,
                    (*p).zDestTable,
                );
                if (*p).showHeader != 0 {
                    fprintf((*p).out, b"(\0" as *const u8 as *const libc::c_char);
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b",\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        if quoteChar(*azCol.offset(i as isize)) != 0 {
                            let mut z_1: *mut libc::c_char = sqlite3_mprintf(
                                b"\"%w\"\0" as *const u8 as *const libc::c_char,
                                *azCol.offset(i as isize),
                            );
                            shell_check_oom(z_1 as *mut libc::c_void);
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_1,
                            );
                            sqlite3_free(z_1 as *mut libc::c_void);
                        } else {
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                *azCol.offset(i as isize),
                            );
                        }
                        i += 1;
                    }
                    fprintf((*p).out, b")\0" as *const u8 as *const libc::c_char);
                }
                (*p).cnt += 1;
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        if i > 0 as libc::c_int {
                            b",\0" as *const u8 as *const libc::c_char
                        } else {
                            b" VALUES(\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            output_quoted_string((*p).out, *azArg.offset(i as isize));
                        } else {
                            output_quoted_escaped_string(
                                (*p).out,
                                *azArg.offset(i as isize),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 1 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_2: [libc::c_char; 50] = [0; 50];
                        let mut r: libc::c_double = sqlite3_column_double((*p).pStmt, i);
                        let mut ur: sqlite3_uint64 = 0;
                        memcpy(
                            &mut ur as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r as *mut libc::c_double as *const libc::c_void,
                            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
                        );
                        if ur
                            == 0x7ff0000000000000 as libc::c_longlong
                                as libc::c_ulonglong
                        {
                            fprintf(
                                (*p).out,
                                b"1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else if ur == 0xfff0000000000000 as libc::c_ulonglong {
                            fprintf(
                                (*p).out,
                                b"-1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            let mut ir: sqlite3_int64 = r as sqlite3_int64;
                            if r == ir as libc::c_double {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%lld.0\0" as *const u8 as *const libc::c_char,
                                    ir,
                                );
                            } else {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%!.20g\0" as *const u8 as *const libc::c_char,
                                    r,
                                );
                            }
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_2.as_mut_ptr(),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let mut pBlob: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let mut nBlob: libc::c_int = sqlite3_column_bytes((*p).pStmt, i);
                        output_hex_blob((*p).out, pBlob, nBlob);
                    } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int)
                        != 0
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    } else {
                        output_quoted_escaped_string(
                            (*p).out,
                            *azArg.offset(i as isize),
                        );
                    }
                    i += 1;
                }
                fprintf((*p).out, b");\n\0" as *const u8 as *const libc::c_char);
            }
        }
        13 => {
            if !azArg.is_null() {
                if (*p).cnt == 0 as libc::c_int {
                    fputs(b"[{\0" as *const u8 as *const libc::c_char, (*p).out);
                } else {
                    fputs(b",\n{\0" as *const u8 as *const libc::c_char, (*p).out);
                }
                (*p).cnt += 1;
                i = 0 as libc::c_int;
                while i < nArg {
                    output_json_string(
                        (*p).out,
                        *azCol.offset(i as isize),
                        -(1 as libc::c_int),
                    );
                    putc(':' as i32, (*p).out);
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fputs(b"null\0" as *const u8 as *const libc::c_char, (*p).out);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_3: [libc::c_char; 50] = [0; 50];
                        let mut r_0: libc::c_double = sqlite3_column_double(
                            (*p).pStmt,
                            i,
                        );
                        let mut ur_0: sqlite3_uint64 = 0;
                        memcpy(
                            &mut ur_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r_0 as *mut libc::c_double as *const libc::c_void,
                            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
                        );
                        if ur_0
                            == 0x7ff0000000000000 as libc::c_longlong
                                as libc::c_ulonglong
                        {
                            fprintf(
                                (*p).out,
                                b"1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else if ur_0 == 0xfff0000000000000 as libc::c_ulonglong {
                            fprintf(
                                (*p).out,
                                b"-1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            sqlite3_snprintf(
                                50 as libc::c_int,
                                z_3.as_mut_ptr(),
                                b"%!.20g\0" as *const u8 as *const libc::c_char,
                                r_0,
                            );
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_3.as_mut_ptr(),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let mut pBlob_0: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let mut nBlob_0: libc::c_int = sqlite3_column_bytes(
                            (*p).pStmt,
                            i,
                        );
                        output_json_string(
                            (*p).out,
                            pBlob_0 as *const libc::c_char,
                            nBlob_0,
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        output_json_string(
                            (*p).out,
                            *azArg.offset(i as isize),
                            -(1 as libc::c_int),
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    }
                    if i < nArg - 1 as libc::c_int {
                        putc(',' as i32, (*p).out);
                    }
                    i += 1;
                }
                putc('}' as i32, (*p).out);
            }
        }
        6 => {
            if !azArg.is_null() {
                if (*p).cnt == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fputs(((*p).colSeparator).as_mut_ptr(), (*p).out);
                        }
                        output_quoted_string((*p).out, *azCol.offset(i as isize));
                        i += 1;
                    }
                    fputs(((*p).rowSeparator).as_mut_ptr(), (*p).out);
                }
                (*p).cnt += 1;
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fputs(((*p).colSeparator).as_mut_ptr(), (*p).out);
                    }
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 1 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_4: [libc::c_char; 50] = [0; 50];
                        let mut r_1: libc::c_double = sqlite3_column_double(
                            (*p).pStmt,
                            i,
                        );
                        sqlite3_snprintf(
                            50 as libc::c_int,
                            z_4.as_mut_ptr(),
                            b"%!.20g\0" as *const u8 as *const libc::c_char,
                            r_1,
                        );
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            z_4.as_mut_ptr(),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let mut pBlob_1: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let mut nBlob_1: libc::c_int = sqlite3_column_bytes(
                            (*p).pStmt,
                            i,
                        );
                        output_hex_blob((*p).out, pBlob_1, nBlob_1);
                    } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int)
                        != 0
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    }
                    i += 1;
                }
                fputs(((*p).rowSeparator).as_mut_ptr(), (*p).out);
            }
        }
        10 => {
            let fresh44 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh44 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        12 => {
            eqp_append(
                p,
                atoi(*azArg.offset(0 as libc::c_int as isize)),
                atoi(*azArg.offset(1 as libc::c_int as isize)),
                *azArg.offset(3 as libc::c_int as isize),
            );
        }
        17 | 18 | _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azCol: *mut *mut libc::c_char,
) -> libc::c_int {
    return shell_callback(pArg, nArg, azArg, azCol, 0 as *mut libc::c_int);
}
unsafe extern "C" fn captureOutputCallback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut az: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellText = pArg as *mut ShellText;
    let mut i: libc::c_int = 0;
    if azArg.is_null() {
        return 0 as libc::c_int;
    }
    if (*p).n != 0 {
        appendText(
            p,
            b"|\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    i = 0 as libc::c_int;
    while i < nArg {
        if i != 0 {
            appendText(
                p,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        if !(*azArg.offset(i as isize)).is_null() {
            appendText(p, *azArg.offset(i as isize), 0 as libc::c_int as libc::c_char);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn createSelftestTable(mut p: *mut ShellState) {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    sqlite3_exec(
        (*p).db,
        b"SAVEPOINT selftest_init;\nCREATE TABLE IF NOT EXISTS selftest(\n  tno INTEGER PRIMARY KEY,\n  op TEXT,\n  cmd TEXT,\n  ans TEXT\n);CREATE TEMP TABLE [_shell$self](op,cmd,ans);\nINSERT INTO [_shell$self](rowid,op,cmd)\n  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n         'memo','Tests generated by --init');\nINSERT INTO [_shell$self]\n  SELECT 'run',\n    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2'',224))',\n    hex(sha3_query('SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2',224));\nINSERT INTO [_shell$self]\n  SELECT 'run',    'SELECT hex(sha3_query(''SELECT * FROM \"' ||        printf('%w',name) || '\" NOT INDEXED'',224))',\n    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n  FROM (\n    SELECT name FROM sqlite_schema\n     WHERE type='table'\n       AND name<>'selftest'\n       AND coalesce(rootpage,0)>0\n  )\n ORDER BY name;\nINSERT INTO [_shell$self]\n  VALUES('run','PRAGMA integrity_check','ok');\nINSERT INTO selftest(tno,op,cmd,ans)  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\nDROP TABLE [_shell$self];\0"
            as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        &mut zErrMsg,
    );
    if !zErrMsg.is_null() {
        fprintf(
            stderr,
            b"SELFTEST initialization failure: %s\n\0" as *const u8
                as *const libc::c_char,
            zErrMsg,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
    }
    sqlite3_exec(
        (*p).db,
        b"RELEASE selftest_init\0" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
unsafe extern "C" fn set_table_name(
    mut p: *mut ShellState,
    mut zName: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut cQuote: libc::c_char = 0;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    if !((*p).zDestTable).is_null() {
        free((*p).zDestTable as *mut libc::c_void);
        (*p).zDestTable = 0 as *mut libc::c_char;
    }
    if zName.is_null() {
        return;
    }
    cQuote = quoteChar(zName);
    n = strlen30(zName);
    if cQuote != 0 {
        n += n + 2 as libc::c_int;
    }
    (*p)
        .zDestTable = malloc((n + 1 as libc::c_int) as libc::c_ulong)
        as *mut libc::c_char;
    z = (*p).zDestTable;
    shell_check_oom(z as *mut libc::c_void);
    n = 0 as libc::c_int;
    if cQuote != 0 {
        let fresh45 = n;
        n = n + 1;
        *z.offset(fresh45 as isize) = cQuote;
    }
    i = 0 as libc::c_int;
    while *zName.offset(i as isize) != 0 {
        let fresh46 = n;
        n = n + 1;
        *z.offset(fresh46 as isize) = *zName.offset(i as isize);
        if *zName.offset(i as isize) as libc::c_int == cQuote as libc::c_int {
            let fresh47 = n;
            n = n + 1;
            *z.offset(fresh47 as isize) = cQuote;
        }
        i += 1;
    }
    if cQuote != 0 {
        let fresh48 = n;
        n = n + 1;
        *z.offset(fresh48 as isize) = cQuote;
    }
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn shell_error_context(
    mut zSql: *const libc::c_char,
    mut db: *mut sqlite3,
) -> *mut libc::c_char {
    let mut iOffset: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut zCode: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    if db.is_null() || zSql.is_null()
        || {
            iOffset = sqlite3_error_offset(db);
            iOffset < 0 as libc::c_int
        }
    {
        return sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
    }
    while iOffset > 50 as libc::c_int {
        iOffset -= 1;
        zSql = zSql.offset(1);
        while *zSql.offset(0 as libc::c_int as isize) as libc::c_int
            & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            zSql = zSql.offset(1);
            iOffset -= 1;
        }
    }
    len = strlen(zSql);
    if len > 78 as libc::c_int as libc::c_ulong {
        len = 78 as libc::c_int as size_t;
        while *zSql.offset(len as isize) as libc::c_int & 0xc0 as libc::c_int
            == 0x80 as libc::c_int
        {
            len = len.wrapping_sub(1);
        }
    }
    zCode = sqlite3_mprintf(b"%.*s\0" as *const u8 as *const libc::c_char, len, zSql);
    i = 0 as libc::c_int;
    while *zCode.offset(i as isize) != 0 {
        if *(*__ctype_b_loc())
            .offset(*zSql.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            *zCode.offset(i as isize) = ' ' as i32 as libc::c_char;
        }
        i += 1;
    }
    if iOffset < 25 as libc::c_int {
        zMsg = sqlite3_mprintf(
            b"\n  %z\n  %*s^--- error here\0" as *const u8 as *const libc::c_char,
            zCode,
            iOffset,
            b"\0" as *const u8 as *const libc::c_char,
        );
    } else {
        zMsg = sqlite3_mprintf(
            b"\n  %z\n  %*serror here ---^\0" as *const u8 as *const libc::c_char,
            zCode,
            iOffset - 14 as libc::c_int,
            b"\0" as *const u8 as *const libc::c_char,
        );
    }
    return zMsg;
}
unsafe extern "C" fn run_table_dump_query(
    mut p: *mut ShellState,
    mut zSelect: *const libc::c_char,
) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    let mut nResult: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSelect,
        -(1 as libc::c_int),
        &mut pSelect,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int || pSelect.is_null() {
        let mut zContext: *mut libc::c_char = shell_error_context(zSelect, (*p).db);
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n%s\0" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
            zContext,
        );
        sqlite3_free(zContext as *mut libc::c_void);
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            (*p).nErr += 1;
        }
        return rc;
    }
    rc = sqlite3_step(pSelect);
    nResult = sqlite3_column_count(pSelect);
    while rc == 100 as libc::c_int {
        z = sqlite3_column_text(pSelect, 0 as libc::c_int) as *const libc::c_char;
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, z);
        i = 1 as libc::c_int;
        while i < nResult {
            fprintf(
                (*p).out,
                b",%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pSelect, i),
            );
            i += 1;
        }
        if z.is_null() {
            z = b"\0" as *const u8 as *const libc::c_char;
        }
        while *z.offset(0 as libc::c_int as isize) as libc::c_int != 0
            && (*z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
                || *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32)
        {
            z = z.offset(1);
        }
        if *z.offset(0 as libc::c_int as isize) != 0 {
            fprintf((*p).out, b"\n;\n\0" as *const u8 as *const libc::c_char);
        } else {
            fprintf((*p).out, b";\n\0" as *const u8 as *const libc::c_char);
        }
        rc = sqlite3_step(pSelect);
    }
    rc = sqlite3_finalize(pSelect);
    if rc != 0 as libc::c_int {
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n\0" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
        );
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            (*p).nErr += 1;
        }
    }
    return rc;
}
unsafe extern "C" fn save_err_msg(
    mut db: *mut sqlite3,
    mut zPhase: *const libc::c_char,
    mut rc: libc::c_int,
    mut zSql: *const libc::c_char,
) -> *mut libc::c_char {
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zContext: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pStr: *mut sqlite3_str = sqlite3_str_new(0 as *mut sqlite3);
    sqlite3_str_appendf(
        pStr,
        b"%s, %s\0" as *const u8 as *const libc::c_char,
        zPhase,
        sqlite3_errmsg(db),
    );
    if rc > 1 as libc::c_int {
        sqlite3_str_appendf(pStr, b" (%d)\0" as *const u8 as *const libc::c_char, rc);
    }
    zContext = shell_error_context(zSql, db);
    if !zContext.is_null() {
        sqlite3_str_appendall(pStr, zContext);
        sqlite3_free(zContext as *mut libc::c_void);
    }
    zErr = sqlite3_str_finish(pStr);
    shell_check_oom(zErr as *mut libc::c_void);
    return zErr;
}
unsafe extern "C" fn displayLinuxIoStats(mut out: *mut FILE) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut z: [libc::c_char; 200] = [0; 200];
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        z.as_mut_ptr(),
        b"/proc/%d/io\0" as *const u8 as *const libc::c_char,
        getpid(),
    );
    in_0 = fopen(z.as_mut_ptr(), b"rb\0" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        return;
    }
    while !(fgets(
        z.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        in_0,
    ))
        .is_null()
    {
        static mut aTrans: [C2RustUnnamed_18; 7] = [
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"rchar: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes received by read():\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"wchar: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes sent to write():\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"syscr: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Read() system calls:\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"syscw: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Write() system calls:\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"read_bytes: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes read from storage:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"write_bytes: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes written to storage:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"cancelled_write_bytes: \0" as *const u8
                        as *const libc::c_char,
                    zDesc: b"Cancelled write bytes:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
        ];
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[C2RustUnnamed_18; 7]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong,
                ) as libc::c_int
        {
            let mut n: libc::c_int = strlen30(aTrans[i as usize].zPattern);
            if strncmp(aTrans[i as usize].zPattern, z.as_mut_ptr(), n as libc::c_ulong)
                == 0 as libc::c_int
            {
                fprintf(
                    out,
                    b"%-36s %s\0" as *const u8 as *const libc::c_char,
                    aTrans[i as usize].zDesc,
                    &mut *z.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
                );
                break;
            } else {
                i += 1;
            }
        }
    }
    fclose(in_0);
}
unsafe extern "C" fn displayStatLine(
    mut p: *mut ShellState,
    mut zLabel: *mut libc::c_char,
    mut zFormat: *mut libc::c_char,
    mut iStatusCtrl: libc::c_int,
    mut bReset: libc::c_int,
) {
    let mut iCur: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut iHiwtr: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut i: libc::c_int = 0;
    let mut nPercent: libc::c_int = 0;
    let mut zLine: [libc::c_char; 200] = [0; 200];
    sqlite3_status64(iStatusCtrl, &mut iCur, &mut iHiwtr, bReset);
    i = 0 as libc::c_int;
    nPercent = 0 as libc::c_int;
    while *zFormat.offset(i as isize) != 0 {
        if *zFormat.offset(i as isize) as libc::c_int == '%' as i32 {
            nPercent += 1;
        }
        i += 1;
    }
    if nPercent > 1 as libc::c_int {
        sqlite3_snprintf(
            ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iCur,
            iHiwtr,
        );
    } else {
        sqlite3_snprintf(
            ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iHiwtr,
        );
    }
    fprintf(
        (*p).out,
        b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
        zLabel,
        zLine.as_mut_ptr(),
    );
}
unsafe extern "C" fn display_stats(
    mut db: *mut sqlite3,
    mut pArg: *mut ShellState,
    mut bReset: libc::c_int,
) -> libc::c_int {
    let mut iCur: libc::c_int = 0;
    let mut iHiwtr: libc::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    if pArg.is_null() || ((*pArg).out).is_null() {
        return 0 as libc::c_int;
    }
    out = (*pArg).out;
    if !((*pArg).pStmt).is_null() && (*pArg).statsOn == 2 as libc::c_int as libc::c_uint
    {
        let mut nCol: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut x: libc::c_int = 0;
        let mut pStmt: *mut sqlite3_stmt = (*pArg).pStmt;
        let mut z: [libc::c_char; 100] = [0; 100];
        nCol = sqlite3_column_count(pStmt);
        fprintf(
            out,
            b"%-36s %d\n\0" as *const u8 as *const libc::c_char,
            b"Number of output columns:\0" as *const u8 as *const libc::c_char,
            nCol,
        );
        i = 0 as libc::c_int;
        while i < nCol {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                z.as_mut_ptr(),
                b"Column %d %nname:\0" as *const u8 as *const libc::c_char,
                i,
                &mut x as *mut libc::c_int,
            );
            fprintf(
                out,
                b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
                z.as_mut_ptr(),
                sqlite3_column_name(pStmt, i),
            );
            sqlite3_snprintf(
                30 as libc::c_int,
                z.as_mut_ptr().offset(x as isize),
                b"declared type:\0" as *const u8 as *const libc::c_char,
            );
            fprintf(
                out,
                b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
                z.as_mut_ptr(),
                sqlite3_column_decltype(pStmt, i),
            );
            i += 1;
        }
    }
    if (*pArg).statsOn == 3 as libc::c_int as libc::c_uint {
        if !((*pArg).pStmt).is_null() {
            iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
            fprintf(
                (*pArg).out,
                b"VM-steps: %d\n\0" as *const u8 as *const libc::c_char,
                iCur,
            );
        }
        return 0 as libc::c_int;
    }
    displayStatLine(
        pArg,
        b"Memory Used:\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%lld (max %lld) bytes\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        0 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Number of Outstanding Allocations:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld (max %lld)\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        9 as libc::c_int,
        bReset,
    );
    if (*pArg).shellFlgs & 0x1 as libc::c_int as libc::c_uint != 0 {
        displayStatLine(
            pArg,
            b"Number of Pcache Pages Used:\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            b"%lld (max %lld) pages\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            1 as libc::c_int,
            bReset,
        );
    }
    displayStatLine(
        pArg,
        b"Number of Pcache Overflow Bytes:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld (max %lld) bytes\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        2 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Largest Allocation:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld bytes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        5 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Largest Pcache Allocation:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld bytes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        7 as libc::c_int,
        bReset,
    );
    if !db.is_null() {
        if (*pArg).shellFlgs & 0x2 as libc::c_int as libc::c_uint != 0 {
            iCur = -(1 as libc::c_int);
            iHiwtr = iCur;
            sqlite3_db_status(db, 0 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside Slots Used:                %d (max %d)\n\0" as *const u8
                    as *const libc::c_char,
                iCur,
                iHiwtr,
            );
            sqlite3_db_status(db, 4 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Successful lookaside attempts:       %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
            sqlite3_db_status(db, 5 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside failures due to size:      %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
            sqlite3_db_status(db, 6 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside failures due to OOM:       %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
        }
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 1 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Pager Heap Usage:                    %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            7 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache hits:                     %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            8 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache misses:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            9 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache writes:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            12 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache spills:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 2 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Schema Heap Usage:                   %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 3 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Statement Heap/Lookaside Usage:      %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
    }
    if !((*pArg).pStmt).is_null() {
        let mut iHit: libc::c_int = 0;
        let mut iMiss: libc::c_int = 0;
        iCur = sqlite3_stmt_status((*pArg).pStmt, 1 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Fullscan Steps:                      %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 2 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Sort Operations:                     %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 3 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Autoindex Inserts:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iHit = sqlite3_stmt_status((*pArg).pStmt, 8 as libc::c_int, bReset);
        iMiss = sqlite3_stmt_status((*pArg).pStmt, 7 as libc::c_int, bReset);
        if iHit != 0 || iMiss != 0 {
            fprintf(
                (*pArg).out,
                b"Bloom filter bypass taken:           %d/%d\n\0" as *const u8
                    as *const libc::c_char,
                iHit,
                iHit + iMiss,
            );
        }
        iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Virtual Machine Steps:               %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 5 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Reprepare operations:                %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 6 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Number of times run:                 %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 99 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Memory used by prepared stmt:        %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
    }
    displayLinuxIoStats((*pArg).out);
    return 0 as libc::c_int;
}
unsafe extern "C" fn display_scanstats(mut db: *mut sqlite3, mut pArg: *mut ShellState) {}
unsafe extern "C" fn str_in_array(
    mut zStr: *const libc::c_char,
    mut azArray: *mut *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(*azArray.offset(i as isize)).is_null() {
        if 0 as libc::c_int == strcmp(zStr, *azArray.offset(i as isize)) {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn explain_data_prepare(
    mut p: *mut ShellState,
    mut pSql: *mut sqlite3_stmt,
) {
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut abYield: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut iOp: libc::c_int = 0;
    let mut azNext: [*const libc::c_char; 7] = [
        b"Next\0" as *const u8 as *const libc::c_char,
        b"Prev\0" as *const u8 as *const libc::c_char,
        b"VPrev\0" as *const u8 as *const libc::c_char,
        b"VNext\0" as *const u8 as *const libc::c_char,
        b"SorterNext\0" as *const u8 as *const libc::c_char,
        b"Return\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azYield: [*const libc::c_char; 6] = [
        b"Yield\0" as *const u8 as *const libc::c_char,
        b"SeekLT\0" as *const u8 as *const libc::c_char,
        b"SeekGT\0" as *const u8 as *const libc::c_char,
        b"RowSetRead\0" as *const u8 as *const libc::c_char,
        b"Rewind\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azGoto: [*const libc::c_char; 2] = [
        b"Goto\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    if sqlite3_column_count(pSql) != 8 as libc::c_int {
        (*p).cMode = (*p).mode;
        return;
    }
    zSql = sqlite3_sql(pSql);
    if zSql.is_null() {
        return;
    }
    z = zSql;
    while *z as libc::c_int == ' ' as i32 || *z as libc::c_int == '\t' as i32
        || *z as libc::c_int == '\n' as i32 || *z as libc::c_int == '\u{c}' as i32
        || *z as libc::c_int == '\r' as i32
    {
        z = z.offset(1);
    }
    if sqlite3_strnicmp(
        z,
        b"explain\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int,
    ) != 0
    {
        (*p).cMode = (*p).mode;
        return;
    }
    iOp = 0 as libc::c_int;
    while 100 as libc::c_int == sqlite3_step(pSql) {
        let mut i: libc::c_int = 0;
        let mut iAddr: libc::c_int = sqlite3_column_int(pSql, 0 as libc::c_int);
        let mut zOp: *const libc::c_char = sqlite3_column_text(pSql, 1 as libc::c_int)
            as *const libc::c_char;
        let mut p2: libc::c_int = sqlite3_column_int(pSql, 3 as libc::c_int);
        let mut p2op: libc::c_int = p2 + (iOp - iAddr);
        if iOp >= nAlloc {
            if iOp == 0 as libc::c_int {
                static mut explainCols: [*const libc::c_char; 8] = [
                    b"addr\0" as *const u8 as *const libc::c_char,
                    b"opcode\0" as *const u8 as *const libc::c_char,
                    b"p1\0" as *const u8 as *const libc::c_char,
                    b"p2\0" as *const u8 as *const libc::c_char,
                    b"p3\0" as *const u8 as *const libc::c_char,
                    b"p4\0" as *const u8 as *const libc::c_char,
                    b"p5\0" as *const u8 as *const libc::c_char,
                    b"comment\0" as *const u8 as *const libc::c_char,
                ];
                let mut jj: libc::c_int = 0;
                jj = 0 as libc::c_int;
                while jj
                    < (::core::mem::size_of::<[*const libc::c_char; 8]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        ) as libc::c_int
                {
                    if strcmp(sqlite3_column_name(pSql, jj), explainCols[jj as usize])
                        != 0 as libc::c_int
                    {
                        (*p).cMode = (*p).mode;
                        sqlite3_reset(pSql);
                        return;
                    }
                    jj += 1;
                }
            }
            nAlloc += 100 as libc::c_int;
            (*p)
                .aiIndent = sqlite3_realloc64(
                (*p).aiIndent as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as sqlite3_uint64,
            ) as *mut libc::c_int;
            shell_check_oom((*p).aiIndent as *mut libc::c_void);
            abYield = sqlite3_realloc64(
                abYield as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as sqlite3_uint64,
            ) as *mut libc::c_int;
            shell_check_oom(abYield as *mut libc::c_void);
        }
        *abYield.offset(iOp as isize) = str_in_array(zOp, azYield.as_mut_ptr());
        *((*p).aiIndent).offset(iOp as isize) = 0 as libc::c_int;
        (*p).nIndent = iOp + 1 as libc::c_int;
        if str_in_array(zOp, azNext.as_mut_ptr()) != 0 && p2op > 0 as libc::c_int {
            i = p2op;
            while i < iOp {
                *((*p).aiIndent).offset(i as isize) += 2 as libc::c_int;
                i += 1;
            }
        }
        if str_in_array(zOp, azGoto.as_mut_ptr()) != 0 && p2op < (*p).nIndent
            && (*abYield.offset(p2op as isize) != 0
                || sqlite3_column_int(pSql, 2 as libc::c_int) != 0)
        {
            i = p2op;
            while i < iOp {
                *((*p).aiIndent).offset(i as isize) += 2 as libc::c_int;
                i += 1;
            }
        }
        iOp += 1;
    }
    (*p).iIndent = 0 as libc::c_int;
    sqlite3_free(abYield as *mut libc::c_void);
    sqlite3_reset(pSql);
}
unsafe extern "C" fn explain_data_delete(mut p: *mut ShellState) {
    sqlite3_free((*p).aiIndent as *mut libc::c_void);
    (*p).aiIndent = 0 as *mut libc::c_int;
    (*p).nIndent = 0 as libc::c_int;
    (*p).iIndent = 0 as libc::c_int;
}
static mut savedSelectTrace: libc::c_uint = 0;
static mut savedWhereTrace: libc::c_uint = 0;
unsafe extern "C" fn disable_debug_trace_modes() {
    let mut zero: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    sqlite3_test_control(
        31 as libc::c_int,
        0 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        2 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
}
unsafe extern "C" fn restore_debug_trace_modes() {
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
}
unsafe extern "C" fn bind_table_init(mut p: *mut ShellState) {
    let mut wrSchema: libc::c_int = 0 as libc::c_int;
    let mut defensiveMode: libc::c_int = 0 as libc::c_int;
    sqlite3_db_config(
        (*p).db,
        1010 as libc::c_int,
        -(1 as libc::c_int),
        &mut defensiveMode as *mut libc::c_int,
    );
    sqlite3_db_config((*p).db, 1010 as libc::c_int, 0 as libc::c_int, 0 as libc::c_int);
    sqlite3_db_config(
        (*p).db,
        1011 as libc::c_int,
        -(1 as libc::c_int),
        &mut wrSchema as *mut libc::c_int,
    );
    sqlite3_db_config((*p).db, 1011 as libc::c_int, 1 as libc::c_int, 0 as libc::c_int);
    sqlite3_exec(
        (*p).db,
        b"CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n  key TEXT PRIMARY KEY,\n  value\n) WITHOUT ROWID;\0"
            as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    sqlite3_db_config((*p).db, 1011 as libc::c_int, wrSchema, 0 as libc::c_int);
    sqlite3_db_config((*p).db, 1010 as libc::c_int, defensiveMode, 0 as libc::c_int);
}
unsafe extern "C" fn bind_prepared_stmt(
    mut pArg: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut nVar: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut pQ: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    nVar = sqlite3_bind_parameter_count(pStmt);
    if nVar == 0 as libc::c_int {
        return;
    }
    if sqlite3_table_column_metadata(
        (*pArg).db,
        b"TEMP\0" as *const u8 as *const libc::c_char,
        b"sqlite_parameters\0" as *const u8 as *const libc::c_char,
        b"key\0" as *const u8 as *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    ) != 0 as libc::c_int
    {
        return;
    }
    rc = sqlite3_prepare_v2(
        (*pArg).db,
        b"SELECT value FROM temp.sqlite_parameters WHERE key=?1\0" as *const u8
            as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pQ,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 || pQ.is_null() {
        return;
    }
    i = 1 as libc::c_int;
    while i <= nVar {
        let mut zNum: [libc::c_char; 30] = [0; 30];
        let mut zVar: *const libc::c_char = sqlite3_bind_parameter_name(pStmt, i);
        if zVar.is_null() {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                zNum.as_mut_ptr(),
                b"?%d\0" as *const u8 as *const libc::c_char,
                i,
            );
            zVar = zNum.as_mut_ptr();
        }
        sqlite3_bind_text(pQ, 1 as libc::c_int, zVar, -(1 as libc::c_int), None);
        if sqlite3_step(pQ) == 100 as libc::c_int {
            sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0 as libc::c_int));
        } else {
            sqlite3_bind_null(pStmt, i);
        }
        sqlite3_reset(pQ);
        i += 1;
    }
    sqlite3_finalize(pQ);
}
unsafe extern "C" fn print_box_line(mut out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 61] = *::core::mem::transmute::<
        &[u8; 61],
        &[libc::c_char; 61],
    >(
        b"\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\0",
    );
    let nDash: libc::c_int = (::core::mem::size_of::<[libc::c_char; 61]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    N *= 3 as libc::c_int;
    while N > nDash {
        fprintf(out, zDash.as_ptr());
        N -= nDash;
    }
    fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, N, zDash.as_ptr());
}
unsafe extern "C" fn print_box_row_separator(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut zSep1: *const libc::c_char,
    mut zSep2: *const libc::c_char,
    mut zSep3: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep1);
        print_box_line(
            (*p).out,
            *((*p).actualWidth).offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep2);
            print_box_line(
                (*p).out,
                *((*p).actualWidth).offset(i as isize) + 2 as libc::c_int,
            );
            i += 1;
        }
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep3);
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, (*p).out);
}
unsafe extern "C" fn translateForDisplayAndDup(
    mut z: *const libc::c_uchar,
    mut pzTail: *mut *const libc::c_uchar,
    mut mxWidth: libc::c_int,
    mut bWordWrap: u8_0,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut zOut: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if z.is_null() {
        *pzTail = 0 as *const libc::c_uchar;
        return 0 as *mut libc::c_char;
    }
    if mxWidth < 0 as libc::c_int {
        mxWidth = -mxWidth;
    }
    if mxWidth == 0 as libc::c_int {
        mxWidth = 1000000 as libc::c_int;
    }
    n = 0 as libc::c_int;
    j = n;
    i = j;
    while n < mxWidth {
        if *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
            n += 1;
            loop {
                i += 1;
                j += 1;
                if !(*z.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int)
                {
                    break;
                }
            }
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\t' as i32) {
                break;
            }
            loop {
                n += 1;
                j += 1;
                if !(n & 7 as libc::c_int != 0 as libc::c_int && n < mxWidth) {
                    break;
                }
            }
            i += 1;
        }
    }
    if n >= mxWidth && bWordWrap as libc::c_int != 0 {
        k = i;
        while k > i / 2 as libc::c_int {
            if *(*__ctype_b_loc())
                .offset(
                    *z.offset((k - 1 as libc::c_int) as isize) as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                break;
            }
            k -= 1;
        }
        if k <= i / 2 as libc::c_int {
            k = i;
            while k > i / 2 as libc::c_int {
                if *(*__ctype_b_loc())
                    .offset(
                        *z.offset((k - 1 as libc::c_int) as isize) as libc::c_int
                            as isize,
                    ) as libc::c_int
                    & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                    != *(*__ctype_b_loc())
                        .offset(*z.offset(k as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                    && *z.offset(k as isize) as libc::c_int & 0xc0 as libc::c_int
                        != 0x80 as libc::c_int
                {
                    break;
                }
                k -= 1;
            }
        }
        if k <= i / 2 as libc::c_int {
            k = i;
        } else {
            i = k;
            while *z.offset(i as isize) as libc::c_int == ' ' as i32 {
                i += 1;
            }
        }
    } else {
        k = i;
    }
    if n >= mxWidth && *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
        *pzTail = &*z.offset(i as isize) as *const libc::c_uchar;
    } else if *z.offset(i as isize) as libc::c_int == '\r' as i32
        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '\n' as i32
    {
        *pzTail = if *z.offset((i + 2 as libc::c_int) as isize) as libc::c_int != 0 {
            &*z.offset((i + 2 as libc::c_int) as isize) as *const libc::c_uchar
        } else {
            0 as *const libc::c_uchar
        };
    } else if *z.offset(i as isize) as libc::c_int == 0 as libc::c_int
        || *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == 0 as libc::c_int
    {
        *pzTail = 0 as *const libc::c_uchar;
    } else {
        *pzTail = &*z.offset((i + 1 as libc::c_int) as isize) as *const libc::c_uchar;
    }
    zOut = malloc((j + 1 as libc::c_int) as libc::c_ulong) as *mut libc::c_uchar;
    shell_check_oom(zOut as *mut libc::c_void);
    n = 0 as libc::c_int;
    j = n;
    i = j;
    while i < k {
        if *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
            n += 1;
            loop {
                let fresh49 = i;
                i = i + 1;
                let fresh50 = j;
                j = j + 1;
                *zOut.offset(fresh50 as isize) = *z.offset(fresh49 as isize);
                if !(*z.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int)
                {
                    break;
                }
            }
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\t' as i32) {
                break;
            }
            loop {
                n += 1;
                let fresh51 = j;
                j = j + 1;
                *zOut.offset(fresh51 as isize) = ' ' as i32 as libc::c_uchar;
                if !(n & 7 as libc::c_int != 0 as libc::c_int && n < mxWidth) {
                    break;
                }
            }
            i += 1;
        }
    }
    *zOut.offset(j as isize) = 0 as libc::c_int as libc::c_uchar;
    return zOut as *mut libc::c_char;
}
unsafe extern "C" fn quoted_column(
    mut pStmt: *mut sqlite3_stmt,
    mut i: libc::c_int,
) -> *mut libc::c_char {
    match sqlite3_column_type(pStmt, i) {
        5 => return sqlite3_mprintf(b"NULL\0" as *const u8 as *const libc::c_char),
        1 | 2 => {
            return sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, i),
            );
        }
        3 => {
            return sqlite3_mprintf(
                b"%Q\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, i),
            );
        }
        4 => {
            let mut j: libc::c_int = 0;
            let mut pStr: *mut sqlite3_str = sqlite3_str_new(0 as *mut sqlite3);
            let mut a: *const libc::c_uchar = sqlite3_column_blob(pStmt, i)
                as *const libc::c_uchar;
            let mut n: libc::c_int = sqlite3_column_bytes(pStmt, i);
            sqlite3_str_append(
                pStr,
                b"x'\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
            j = 0 as libc::c_int;
            while j < n {
                sqlite3_str_appendf(
                    pStr,
                    b"%02x\0" as *const u8 as *const libc::c_char,
                    *a.offset(j as isize) as libc::c_int,
                );
                j += 1;
            }
            sqlite3_str_append(
                pStr,
                b"'\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
            );
            return sqlite3_str_finish(pStr);
        }
        _ => {}
    }
    return 0 as *mut libc::c_char;
}
unsafe extern "C" fn exec_prepared_stmt_columnar(
    mut p: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut current_block: u64;
    let mut nRow: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut nColumn: libc::c_int = 0 as libc::c_int;
    let mut azData: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut nAlloc: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut abRowDiv: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut uz: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut azQuoted: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: sqlite3_int64 = 0;
    let mut nData: sqlite3_int64 = 0;
    let mut j: libc::c_int = 0;
    let mut nTotal: libc::c_int = 0;
    let mut w: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut colSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut rowSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut azNextLine: *mut *const libc::c_uchar = 0 as *mut *const libc::c_uchar;
    let mut bNextLine: libc::c_int = 0 as libc::c_int;
    let mut bMultiLineRowExists: libc::c_int = 0 as libc::c_int;
    let mut bw: libc::c_int = (*p).cmOpts.bWordWrap as libc::c_int;
    let mut zEmpty: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zShowNull: *const libc::c_char = ((*p).nullValue).as_mut_ptr();
    rc = sqlite3_step(pStmt);
    if rc != 100 as libc::c_int {
        return;
    }
    nColumn = sqlite3_column_count(pStmt);
    nAlloc = (nColumn * 4 as libc::c_int) as sqlite3_int64;
    if nAlloc <= 0 as libc::c_int as libc::c_longlong {
        nAlloc = 1 as libc::c_int as sqlite3_int64;
    }
    azData = sqlite3_malloc64(
        (nAlloc as libc::c_ulonglong)
            .wrapping_mul(
                ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                    as libc::c_ulonglong,
            ),
    ) as *mut *mut libc::c_char;
    shell_check_oom(azData as *mut libc::c_void);
    azNextLine = sqlite3_malloc64(
        (nColumn as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut *const libc::c_uchar;
    shell_check_oom(azNextLine as *mut libc::c_void);
    memset(
        azNextLine as *mut libc::c_void,
        0 as libc::c_int,
        (nColumn as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
    );
    if (*p).cmOpts.bQuote != 0 {
        azQuoted = sqlite3_malloc64(
            (nColumn as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as sqlite3_uint64,
        ) as *mut *mut libc::c_char;
        shell_check_oom(azQuoted as *mut libc::c_void);
        memset(
            azQuoted as *mut libc::c_void,
            0 as libc::c_int,
            (nColumn as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
    }
    abRowDiv = sqlite3_malloc64((nAlloc / nColumn as libc::c_longlong) as sqlite3_uint64)
        as *mut libc::c_char;
    shell_check_oom(abRowDiv as *mut libc::c_void);
    if nColumn > (*p).nWidth {
        (*p)
            .colWidth = realloc(
            (*p).colWidth as *mut libc::c_void,
            (((nColumn + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        shell_check_oom((*p).colWidth as *mut libc::c_void);
        i = (*p).nWidth as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            *((*p).colWidth).offset(i as isize) = 0 as libc::c_int;
            i += 1;
        }
        (*p).nWidth = nColumn;
        (*p)
            .actualWidth = &mut *((*p).colWidth).offset(nColumn as isize)
            as *mut libc::c_int;
    }
    memset(
        (*p).actualWidth as *mut libc::c_void,
        0 as libc::c_int,
        (nColumn as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nColumn as libc::c_longlong {
        w = *((*p).colWidth).offset(i as isize);
        if w < 0 as libc::c_int {
            w = -w;
        }
        *((*p).actualWidth).offset(i as isize) = w;
        i += 1;
    }
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nColumn as libc::c_longlong {
        let mut zNotUsed: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut wx: libc::c_int = *((*p).colWidth).offset(i as isize);
        if wx == 0 as libc::c_int {
            wx = (*p).cmOpts.iWrap;
        }
        if wx < 0 as libc::c_int {
            wx = -wx;
        }
        uz = sqlite3_column_name(pStmt, i as libc::c_int) as *const libc::c_uchar;
        let ref mut fresh52 = *azData.offset(i as isize);
        *fresh52 = translateForDisplayAndDup(uz, &mut zNotUsed, wx, bw as u8_0);
        i += 1;
    }
    loop {
        let mut useNextLine: libc::c_int = bNextLine;
        bNextLine = 0 as libc::c_int;
        if (nRow + 2 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong
            >= nAlloc
        {
            nAlloc *= 2 as libc::c_int as libc::c_longlong;
            azData = sqlite3_realloc64(
                azData as *mut libc::c_void,
                (nAlloc as libc::c_ulonglong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                            as libc::c_ulonglong,
                    ),
            ) as *mut *mut libc::c_char;
            shell_check_oom(azData as *mut libc::c_void);
            abRowDiv = sqlite3_realloc64(
                abRowDiv as *mut libc::c_void,
                (nAlloc / nColumn as libc::c_longlong) as sqlite3_uint64,
            ) as *mut libc::c_char;
            shell_check_oom(abRowDiv as *mut libc::c_void);
        }
        *abRowDiv.offset(nRow as isize) = 1 as libc::c_int as libc::c_char;
        nRow += 1;
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            let mut wx_0: libc::c_int = *((*p).colWidth).offset(i as isize);
            if wx_0 == 0 as libc::c_int {
                wx_0 = (*p).cmOpts.iWrap;
            }
            if wx_0 < 0 as libc::c_int {
                wx_0 = -wx_0;
            }
            if useNextLine != 0 {
                uz = *azNextLine.offset(i as isize);
                if uz.is_null() {
                    uz = zEmpty as *mut u8_0;
                }
            } else if (*p).cmOpts.bQuote != 0 {
                sqlite3_free(*azQuoted.offset(i as isize) as *mut libc::c_void);
                let ref mut fresh53 = *azQuoted.offset(i as isize);
                *fresh53 = quoted_column(pStmt, i as libc::c_int);
                uz = *azQuoted.offset(i as isize) as *const libc::c_uchar;
            } else {
                uz = sqlite3_column_text(pStmt, i as libc::c_int);
                if uz.is_null() {
                    uz = zShowNull as *mut u8_0;
                }
            }
            let ref mut fresh54 = *azData
                .offset((nRow * nColumn as libc::c_longlong + i) as isize);
            *fresh54 = translateForDisplayAndDup(
                uz,
                &mut *azNextLine.offset(i as isize),
                wx_0,
                bw as u8_0,
            );
            if !(*azNextLine.offset(i as isize)).is_null() {
                bNextLine = 1 as libc::c_int;
                *abRowDiv
                    .offset(
                        (nRow - 1 as libc::c_int as libc::c_longlong) as isize,
                    ) = 0 as libc::c_int as libc::c_char;
                bMultiLineRowExists = 1 as libc::c_int;
            }
            i += 1;
        }
        if !(bNextLine != 0 || sqlite3_step(pStmt) == 100 as libc::c_int) {
            break;
        }
    }
    nTotal = (nColumn as libc::c_longlong
        * (nRow + 1 as libc::c_int as libc::c_longlong)) as libc::c_int;
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nTotal as libc::c_longlong {
        z = *azData.offset(i as isize);
        if z.is_null() {
            z = zEmpty as *mut libc::c_char;
        }
        n = strlenChar(z);
        j = (i % nColumn as libc::c_longlong) as libc::c_int;
        if n > *((*p).actualWidth).offset(j as isize) {
            *((*p).actualWidth).offset(j as isize) = n;
        }
        i += 1;
    }
    if !(seenInterrupt != 0) {
        if !(nColumn == 0 as libc::c_int) {
            match (*p).cMode {
                1 => {
                    colSep = b"  \0" as *const u8 as *const libc::c_char;
                    rowSep = b"\n\0" as *const u8 as *const libc::c_char;
                    if (*p).showHeader != 0 {
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            w = *((*p).actualWidth).offset(i as isize);
                            if *((*p).colWidth).offset(i as isize) < 0 as libc::c_int {
                                w = -w;
                            }
                            utf8_width_print((*p).out, w, *azData.offset(i as isize));
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \0" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1;
                        }
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            print_dashes(
                                (*p).out,
                                *((*p).actualWidth).offset(i as isize),
                            );
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \0" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1;
                        }
                    }
                }
                15 => {
                    colSep = b" | \0" as *const u8 as *const libc::c_char;
                    rowSep = b" |\n\0" as *const u8 as *const libc::c_char;
                    print_row_separator(
                        p,
                        nColumn,
                        b"+\0" as *const u8 as *const libc::c_char,
                    );
                    fputs(b"| \0" as *const u8 as *const libc::c_char, (*p).out);
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        fputs(
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" |\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" | \0" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1;
                    }
                    print_row_separator(
                        p,
                        nColumn,
                        b"+\0" as *const u8 as *const libc::c_char,
                    );
                }
                14 => {
                    colSep = b" | \0" as *const u8 as *const libc::c_char;
                    rowSep = b" |\n\0" as *const u8 as *const libc::c_char;
                    fputs(b"| \0" as *const u8 as *const libc::c_char, (*p).out);
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        fputs(
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" |\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" | \0" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1;
                    }
                    print_row_separator(
                        p,
                        nColumn,
                        b"|\0" as *const u8 as *const libc::c_char,
                    );
                }
                16 => {
                    colSep = b" \xE2\x94\x82 \0" as *const u8 as *const libc::c_char;
                    rowSep = b" \xE2\x94\x82\n\0" as *const u8 as *const libc::c_char;
                    print_box_row_separator(
                        p,
                        nColumn,
                        b"\xE2\x94\x8C\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xAC\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\x90\0" as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"\xE2\x94\x82 \0" as *const u8 as *const libc::c_char,
                    );
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s%s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" \xE2\x94\x82\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" \xE2\x94\x82 \0" as *const u8 as *const libc::c_char
                            },
                        );
                        i += 1;
                    }
                    print_box_row_separator(
                        p,
                        nColumn,
                        b"\xE2\x94\x9C\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xBC\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xA4\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {}
            }
            i = nColumn as sqlite3_int64;
            j = 0 as libc::c_int;
            loop {
                if !(i < nTotal as libc::c_longlong) {
                    current_block = 8880031775101799352;
                    break;
                }
                if j == 0 as libc::c_int && (*p).cMode != 1 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if (*p).cMode == 16 as libc::c_int {
                            b"\xE2\x94\x82 \0" as *const u8 as *const libc::c_char
                        } else {
                            b"| \0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                z = *azData.offset(i as isize);
                if z.is_null() {
                    z = ((*p).nullValue).as_mut_ptr();
                }
                w = *((*p).actualWidth).offset(j as isize);
                if *((*p).colWidth).offset(j as isize) < 0 as libc::c_int {
                    w = -w;
                }
                utf8_width_print((*p).out, w, z);
                if j == nColumn - 1 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        rowSep,
                    );
                    if bMultiLineRowExists != 0
                        && *abRowDiv
                            .offset(
                                (i / nColumn as libc::c_longlong
                                    - 1 as libc::c_int as libc::c_longlong) as isize,
                            ) as libc::c_int != 0
                        && (i + 1 as libc::c_int as libc::c_longlong)
                            < nTotal as libc::c_longlong
                    {
                        if (*p).cMode == 15 as libc::c_int {
                            print_row_separator(
                                p,
                                nColumn,
                                b"+\0" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 16 as libc::c_int {
                            print_box_row_separator(
                                p,
                                nColumn,
                                b"\xE2\x94\x9C\0" as *const u8 as *const libc::c_char,
                                b"\xE2\x94\xBC\0" as *const u8 as *const libc::c_char,
                                b"\xE2\x94\xA4\0" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"\n\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                    j = -(1 as libc::c_int);
                    if seenInterrupt != 0 {
                        current_block = 9012110987785288076;
                        break;
                    }
                } else {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        colSep,
                    );
                }
                i += 1;
                j += 1;
            }
            match current_block {
                9012110987785288076 => {}
                _ => {
                    if (*p).cMode == 15 as libc::c_int {
                        print_row_separator(
                            p,
                            nColumn,
                            b"+\0" as *const u8 as *const libc::c_char,
                        );
                    } else if (*p).cMode == 16 as libc::c_int {
                        print_box_row_separator(
                            p,
                            nColumn,
                            b"\xE2\x94\x94\0" as *const u8 as *const libc::c_char,
                            b"\xE2\x94\xB4\0" as *const u8 as *const libc::c_char,
                            b"\xE2\x94\x98\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
        }
    }
    if seenInterrupt != 0 {
        fprintf((*p).out, b"Interrupt\n\0" as *const u8 as *const libc::c_char);
    }
    nData = (nRow + 1 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong;
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nData {
        z = *azData.offset(i as isize);
        if z != zEmpty && z != zShowNull {
            free(*azData.offset(i as isize) as *mut libc::c_void);
        }
        i += 1;
    }
    sqlite3_free(azData as *mut libc::c_void);
    sqlite3_free(azNextLine as *mut libc::c_void);
    sqlite3_free(abRowDiv as *mut libc::c_void);
    if !azQuoted.is_null() {
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            sqlite3_free(*azQuoted.offset(i as isize) as *mut libc::c_void);
            i += 1;
        }
        sqlite3_free(azQuoted as *mut libc::c_void);
    }
}
unsafe extern "C" fn exec_prepared_stmt(
    mut pArg: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = 0;
    let mut nRow: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    if (*pArg).cMode == 1 as libc::c_int || (*pArg).cMode == 15 as libc::c_int
        || (*pArg).cMode == 16 as libc::c_int || (*pArg).cMode == 14 as libc::c_int
    {
        exec_prepared_stmt_columnar(pArg, pStmt);
        return;
    }
    rc = sqlite3_step(pStmt);
    if 100 as libc::c_int == rc {
        let mut nCol: libc::c_int = sqlite3_column_count(pStmt);
        let mut pData: *mut libc::c_void = sqlite3_malloc64(
            ((3 as libc::c_int * nCol) as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                )
                .wrapping_add(1 as libc::c_int as libc::c_ulong) as sqlite3_uint64,
        );
        if pData.is_null() {
            shell_out_of_memory();
        } else {
            let mut azCols: *mut *mut libc::c_char = pData as *mut *mut libc::c_char;
            let mut azVals: *mut *mut libc::c_char = &mut *azCols.offset(nCol as isize)
                as *mut *mut libc::c_char;
            let mut aiTypes: *mut libc::c_int = &mut *azVals.offset(nCol as isize)
                as *mut *mut libc::c_char as *mut libc::c_int;
            let mut i: libc::c_int = 0;
            let mut x: libc::c_int = 0;
            if ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                <= ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
            {} else {
                __assert_fail(
                    b"sizeof(int) <= sizeof(char *)\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    14704 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 54],
                        &[libc::c_char; 54],
                    >(b"void exec_prepared_stmt(ShellState *, sqlite3_stmt *)\0"))
                        .as_ptr(),
                );
            }
            i = 0 as libc::c_int;
            while i < nCol {
                let ref mut fresh55 = *azCols.offset(i as isize);
                *fresh55 = sqlite3_column_name(pStmt, i) as *mut libc::c_char;
                i += 1;
            }
            loop {
                nRow = nRow.wrapping_add(1);
                i = 0 as libc::c_int;
                while i < nCol {
                    x = sqlite3_column_type(pStmt, i);
                    *aiTypes.offset(i as isize) = x;
                    if x == 4 as libc::c_int && !pArg.is_null()
                        && ((*pArg).cMode == 5 as libc::c_int
                            || (*pArg).cMode == 6 as libc::c_int)
                    {
                        let ref mut fresh56 = *azVals.offset(i as isize);
                        *fresh56 = b"\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                    } else {
                        let ref mut fresh57 = *azVals.offset(i as isize);
                        *fresh57 = sqlite3_column_text(pStmt, i) as *mut libc::c_char;
                    }
                    if (*azVals.offset(i as isize)).is_null()
                        && *aiTypes.offset(i as isize) != 5 as libc::c_int
                    {
                        rc = 7 as libc::c_int;
                        break;
                    } else {
                        i += 1;
                    }
                }
                if 100 as libc::c_int == rc {
                    if shell_callback(
                        pArg as *mut libc::c_void,
                        nCol,
                        azVals,
                        azCols,
                        aiTypes,
                    ) != 0
                    {
                        rc = 4 as libc::c_int;
                    } else {
                        rc = sqlite3_step(pStmt);
                    }
                }
                if !(100 as libc::c_int == rc) {
                    break;
                }
            }
            sqlite3_free(pData);
            if (*pArg).cMode == 13 as libc::c_int {
                fputs(b"]\n\0" as *const u8 as *const libc::c_char, (*pArg).out);
            } else if (*pArg).cMode == 17 as libc::c_int {
                let mut zBuf: [libc::c_char; 200] = [0; 200];
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                        as libc::c_int,
                    zBuf.as_mut_ptr(),
                    b"%llu row%s\n\0" as *const u8 as *const libc::c_char,
                    nRow,
                    if nRow != 1 as libc::c_int as libc::c_ulonglong {
                        b"s\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                printf(b"%s\0" as *const u8 as *const libc::c_char, zBuf.as_mut_ptr());
            }
        }
    }
}
unsafe extern "C" fn expertHandleSQL(
    mut pState: *mut ShellState,
    mut zSql: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    if !((*pState).expert.pExpert).is_null() {} else {
        __assert_fail(
            b"pState->expert.pExpert\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14767 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 57],
                &[libc::c_char; 57],
            >(b"int expertHandleSQL(ShellState *, const char *, char **)\0"))
                .as_ptr(),
        );
    }
    if pzErr.is_null() || (*pzErr).is_null() {} else {
        __assert_fail(
            b"pzErr==0 || *pzErr==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14768 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 57],
                &[libc::c_char; 57],
            >(b"int expertHandleSQL(ShellState *, const char *, char **)\0"))
                .as_ptr(),
        );
    }
    return sqlite3_expert_sql((*pState).expert.pExpert, zSql, pzErr);
}
unsafe extern "C" fn expertFinish(
    mut pState: *mut ShellState,
    mut bCancel: libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut p: *mut sqlite3expert = (*pState).expert.pExpert;
    if !p.is_null() {} else {
        __assert_fail(
            b"p\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14789 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 45],
                &[libc::c_char; 45],
            >(b"int expertFinish(ShellState *, int, char **)\0"))
                .as_ptr(),
        );
    }
    if bCancel != 0 || pzErr.is_null() || (*pzErr).is_null() {} else {
        __assert_fail(
            b"bCancel || pzErr==0 || *pzErr==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14790 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 45],
                &[libc::c_char; 45],
            >(b"int expertFinish(ShellState *, int, char **)\0"))
                .as_ptr(),
        );
    }
    if bCancel == 0 as libc::c_int {
        let mut out: *mut FILE = (*pState).out;
        let mut bVerbose: libc::c_int = (*pState).expert.bVerbose;
        rc = sqlite3_expert_analyze(p, pzErr);
        if rc == 0 as libc::c_int {
            let mut nQuery: libc::c_int = sqlite3_expert_count(p);
            let mut i: libc::c_int = 0;
            if bVerbose != 0 {
                let mut zCand: *const libc::c_char = sqlite3_expert_report(
                    p,
                    0 as libc::c_int,
                    4 as libc::c_int,
                );
                fprintf(
                    out,
                    b"-- Candidates -----------------------------\n\0" as *const u8
                        as *const libc::c_char,
                );
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zCand);
            }
            i = 0 as libc::c_int;
            while i < nQuery {
                let mut zSql: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    1 as libc::c_int,
                );
                let mut zIdx: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    2 as libc::c_int,
                );
                let mut zEQP: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    3 as libc::c_int,
                );
                if zIdx.is_null() {
                    zIdx = b"(no new indexes)\n\0" as *const u8 as *const libc::c_char;
                }
                if bVerbose != 0 {
                    fprintf(
                        out,
                        b"-- Query %d --------------------------------\n\0" as *const u8
                            as *const libc::c_char,
                        i + 1 as libc::c_int,
                    );
                    fprintf(out, b"%s\n\n\0" as *const u8 as *const libc::c_char, zSql);
                }
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zIdx);
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zEQP);
                i += 1;
            }
        }
    }
    sqlite3_expert_destroy(p);
    (*pState).expert.pExpert = 0 as *mut sqlite3expert;
    return rc;
}
unsafe extern "C" fn expertDotCommand(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut iSample: libc::c_int = 0 as libc::c_int;
    if ((*pState).expert.pExpert).is_null() {} else {
        __assert_fail(
            b"pState->expert.pExpert==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14837 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"int expertDotCommand(ShellState *, char **, int)\0"))
                .as_ptr(),
        );
    }
    memset(
        &mut (*pState).expert as *mut ExpertInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ExpertInfo>() as libc::c_ulong,
    );
    i = 1 as libc::c_int;
    while rc == 0 as libc::c_int && i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1);
        }
        n = strlen30(z);
        if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == strncmp(
                    z,
                    b"-verbose\0" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                )
        {
            (*pState).expert.bVerbose = 1 as libc::c_int;
        } else if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == strncmp(
                    z,
                    b"-sample\0" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                )
        {
            if i == nArg - 1 as libc::c_int {
                fprintf(
                    stderr,
                    b"option requires an argument: %s\n\0" as *const u8
                        as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int;
            } else {
                i += 1;
                iSample = integerValue(*azArg.offset(i as isize)) as libc::c_int;
                if iSample < 0 as libc::c_int || iSample > 100 as libc::c_int {
                    fprintf(
                        stderr,
                        b"value out of range: %s\n\0" as *const u8
                            as *const libc::c_char,
                        *azArg.offset(i as isize),
                    );
                    rc = 1 as libc::c_int;
                }
            }
        } else {
            fprintf(
                stderr,
                b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                z,
            );
            rc = 1 as libc::c_int;
        }
        i += 1;
    }
    if rc == 0 as libc::c_int {
        (*pState).expert.pExpert = sqlite3_expert_new((*pState).db, &mut zErr);
        if ((*pState).expert.pExpert).is_null() {
            fprintf(
                stderr,
                b"sqlite3_expert_new: %s\n\0" as *const u8 as *const libc::c_char,
                if !zErr.is_null() {
                    zErr as *const libc::c_char
                } else {
                    b"out of memory\0" as *const u8 as *const libc::c_char
                },
            );
            rc = 1 as libc::c_int;
        } else {
            sqlite3_expert_config((*pState).expert.pExpert, 1 as libc::c_int, iSample);
        }
    }
    sqlite3_free(zErr as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn shell_exec(
    mut pArg: *mut ShellState,
    mut zSql: *const libc::c_char,
    mut pzErrMsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut rc2: libc::c_int = 0;
    let mut zLeftover: *const libc::c_char = 0 as *const libc::c_char;
    let mut db: *mut sqlite3 = (*pArg).db;
    if !pzErrMsg.is_null() {
        *pzErrMsg = 0 as *mut libc::c_char;
    }
    if !((*pArg).expert.pExpert).is_null() {
        rc = expertHandleSQL(pArg, zSql, pzErrMsg);
        return expertFinish(pArg, (rc != 0 as libc::c_int) as libc::c_int, pzErrMsg);
    }
    while *zSql.offset(0 as libc::c_int as isize) as libc::c_int != 0
        && 0 as libc::c_int == rc
    {
        static mut zStmtSql: *const libc::c_char = 0 as *const libc::c_char;
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            &mut zLeftover,
        );
        if 0 as libc::c_int != rc {
            if !pzErrMsg.is_null() {
                *pzErrMsg = save_err_msg(
                    db,
                    b"in prepare\0" as *const u8 as *const libc::c_char,
                    rc,
                    zSql,
                );
            }
        } else if pStmt.is_null() {
            zSql = zLeftover;
            while *(*__ctype_b_loc())
                .offset(
                    *zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zSql = zSql.offset(1);
            }
        } else {
            zStmtSql = sqlite3_sql(pStmt);
            if zStmtSql.is_null() {
                zStmtSql = b"\0" as *const u8 as *const libc::c_char;
            }
            while *(*__ctype_b_loc())
                .offset(
                    *zStmtSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zStmtSql = zStmtSql.offset(1);
            }
            if !pArg.is_null() {
                (*pArg).pStmt = pStmt;
                (*pArg).cnt = 0 as libc::c_int;
            }
            if !pArg.is_null() && (*pArg).autoEQP as libc::c_int != 0
                && sqlite3_stmt_isexplain(pStmt) == 0 as libc::c_int
            {
                let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                let mut zEQP: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut triggerEQP: libc::c_int = 0 as libc::c_int;
                disable_debug_trace_modes();
                sqlite3_db_config(
                    db,
                    1008 as libc::c_int,
                    -(1 as libc::c_int),
                    &mut triggerEQP as *mut libc::c_int,
                );
                if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int {
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        1 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                zEQP = sqlite3_mprintf(
                    b"EXPLAIN QUERY PLAN %s\0" as *const u8 as *const libc::c_char,
                    zStmtSql,
                );
                shell_check_oom(zEQP as *mut libc::c_void);
                rc = sqlite3_prepare_v2(
                    db,
                    zEQP,
                    -(1 as libc::c_int),
                    &mut pExplain,
                    0 as *mut *const libc::c_char,
                );
                if rc == 0 as libc::c_int {
                    while sqlite3_step(pExplain) == 100 as libc::c_int {
                        let mut zEQPLine: *const libc::c_char = sqlite3_column_text(
                            pExplain,
                            3 as libc::c_int,
                        ) as *const libc::c_char;
                        let mut iEqpId: libc::c_int = sqlite3_column_int(
                            pExplain,
                            0 as libc::c_int,
                        );
                        let mut iParentId: libc::c_int = sqlite3_column_int(
                            pExplain,
                            1 as libc::c_int,
                        );
                        if zEQPLine.is_null() {
                            zEQPLine = b"\0" as *const u8 as *const libc::c_char;
                        }
                        if *zEQPLine.offset(0 as libc::c_int as isize) as libc::c_int
                            == '-' as i32
                        {
                            eqp_render(pArg);
                        }
                        eqp_append(pArg, iEqpId, iParentId, zEQPLine);
                    }
                    eqp_render(pArg);
                }
                sqlite3_finalize(pExplain);
                sqlite3_free(zEQP as *mut libc::c_void);
                if (*pArg).autoEQP as libc::c_int >= 3 as libc::c_int {
                    zEQP = sqlite3_mprintf(
                        b"EXPLAIN %s\0" as *const u8 as *const libc::c_char,
                        zStmtSql,
                    );
                    shell_check_oom(zEQP as *mut libc::c_void);
                    rc = sqlite3_prepare_v2(
                        db,
                        zEQP,
                        -(1 as libc::c_int),
                        &mut pExplain,
                        0 as *mut *const libc::c_char,
                    );
                    if rc == 0 as libc::c_int {
                        (*pArg).cMode = 9 as libc::c_int;
                        explain_data_prepare(pArg, pExplain);
                        exec_prepared_stmt(pArg, pExplain);
                        explain_data_delete(pArg);
                    }
                    sqlite3_finalize(pExplain);
                    sqlite3_free(zEQP as *mut libc::c_void);
                }
                if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int
                    && triggerEQP == 0 as libc::c_int
                {
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                    sqlite3_finalize(pStmt);
                    sqlite3_prepare_v2(
                        db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    if !pArg.is_null() {
                        (*pArg).pStmt = pStmt;
                    }
                }
                restore_debug_trace_modes();
            }
            if !pArg.is_null() {
                (*pArg).cMode = (*pArg).mode;
                if (*pArg).autoExplain != 0 {
                    if sqlite3_stmt_isexplain(pStmt) == 1 as libc::c_int {
                        (*pArg).cMode = 9 as libc::c_int;
                    }
                    if sqlite3_stmt_isexplain(pStmt) == 2 as libc::c_int {
                        (*pArg).cMode = 12 as libc::c_int;
                    }
                }
                if (*pArg).cMode == 9 as libc::c_int {
                    explain_data_prepare(pArg, pStmt);
                }
            }
            bind_prepared_stmt(pArg, pStmt);
            exec_prepared_stmt(pArg, pStmt);
            explain_data_delete(pArg);
            eqp_render(pArg);
            if !pArg.is_null() && (*pArg).statsOn != 0 {
                display_stats(db, pArg, 0 as libc::c_int);
            }
            if !pArg.is_null() && (*pArg).scanstatsOn as libc::c_int != 0 {
                display_scanstats(db, pArg);
            }
            rc2 = sqlite3_finalize(pStmt);
            if rc != 7 as libc::c_int {
                rc = rc2;
            }
            if rc == 0 as libc::c_int {
                zSql = zLeftover;
                while *(*__ctype_b_loc())
                    .offset(
                        *zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    zSql = zSql.offset(1);
                }
            } else if !pzErrMsg.is_null() {
                *pzErrMsg = save_err_msg(
                    db,
                    b"stepping\0" as *const u8 as *const libc::c_char,
                    rc,
                    0 as *const libc::c_char,
                );
            }
            if !pArg.is_null() {
                (*pArg).pStmt = 0 as *mut sqlite3_stmt;
            }
        }
    }
    return rc;
}
unsafe extern "C" fn freeColumnList(mut azCol: *mut *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while !(*azCol.offset(i as isize)).is_null() {
        sqlite3_free(*azCol.offset(i as isize) as *mut libc::c_void);
        i += 1;
    }
    sqlite3_free(azCol as *mut libc::c_void);
}
unsafe extern "C" fn tableColumnList(
    mut p: *mut ShellState,
    mut zTab: *const libc::c_char,
) -> *mut *mut libc::c_char {
    let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut nPK: libc::c_int = 0 as libc::c_int;
    let mut isIPK: libc::c_int = 0 as libc::c_int;
    let mut preserveRowid: libc::c_int = ((*p).shellFlgs
        & 0x8 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint)
        as libc::c_int;
    let mut rc: libc::c_int = 0;
    zSql = sqlite3_mprintf(
        b"PRAGMA table_info=%Q\0" as *const u8 as *const libc::c_char,
        zTab,
    );
    shell_check_oom(zSql as *mut libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    if rc != 0 {
        return 0 as *mut *mut libc::c_char;
    }
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        if nCol >= nAlloc - 2 as libc::c_int {
            nAlloc = nAlloc * 2 as libc::c_int + nCol + 10 as libc::c_int;
            azCol = sqlite3_realloc(
                azCol as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int,
            ) as *mut *mut libc::c_char;
            shell_check_oom(azCol as *mut libc::c_void);
        }
        nCol += 1;
        let ref mut fresh58 = *azCol.offset(nCol as isize);
        *fresh58 = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            sqlite3_column_text(pStmt, 1 as libc::c_int),
        );
        shell_check_oom(*azCol.offset(nCol as isize) as *mut libc::c_void);
        if sqlite3_column_int(pStmt, 5 as libc::c_int) != 0 {
            nPK += 1;
            if nPK == 1 as libc::c_int
                && sqlite3_stricmp(
                    sqlite3_column_text(pStmt, 2 as libc::c_int) as *const libc::c_char,
                    b"INTEGER\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                isIPK = 1 as libc::c_int;
            } else {
                isIPK = 0 as libc::c_int;
            }
        }
    }
    sqlite3_finalize(pStmt);
    if azCol.is_null() {
        return 0 as *mut *mut libc::c_char;
    }
    let ref mut fresh59 = *azCol.offset(0 as libc::c_int as isize);
    *fresh59 = 0 as *mut libc::c_char;
    let ref mut fresh60 = *azCol.offset((nCol + 1 as libc::c_int) as isize);
    *fresh60 = 0 as *mut libc::c_char;
    if preserveRowid != 0 && isIPK != 0 {
        zSql = sqlite3_mprintf(
            b"SELECT 1 FROM pragma_index_list(%Q) WHERE origin='pk'\0" as *const u8
                as *const libc::c_char,
            zTab,
        );
        shell_check_oom(zSql as *mut libc::c_void);
        rc = sqlite3_prepare_v2(
            (*p).db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
        if rc != 0 {
            freeColumnList(azCol);
            return 0 as *mut *mut libc::c_char;
        }
        rc = sqlite3_step(pStmt);
        sqlite3_finalize(pStmt);
        preserveRowid = (rc == 100 as libc::c_int) as libc::c_int;
    }
    if preserveRowid != 0 {
        static mut azRowid: [*mut libc::c_char; 3] = [
            b"rowid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"_rowid_\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"oid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        j = 0 as libc::c_int;
        while j < 3 as libc::c_int {
            i = 1 as libc::c_int;
            while i <= nCol {
                if sqlite3_stricmp(azRowid[j as usize], *azCol.offset(i as isize))
                    == 0 as libc::c_int
                {
                    break;
                }
                i += 1;
            }
            if i > nCol {
                rc = sqlite3_table_column_metadata(
                    (*p).db,
                    0 as *const libc::c_char,
                    zTab,
                    azRowid[j as usize],
                    0 as *mut *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                );
                if rc == 0 as libc::c_int {
                    let ref mut fresh61 = *azCol.offset(0 as libc::c_int as isize);
                    *fresh61 = azRowid[j as usize];
                }
                break;
            } else {
                j += 1;
            }
        }
    }
    return azCol;
}
unsafe extern "C" fn toggleSelectOrder(mut db: *mut sqlite3) {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut iSetting: libc::c_int = 0 as libc::c_int;
    let mut zStmt: [libc::c_char; 100] = [0; 100];
    sqlite3_prepare_v2(
        db,
        b"PRAGMA reverse_unordered_selects\0" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        iSetting = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    sqlite3_finalize(pStmt);
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
        zStmt.as_mut_ptr(),
        b"PRAGMA reverse_unordered_selects(%d)\0" as *const u8 as *const libc::c_char,
        (iSetting == 0) as libc::c_int,
    );
    sqlite3_exec(
        db,
        zStmt.as_mut_ptr(),
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
unsafe extern "C" fn dump_callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azNotUsed: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zTable: *const libc::c_char = 0 as *const libc::c_char;
    let mut zType: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *mut ShellState = pArg as *mut ShellState;
    let mut dataOnly: libc::c_int = 0;
    let mut noSys: libc::c_int = 0;
    if nArg != 3 as libc::c_int || azArg.is_null() {
        return 0 as libc::c_int;
    }
    zTable = *azArg.offset(0 as libc::c_int as isize);
    zType = *azArg.offset(1 as libc::c_int as isize);
    zSql = *azArg.offset(2 as libc::c_int as isize);
    dataOnly = ((*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    noSys = ((*p).shellFlgs & 0x200 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    if strcmp(zTable, b"sqlite_sequence\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int && noSys == 0
    {
        if dataOnly == 0 {
            fprintf(
                (*p).out,
                b"DELETE FROM sqlite_sequence;\n\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if sqlite3_strglob(
        b"sqlite_stat?\0" as *const u8 as *const libc::c_char,
        zTable,
    ) == 0 as libc::c_int && noSys == 0
    {
        if dataOnly == 0 {
            fprintf(
                (*p).out,
                b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if strncmp(
        zTable,
        b"sqlite_\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as libc::c_ulong,
    ) == 0 as libc::c_int
    {
        return 0 as libc::c_int
    } else {
        if !(dataOnly != 0) {
            if strncmp(
                zSql,
                b"CREATE VIRTUAL TABLE\0" as *const u8 as *const libc::c_char,
                20 as libc::c_int as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                let mut zIns: *mut libc::c_char = 0 as *mut libc::c_char;
                if (*p).writableSchema == 0 {
                    fprintf(
                        (*p).out,
                        b"PRAGMA writable_schema=ON;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*p).writableSchema = 1 as libc::c_int;
                }
                zIns = sqlite3_mprintf(
                    b"INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)VALUES('table','%q','%q',0,'%q');\0"
                        as *const u8 as *const libc::c_char,
                    zTable,
                    zTable,
                    zSql,
                );
                shell_check_oom(zIns as *mut libc::c_void);
                fprintf((*p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zIns);
                sqlite3_free(zIns as *mut libc::c_void);
                return 0 as libc::c_int;
            } else {
                printSchemaLine(
                    (*p).out,
                    zSql,
                    b";\n\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    if strcmp(zType, b"table\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
    {
        let mut sSelect: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut sTable: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut i: libc::c_int = 0;
        let mut savedDestTable: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut savedMode: libc::c_int = 0;
        azCol = tableColumnList(p, zTable);
        if azCol.is_null() {
            (*p).nErr += 1;
            return 0 as libc::c_int;
        }
        initText(&mut sTable);
        appendText(&mut sTable, zTable, quoteChar(zTable));
        if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
            appendText(
                &mut sTable,
                b"(\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
            appendText(
                &mut sTable,
                *azCol.offset(0 as libc::c_int as isize),
                0 as libc::c_int as libc::c_char,
            );
            i = 1 as libc::c_int;
            while !(*azCol.offset(i as isize)).is_null() {
                appendText(
                    &mut sTable,
                    b",\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                appendText(
                    &mut sTable,
                    *azCol.offset(i as isize),
                    quoteChar(*azCol.offset(i as isize)),
                );
                i += 1;
            }
            appendText(
                &mut sTable,
                b")\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        initText(&mut sSelect);
        appendText(
            &mut sSelect,
            b"SELECT \0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
            appendText(
                &mut sSelect,
                *azCol.offset(0 as libc::c_int as isize),
                0 as libc::c_int as libc::c_char,
            );
            appendText(
                &mut sSelect,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        i = 1 as libc::c_int;
        while !(*azCol.offset(i as isize)).is_null() {
            appendText(
                &mut sSelect,
                *azCol.offset(i as isize),
                quoteChar(*azCol.offset(i as isize)),
            );
            if !(*azCol.offset((i + 1 as libc::c_int) as isize)).is_null() {
                appendText(
                    &mut sSelect,
                    b",\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
            }
            i += 1;
        }
        freeColumnList(azCol);
        appendText(
            &mut sSelect,
            b" FROM \0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        appendText(&mut sSelect, zTable, quoteChar(zTable));
        savedDestTable = (*p).zDestTable;
        savedMode = (*p).mode;
        (*p).zDestTable = sTable.z;
        (*p).cMode = 5 as libc::c_int;
        (*p).mode = (*p).cMode;
        rc = shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
        if rc & 0xff as libc::c_int == 11 as libc::c_int {
            fprintf(
                (*p).out,
                b"/****** CORRUPTION ERROR *******/\n\0" as *const u8
                    as *const libc::c_char,
            );
            toggleSelectOrder((*p).db);
            shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
            toggleSelectOrder((*p).db);
        }
        (*p).zDestTable = savedDestTable;
        (*p).mode = savedMode;
        freeText(&mut sTable);
        freeText(&mut sSelect);
        if rc != 0 {
            (*p).nErr += 1;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn run_schema_dump_query(
    mut p: *mut ShellState,
    mut zQuery: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).db,
        zQuery,
        Some(
            dump_callback
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *mut *mut libc::c_char,
                    *mut *mut libc::c_char,
                ) -> libc::c_int,
        ),
        p as *mut libc::c_void,
        &mut zErr,
    );
    if rc == 11 as libc::c_int {
        let mut zQ2: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut len: libc::c_int = strlen30(zQuery);
        fprintf(
            (*p).out,
            b"/****** CORRUPTION ERROR *******/\n\0" as *const u8 as *const libc::c_char,
        );
        if !zErr.is_null() {
            fprintf(
                (*p).out,
                b"/****** %s ******/\n\0" as *const u8 as *const libc::c_char,
                zErr,
            );
            sqlite3_free(zErr as *mut libc::c_void);
            zErr = 0 as *mut libc::c_char;
        }
        zQ2 = malloc((len + 100 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
        if zQ2.is_null() {
            return rc;
        }
        sqlite3_snprintf(
            len + 100 as libc::c_int,
            zQ2,
            b"%s ORDER BY rowid DESC\0" as *const u8 as *const libc::c_char,
            zQuery,
        );
        rc = sqlite3_exec(
            (*p).db,
            zQ2,
            Some(
                dump_callback
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *mut *mut libc::c_char,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            p as *mut libc::c_void,
            &mut zErr,
        );
        if rc != 0 {
            fprintf(
                (*p).out,
                b"/****** ERROR: %s ******/\n\0" as *const u8 as *const libc::c_char,
                zErr,
            );
        } else {
            rc = 11 as libc::c_int;
        }
        sqlite3_free(zErr as *mut libc::c_void);
        free(zQ2 as *mut libc::c_void);
    }
    return rc;
}
static mut azHelp: [*const libc::c_char; 175] = [
    b".auth ON|OFF             Show authorizer callbacks\0" as *const u8
        as *const libc::c_char,
    b".backup ?DB? FILE        Backup DB (default \"main\") to FILE\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"       --append            Use the appendvfs\0" as *const u8
        as *const libc::c_char,
    b"       --async             Write to FILE without journal and fsync()\0"
        as *const u8 as *const libc::c_char,
    b".bail on|off             Stop after hitting an error.  Default OFF\0" as *const u8
        as *const libc::c_char,
    b".binary on|off           Turn binary output on or off.  Default OFF\0" as *const u8
        as *const libc::c_char,
    b".cd DIRECTORY            Change the working directory to DIRECTORY\0" as *const u8
        as *const libc::c_char,
    b".changes on|off          Show number of rows changed by SQL\0" as *const u8
        as *const libc::c_char,
    b".check GLOB              Fail if output since .testcase does not match\0"
        as *const u8 as *const libc::c_char,
    b".clone NEWDB             Clone data into NEWDB from the existing database\0"
        as *const u8 as *const libc::c_char,
    b".connection [close] [#]  Open or close an auxiliary database connection\0"
        as *const u8 as *const libc::c_char,
    b".databases               List names and files of attached databases\0" as *const u8
        as *const libc::c_char,
    b".dbconfig ?op? ?val?     List or change sqlite3_db_config() options\0" as *const u8
        as *const libc::c_char,
    b".dump ?OBJECTS?          Render database content as SQL\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --data-only            Output only INSERT statements\0" as *const u8
        as *const libc::c_char,
    b"     --newlines             Allow unescaped newline characters in output\0"
        as *const u8 as *const libc::c_char,
    b"     --nosys                Omit system tables (ex: \"sqlite_stat1\")\0"
        as *const u8 as *const libc::c_char,
    b"     --preserve-rowids      Include ROWID values in the output\0" as *const u8
        as *const libc::c_char,
    b"   OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump\0"
        as *const u8 as *const libc::c_char,
    b"   Additional LIKE patterns can be given in subsequent arguments\0" as *const u8
        as *const libc::c_char,
    b".echo on|off             Turn command echo on or off\0" as *const u8
        as *const libc::c_char,
    b".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN\0"
        as *const u8 as *const libc::c_char,
    b"   Other Modes:\0" as *const u8 as *const libc::c_char,
    b"      trigger               Like \"full\" but also show trigger bytecode\0"
        as *const u8 as *const libc::c_char,
    b".excel                   Display the output of next command in spreadsheet\0"
        as *const u8 as *const libc::c_char,
    b"   --bom                   Put a UTF8 byte-order mark on intermediate file\0"
        as *const u8 as *const libc::c_char,
    b".exit ?CODE?             Exit this program with return-code CODE\0" as *const u8
        as *const libc::c_char,
    b".expert                  EXPERIMENTAL. Suggest indexes for queries\0" as *const u8
        as *const libc::c_char,
    b".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto\0"
        as *const u8 as *const libc::c_char,
    b".filectrl CMD ...        Run various sqlite3_file_control() operations\0"
        as *const u8 as *const libc::c_char,
    b"   --schema SCHEMA         Use SCHEMA instead of \"main\"\0" as *const u8
        as *const libc::c_char,
    b"   --help                  Show CMD details\0" as *const u8 as *const libc::c_char,
    b".fullschema ?--indent?   Show schema and the content of sqlite_stat tables\0"
        as *const u8 as *const libc::c_char,
    b".headers on|off          Turn display of headers on or off\0" as *const u8
        as *const libc::c_char,
    b".help ?-all? ?PATTERN?   Show help text for PATTERN\0" as *const u8
        as *const libc::c_char,
    b".import FILE TABLE       Import data from FILE into TABLE\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --ascii               Use \\037 and \\036 as column and row separators\0"
        as *const u8 as *const libc::c_char,
    b"     --csv                 Use , and \\n as column and row separators\0"
        as *const u8 as *const libc::c_char,
    b"     --skip N              Skip the first N rows of input\0" as *const u8
        as *const libc::c_char,
    b"     --schema S            Target table to be S.TABLE\0" as *const u8
        as *const libc::c_char,
    b"     -v                    \"Verbose\" - increase auxiliary output\0" as *const u8
        as *const libc::c_char,
    b"   Notes:\0" as *const u8 as *const libc::c_char,
    b"     *  If TABLE does not exist, it is created.  The first row of input\0"
        as *const u8 as *const libc::c_char,
    b"        determines the column names.\0" as *const u8 as *const libc::c_char,
    b"     *  If neither --csv or --ascii are used, the input mode is derived\0"
        as *const u8 as *const libc::c_char,
    b"        from the \".mode\" output mode\0" as *const u8 as *const libc::c_char,
    b"     *  If FILE begins with \"|\" then it is a command that generates the\0"
        as *const u8 as *const libc::c_char,
    b"        input text.\0" as *const u8 as *const libc::c_char,
    b".imposter INDEX TABLE    Create imposter table TABLE on index INDEX\0" as *const u8
        as *const libc::c_char,
    b".indexes ?TABLE?         Show names of indexes\0" as *const u8
        as *const libc::c_char,
    b"                           If TABLE is specified, only show indexes for\0"
        as *const u8 as *const libc::c_char,
    b"                           tables matching TABLE using the LIKE operator.\0"
        as *const u8 as *const libc::c_char,
    b".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT\0"
        as *const u8 as *const libc::c_char,
    b".lint OPTIONS            Report potential schema issues.\0" as *const u8
        as *const libc::c_char,
    b"     Options:\0" as *const u8 as *const libc::c_char,
    b"        fkey-indexes     Find missing foreign key indexes\0" as *const u8
        as *const libc::c_char,
    b".load FILE ?ENTRY?       Load an extension library\0" as *const u8
        as *const libc::c_char,
    b".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout\0"
        as *const u8 as *const libc::c_char,
    b".mode MODE ?OPTIONS?     Set output mode\0" as *const u8 as *const libc::c_char,
    b"   MODE is one of:\0" as *const u8 as *const libc::c_char,
    b"     ascii       Columns/rows delimited by 0x1F and 0x1E\0" as *const u8
        as *const libc::c_char,
    b"     box         Tables using unicode box-drawing characters\0" as *const u8
        as *const libc::c_char,
    b"     csv         Comma-separated values\0" as *const u8 as *const libc::c_char,
    b"     column      Output in columns.  (See .width)\0" as *const u8
        as *const libc::c_char,
    b"     html        HTML <table> code\0" as *const u8 as *const libc::c_char,
    b"     insert      SQL insert statements for TABLE\0" as *const u8
        as *const libc::c_char,
    b"     json        Results in a JSON array\0" as *const u8 as *const libc::c_char,
    b"     line        One value per line\0" as *const u8 as *const libc::c_char,
    b"     list        Values delimited by \"|\"\0" as *const u8 as *const libc::c_char,
    b"     markdown    Markdown table format\0" as *const u8 as *const libc::c_char,
    b"     qbox        Shorthand for \"box --width 60 --quote\"\0" as *const u8
        as *const libc::c_char,
    b"     quote       Escape answers as for SQL\0" as *const u8 as *const libc::c_char,
    b"     table       ASCII-art table\0" as *const u8 as *const libc::c_char,
    b"     tabs        Tab-separated values\0" as *const u8 as *const libc::c_char,
    b"     tcl         TCL list elements\0" as *const u8 as *const libc::c_char,
    b"   OPTIONS: (for columnar modes or insert mode):\0" as *const u8
        as *const libc::c_char,
    b"     --wrap N       Wrap output lines to no longer than N characters\0"
        as *const u8 as *const libc::c_char,
    b"     --wordwrap B   Wrap or not at word boundaries per B (on/off)\0" as *const u8
        as *const libc::c_char,
    b"     --ww           Shorthand for \"--wordwrap 1\"\0" as *const u8
        as *const libc::c_char,
    b"     --quote        Quote output text as SQL literals\0" as *const u8
        as *const libc::c_char,
    b"     --noquote      Do not quote output text\0" as *const u8
        as *const libc::c_char,
    b"     TABLE          The name of SQL table used for \"insert\" mode\0" as *const u8
        as *const libc::c_char,
    b".nonce STRING            Suspend safe mode for one command if nonce matches\0"
        as *const u8 as *const libc::c_char,
    b".nullvalue STRING        Use STRING in place of NULL values\0" as *const u8
        as *const libc::c_char,
    b".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE\0"
        as *const u8 as *const libc::c_char,
    b"     If FILE begins with '|' then open as a pipe\0" as *const u8
        as *const libc::c_char,
    b"       --bom  Put a UTF8 byte-order mark at the beginning\0" as *const u8
        as *const libc::c_char,
    b"       -e     Send output to the system text editor\0" as *const u8
        as *const libc::c_char,
    b"       -x     Send output as CSV to a spreadsheet (same as \".excel\")\0"
        as *const u8 as *const libc::c_char,
    b".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE\0" as *const u8
        as *const libc::c_char,
    b"     Options:\0" as *const u8 as *const libc::c_char,
    b"        --append        Use appendvfs to append database to the end of FILE\0"
        as *const u8 as *const libc::c_char,
    b"        --deserialize   Load into memory using sqlite3_deserialize()\0"
        as *const u8 as *const libc::c_char,
    b"        --hexdb         Load the output of \"dbtotxt\" as an in-memory db\0"
        as *const u8 as *const libc::c_char,
    b"        --maxsize N     Maximum size for --hexdb or --deserialized database\0"
        as *const u8 as *const libc::c_char,
    b"        --new           Initialize FILE to an empty database\0" as *const u8
        as *const libc::c_char,
    b"        --nofollow      Do not follow symbolic links\0" as *const u8
        as *const libc::c_char,
    b"        --readonly      Open FILE readonly\0" as *const u8 as *const libc::c_char,
    b"        --zip           FILE is a ZIP archive\0" as *const u8
        as *const libc::c_char,
    b".output ?FILE?           Send output to FILE or stdout if FILE is omitted\0"
        as *const u8 as *const libc::c_char,
    b"   If FILE begins with '|' then open it as a pipe.\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --bom                 Prefix output with a UTF8 byte-order mark\0"
        as *const u8 as *const libc::c_char,
    b"     -e                    Send output to the system text editor\0" as *const u8
        as *const libc::c_char,
    b"     -x                    Send output as CSV to a spreadsheet\0" as *const u8
        as *const libc::c_char,
    b".parameter CMD ...       Manage SQL parameter bindings\0" as *const u8
        as *const libc::c_char,
    b"   clear                   Erase all bindings\0" as *const u8
        as *const libc::c_char,
    b"   init                    Initialize the TEMP table that holds bindings\0"
        as *const u8 as *const libc::c_char,
    b"   list                    List the current parameter bindings\0" as *const u8
        as *const libc::c_char,
    b"   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE\0"
        as *const u8 as *const libc::c_char,
    b"                           PARAMETER should start with one of: $ : @ ?\0"
        as *const u8 as *const libc::c_char,
    b"   unset PARAMETER         Remove PARAMETER from the binding table\0" as *const u8
        as *const libc::c_char,
    b".print STRING...         Print literal STRING\0" as *const u8
        as *const libc::c_char,
    b".progress N              Invoke progress handler after every N opcodes\0"
        as *const u8 as *const libc::c_char,
    b"   --limit N                 Interrupt after N progress callbacks\0" as *const u8
        as *const libc::c_char,
    b"   --once                    Do no more than one progress interrupt\0" as *const u8
        as *const libc::c_char,
    b"   --quiet|-q                No output except at interrupts\0" as *const u8
        as *const libc::c_char,
    b"   --reset                   Reset the count for each input and interrupt\0"
        as *const u8 as *const libc::c_char,
    b".prompt MAIN CONTINUE    Replace the standard prompts\0" as *const u8
        as *const libc::c_char,
    b".quit                    Exit this program\0" as *const u8 as *const libc::c_char,
    b".read FILE               Read input from FILE or command output\0" as *const u8
        as *const libc::c_char,
    b"    If FILE begins with \"|\", it is a command that generates the input.\0"
        as *const u8 as *const libc::c_char,
    b".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE\0"
        as *const u8 as *const libc::c_char,
    b".save ?OPTIONS? FILE     Write database to FILE (an alias for .backup ...)\0"
        as *const u8 as *const libc::c_char,
    b".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\0"
        as *const u8 as *const libc::c_char,
    b".schema ?PATTERN?        Show the CREATE statements matching PATTERN\0"
        as *const u8 as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"      --indent             Try to pretty-print the schema\0" as *const u8
        as *const libc::c_char,
    b"      --nosys              Omit objects whose names start with \"sqlite_\"\0"
        as *const u8 as *const libc::c_char,
    b".selftest ?OPTIONS?      Run tests defined in the SELFTEST table\0" as *const u8
        as *const libc::c_char,
    b"    Options:\0" as *const u8 as *const libc::c_char,
    b"       --init               Create a new SELFTEST table\0" as *const u8
        as *const libc::c_char,
    b"       -v                   Verbose output\0" as *const u8 as *const libc::c_char,
    b".separator COL ?ROW?     Change the column and row separators\0" as *const u8
        as *const libc::c_char,
    b".sha3sum ...             Compute a SHA3 hash of database content\0" as *const u8
        as *const libc::c_char,
    b"    Options:\0" as *const u8 as *const libc::c_char,
    b"      --schema              Also hash the sqlite_schema table\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-224            Use the sha3-224 algorithm\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-256            Use the sha3-256 algorithm (default)\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-384            Use the sha3-384 algorithm\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-512            Use the sha3-512 algorithm\0" as *const u8
        as *const libc::c_char,
    b"    Any other argument is a LIKE pattern for tables to hash\0" as *const u8
        as *const libc::c_char,
    b".shell CMD ARGS...       Run CMD ARGS... in a system shell\0" as *const u8
        as *const libc::c_char,
    b".show                    Show the current values for various settings\0"
        as *const u8 as *const libc::c_char,
    b".stats ?ARG?             Show stats or turn stats on or off\0" as *const u8
        as *const libc::c_char,
    b"   off                      Turn off automatic stat display\0" as *const u8
        as *const libc::c_char,
    b"   on                       Turn on automatic stat display\0" as *const u8
        as *const libc::c_char,
    b"   stmt                     Show statement stats\0" as *const u8
        as *const libc::c_char,
    b"   vmstep                   Show the virtual machine step count only\0"
        as *const u8 as *const libc::c_char,
    b".system CMD ARGS...      Run CMD ARGS... in a system shell\0" as *const u8
        as *const libc::c_char,
    b".tables ?TABLE?          List names of tables matching LIKE pattern TABLE\0"
        as *const u8 as *const libc::c_char,
    b".testcase NAME           Begin redirecting output to 'testcase-out.txt'\0"
        as *const u8 as *const libc::c_char,
    b".testctrl CMD ...        Run various sqlite3_test_control() operations\0"
        as *const u8 as *const libc::c_char,
    b"                           Run \".testctrl\" with no arguments for details\0"
        as *const u8 as *const libc::c_char,
    b".timeout MS              Try opening locked tables for MS milliseconds\0"
        as *const u8 as *const libc::c_char,
    b".timer on|off            Turn SQL timer on or off\0" as *const u8
        as *const libc::c_char,
    b".trace ?OPTIONS?         Output each SQL statement as it is run\0" as *const u8
        as *const libc::c_char,
    b"    FILE                    Send output to FILE\0" as *const u8
        as *const libc::c_char,
    b"    stdout                  Send output to stdout\0" as *const u8
        as *const libc::c_char,
    b"    stderr                  Send output to stderr\0" as *const u8
        as *const libc::c_char,
    b"    off                     Disable tracing\0" as *const u8 as *const libc::c_char,
    b"    --expanded              Expand query parameters\0" as *const u8
        as *const libc::c_char,
    b"    --plain                 Show SQL as it is input\0" as *const u8
        as *const libc::c_char,
    b"    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)\0"
        as *const u8 as *const libc::c_char,
    b"    --profile               Profile statements (SQLITE_TRACE_PROFILE)\0"
        as *const u8 as *const libc::c_char,
    b"    --row                   Trace each row (SQLITE_TRACE_ROW)\0" as *const u8
        as *const libc::c_char,
    b"    --close                 Trace connection close (SQLITE_TRACE_CLOSE)\0"
        as *const u8 as *const libc::c_char,
    b".vfsinfo ?AUX?           Information about the top-level VFS\0" as *const u8
        as *const libc::c_char,
    b".vfslist                 List all available VFSes\0" as *const u8
        as *const libc::c_char,
    b".vfsname ?AUX?           Print the name of the VFS stack\0" as *const u8
        as *const libc::c_char,
    b".width NUM1 NUM2 ...     Set minimum column widths for columnar output\0"
        as *const u8 as *const libc::c_char,
    b"     Negative values right-justify\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn showHelp(
    mut out: *mut FILE,
    mut zPattern: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut zPat: *mut libc::c_char = 0 as *mut libc::c_char;
    if zPattern.is_null()
        || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        || strcmp(zPattern, b"-a\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        || strcmp(zPattern, b"-all\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        || strcmp(zPattern, b"--all\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        if zPattern.is_null() {
            zPattern = b"\0" as *const u8 as *const libc::c_char;
        }
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 175]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '.' as i32
                || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int != 0
            {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                n += 1;
            }
            i += 1;
        }
    } else {
        zPat = sqlite3_mprintf(b".%s*\0" as *const u8 as *const libc::c_char, zPattern);
        shell_check_oom(zPat as *mut libc::c_void);
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 175]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if sqlite3_strglob(zPat, azHelp[i as usize]) == 0 as libc::c_int {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                j = i + 1 as libc::c_int;
                n += 1;
            }
            i += 1;
        }
        sqlite3_free(zPat as *mut libc::c_void);
        if n != 0 {
            if n == 1 as libc::c_int {
                while j
                    < (::core::mem::size_of::<[*const libc::c_char; 175]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        ) as libc::c_int - 1 as libc::c_int
                    && *(azHelp[j as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_int != '.' as i32
                {
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                    j += 1;
                }
            }
            return n;
        }
        zPat = sqlite3_mprintf(
            b"%%%s%%\0" as *const u8 as *const libc::c_char,
            zPattern,
        );
        shell_check_oom(zPat as *mut libc::c_void);
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 175]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '.' as i32
            {
                j = i;
            }
            if sqlite3_strlike(
                zPat,
                azHelp[i as usize],
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
            {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[j as usize],
                );
                while j
                    < (::core::mem::size_of::<[*const libc::c_char; 175]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        ) as libc::c_int - 1 as libc::c_int
                    && *(azHelp[(j + 1 as libc::c_int) as usize])
                        .offset(0 as libc::c_int as isize) as libc::c_int != '.' as i32
                {
                    j += 1;
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                }
                i = j;
                n += 1;
            }
            i += 1;
        }
        sqlite3_free(zPat as *mut libc::c_void);
    }
    return n;
}
unsafe extern "C" fn readFile(
    mut zName: *const libc::c_char,
    mut pnByte: *mut libc::c_int,
) -> *mut libc::c_char {
    let mut in_0: *mut FILE = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    let mut nIn: libc::c_long = 0;
    let mut nRead: size_t = 0;
    let mut pBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    if in_0.is_null() {
        return 0 as *mut libc::c_char;
    }
    fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
    nIn = ftell(in_0);
    rewind(in_0);
    pBuf = sqlite3_malloc64((nIn + 1 as libc::c_int as libc::c_long) as sqlite3_uint64)
        as *mut libc::c_char;
    if pBuf.is_null() {
        fclose(in_0);
        return 0 as *mut libc::c_char;
    }
    nRead = fread(
        pBuf as *mut libc::c_void,
        nIn as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        in_0,
    );
    fclose(in_0);
    if nRead != 1 as libc::c_int as libc::c_ulong {
        sqlite3_free(pBuf as *mut libc::c_void);
        return 0 as *mut libc::c_char;
    }
    *pBuf.offset(nIn as isize) = 0 as libc::c_int as libc::c_char;
    if !pnByte.is_null() {
        *pnByte = nIn as libc::c_int;
    }
    return pBuf;
}
#[no_mangle]
pub unsafe extern "C" fn deduceDatabaseType(
    mut zName: *const libc::c_char,
    mut dfltZip: libc::c_int,
) -> libc::c_int {
    let mut f: *mut FILE = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    let mut n: size_t = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zBuf: [libc::c_char; 100] = [0; 100];
    if f.is_null() {
        if dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\0" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            return 3 as libc::c_int
        } else {
            return 1 as libc::c_int
        }
    }
    n = fread(
        zBuf.as_mut_ptr() as *mut libc::c_void,
        16 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        f,
    );
    if n == 1 as libc::c_int as libc::c_ulong
        && memcmp(
            zBuf.as_mut_ptr() as *const libc::c_void,
            b"SQLite format 3\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
            16 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        fclose(f);
        return 1 as libc::c_int;
    }
    fseek(f, -(25 as libc::c_int) as libc::c_long, 2 as libc::c_int);
    n = fread(
        zBuf.as_mut_ptr() as *mut libc::c_void,
        25 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        f,
    );
    if n == 1 as libc::c_int as libc::c_ulong
        && memcmp(
            zBuf.as_mut_ptr() as *const libc::c_void,
            b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
            17 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        rc = 2 as libc::c_int;
    } else {
        fseek(f, -(22 as libc::c_int) as libc::c_long, 2 as libc::c_int);
        n = fread(
            zBuf.as_mut_ptr() as *mut libc::c_void,
            22 as libc::c_int as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            f,
        );
        if n == 1 as libc::c_int as libc::c_ulong
            && zBuf[0 as libc::c_int as usize] as libc::c_int == 0x50 as libc::c_int
            && zBuf[1 as libc::c_int as usize] as libc::c_int == 0x4b as libc::c_int
            && zBuf[2 as libc::c_int as usize] as libc::c_int == 0x5 as libc::c_int
            && zBuf[3 as libc::c_int as usize] as libc::c_int == 0x6 as libc::c_int
        {
            rc = 3 as libc::c_int;
        } else if n == 0 as libc::c_int as libc::c_ulong && dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\0" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            rc = 3 as libc::c_int;
        }
    }
    fclose(f);
    return rc;
}
unsafe extern "C" fn readHexDb(
    mut p: *mut ShellState,
    mut pnData: *mut libc::c_int,
) -> *mut libc::c_uchar {
    let mut a: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut nLine: libc::c_int = 0;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pgsz: libc::c_int = 0 as libc::c_int;
    let mut iOffset: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
    let mut x: [libc::c_uint; 16] = [0; 16];
    let mut zLine: [libc::c_char; 1000] = [0; 1000];
    if !zDbFilename.is_null() {
        in_0 = fopen(zDbFilename, b"r\0" as *const u8 as *const libc::c_char);
        if in_0.is_null() {
            fprintf(
                stderr,
                b"cannot open \"%s\" for reading\n\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
            );
            return 0 as *mut libc::c_uchar;
        }
        nLine = 0 as libc::c_int;
    } else {
        in_0 = (*p).in_0;
        nLine = (*p).lineno;
        if in_0.is_null() {
            in_0 = stdin;
        }
    }
    *pnData = 0 as libc::c_int;
    nLine += 1;
    if !(fgets(
        zLine.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong as libc::c_int,
        in_0,
    ))
        .is_null()
    {
        rc = sscanf(
            zLine.as_mut_ptr(),
            b"| size %d pagesize %d\0" as *const u8 as *const libc::c_char,
            &mut n as *mut libc::c_int,
            &mut pgsz as *mut libc::c_int,
        );
        if !(rc != 2 as libc::c_int) {
            if !(n < 0 as libc::c_int) {
                if !(pgsz < 512 as libc::c_int || pgsz > 65536 as libc::c_int
                    || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int)
                {
                    n = n + pgsz - 1 as libc::c_int & !(pgsz - 1 as libc::c_int);
                    a = sqlite3_malloc(if n != 0 { n } else { 1 as libc::c_int })
                        as *mut libc::c_uchar;
                    shell_check_oom(a as *mut libc::c_void);
                    memset(a as *mut libc::c_void, 0 as libc::c_int, n as libc::c_ulong);
                    if pgsz < 512 as libc::c_int || pgsz > 65536 as libc::c_int
                        || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"invalid pagesize\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        nLine += 1;
                        while !(fgets(
                            zLine.as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_char; 1000]>()
                                as libc::c_ulong as libc::c_int,
                            in_0,
                        ))
                            .is_null()
                        {
                            rc = sscanf(
                                zLine.as_mut_ptr(),
                                b"| page %d offset %d\0" as *const u8
                                    as *const libc::c_char,
                                &mut j as *mut libc::c_int,
                                &mut k as *mut libc::c_int,
                            );
                            if rc == 2 as libc::c_int {
                                iOffset = k;
                            } else {
                                if strncmp(
                                    zLine.as_mut_ptr(),
                                    b"| end \0" as *const u8 as *const libc::c_char,
                                    6 as libc::c_int as libc::c_ulong,
                                ) == 0 as libc::c_int
                                {
                                    break;
                                }
                                rc = sscanf(
                                    zLine.as_mut_ptr(),
                                    b"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\0"
                                        as *const u8 as *const libc::c_char,
                                    &mut j as *mut libc::c_int,
                                    &mut *x.as_mut_ptr().offset(0 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(1 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(2 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(3 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(4 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(5 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(6 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(7 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(8 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(9 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(10 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(11 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(12 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(13 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(14 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(15 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                );
                                if rc == 17 as libc::c_int {
                                    k = iOffset + j;
                                    if k + 16 as libc::c_int <= n && k >= 0 as libc::c_int {
                                        let mut ii: libc::c_int = 0;
                                        ii = 0 as libc::c_int;
                                        while ii < 16 as libc::c_int {
                                            *a
                                                .offset(
                                                    (k + ii) as isize,
                                                ) = (x[ii as usize] & 0xff as libc::c_int as libc::c_uint)
                                                as libc::c_uchar;
                                            ii += 1;
                                        }
                                    }
                                }
                            }
                            nLine += 1;
                        }
                        *pnData = n;
                        if in_0 != (*p).in_0 {
                            fclose(in_0);
                        } else {
                            (*p).lineno = nLine;
                        }
                        return a;
                    }
                }
            }
        }
    }
    if in_0 != (*p).in_0 {
        fclose(in_0);
    } else {
        while !(fgets(
            zLine.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong
                as libc::c_int,
            (*p).in_0,
        ))
            .is_null()
        {
            nLine += 1;
            if strncmp(
                zLine.as_mut_ptr(),
                b"| end \0" as *const u8 as *const libc::c_char,
                6 as libc::c_int as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                break;
            }
        }
        (*p).lineno = nLine;
    }
    sqlite3_free(a as *mut libc::c_void);
    fprintf(
        stderr,
        b"Error on line %d of --hexdb input\n\0" as *const u8 as *const libc::c_char,
        nLine,
    );
    return 0 as *mut libc::c_uchar;
}
unsafe extern "C" fn shellInt32(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pBlob: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut nBlob: libc::c_int = 0;
    let mut iInt: libc::c_int = 0;
    nBlob = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
    pBlob = sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_uchar;
    iInt = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
    if iInt >= 0 as libc::c_int && (iInt + 1 as libc::c_int) * 4 as libc::c_int <= nBlob
    {
        let mut a: *const libc::c_uchar = &*pBlob
            .offset((iInt * 4 as libc::c_int) as isize) as *const libc::c_uchar;
        let mut iVal: sqlite3_int64 = ((*a.offset(0 as libc::c_int as isize)
            as sqlite3_int64) << 24 as libc::c_int)
            + ((*a.offset(1 as libc::c_int as isize) as sqlite3_int64)
                << 16 as libc::c_int)
            + ((*a.offset(2 as libc::c_int as isize) as sqlite3_int64)
                << 8 as libc::c_int)
            + ((*a.offset(3 as libc::c_int as isize) as sqlite3_int64)
                << 0 as libc::c_int);
        sqlite3_result_int64(context, iVal);
    }
}
unsafe extern "C" fn shellIdQuote(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    if !zName.is_null() {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b"\"%w\"\0" as *const u8 as *const libc::c_char,
            zName,
        );
        sqlite3_result_text(
            context,
            z,
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
    }
}
unsafe extern "C" fn shellUSleepFunc(
    mut context: *mut sqlite3_context,
    mut argcUnused: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut sleep: libc::c_int = sqlite3_value_int(
        *argv.offset(0 as libc::c_int as isize),
    );
    sqlite3_sleep(sleep / 1000 as libc::c_int);
    sqlite3_result_int(context, sleep);
}
unsafe extern "C" fn shellEscapeCrnl(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zText: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    if !zText.is_null()
        && *zText.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32
    {
        let mut nText: libc::c_int = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        );
        let mut i: libc::c_int = 0;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while *zText.offset(i as isize) != 0 {
            if zNL.is_null() && *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                zNL = unused_string(
                    zText,
                    b"\\n\0" as *const u8 as *const libc::c_char,
                    b"\\012\0" as *const u8 as *const libc::c_char,
                    zBuf1.as_mut_ptr(),
                );
                nNL = strlen(zNL) as libc::c_int;
            }
            if zCR.is_null() && *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                zCR = unused_string(
                    zText,
                    b"\\r\0" as *const u8 as *const libc::c_char,
                    b"\\015\0" as *const u8 as *const libc::c_char,
                    zBuf2.as_mut_ptr(),
                );
                nCR = strlen(zCR) as libc::c_int;
            }
            i += 1;
        }
        if !zNL.is_null() || !zCR.is_null() {
            let mut iOut: libc::c_int = 0 as libc::c_int;
            let mut nMax: i64_0 = (if nNL > nCR { nNL } else { nCR }) as i64_0;
            let mut nAlloc: i64_0 = nMax * nText as libc::c_longlong
                + (nMax + 64 as libc::c_int as libc::c_longlong)
                    * 2 as libc::c_int as libc::c_longlong;
            let mut zOut: *mut libc::c_char = sqlite3_malloc64(nAlloc as sqlite3_uint64)
                as *mut libc::c_char;
            if zOut.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            }
            if !zNL.is_null() && !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    16 as libc::c_int as libc::c_ulong,
                );
                iOut += 16 as libc::c_int;
            } else {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    8 as libc::c_int as libc::c_ulong,
                );
                iOut += 8 as libc::c_int;
            }
            i = 0 as libc::c_int;
            while *zText.offset(i as isize) != 0 {
                if *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zNL as *const libc::c_void,
                        nNL as libc::c_ulong,
                    );
                    iOut += nNL;
                } else if *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zCR as *const libc::c_void,
                        nCR as libc::c_ulong,
                    );
                    iOut += nCR;
                } else {
                    *zOut.offset(iOut as isize) = *zText.offset(i as isize);
                    iOut += 1;
                }
                i += 1;
            }
            if !zNL.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zNL as *const libc::c_void,
                    nNL as libc::c_ulong,
                );
                iOut += nNL;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(10))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int;
            }
            if !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zCR as *const libc::c_void,
                    nCR as libc::c_ulong,
                );
                iOut += nCR;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(13))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int;
            }
            sqlite3_result_text(
                context,
                zOut,
                iOut,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            sqlite3_free(zOut as *mut libc::c_void);
            return;
        }
    }
    sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn open_db(mut p: *mut ShellState, mut openFlags: libc::c_int) {
    if ((*p).db).is_null() {
        let mut zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
        if (*p).openMode as libc::c_int == 0 as libc::c_int {
            if zDbFilename.is_null()
                || *zDbFilename.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
            {
                (*p).openMode = 1 as libc::c_int as u8_0;
            } else {
                (*p)
                    .openMode = deduceDatabaseType(
                    zDbFilename,
                    (openFlags & 0x2 as libc::c_int != 0 as libc::c_int) as libc::c_int,
                ) as u8_0;
            }
        }
        match (*p).openMode as libc::c_int {
            2 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    b"apndvfs\0" as *const u8 as *const libc::c_char,
                );
            }
            6 | 5 => {
                sqlite3_open(0 as *const libc::c_char, &mut (*p).db);
            }
            3 => {
                sqlite3_open(
                    b":memory:\0" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
            }
            4 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x1 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            0 | 1 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            _ => {}
        }
        globalDb = (*p).db;
        if ((*p).db).is_null() || 0 as libc::c_int != sqlite3_errcode((*p).db) {
            fprintf(
                stderr,
                b"Error: unable to open database \"%s\": %s\n\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
                sqlite3_errmsg((*p).db),
            );
            if openFlags & 0x1 as libc::c_int != 0 {
                sqlite3_open(
                    b":memory:\0" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
                return;
            }
            exit(1 as libc::c_int);
        }
        sqlite3_enable_load_extension((*p).db, 1 as libc::c_int);
        sqlite3_shathree_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_uint_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_decimal_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_regexp_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_ieee_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_series_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_fileio_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_completion_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_add_schema\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellAddSchemaName
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_module_schema\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellModuleSchema
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_putsnl\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            p as *mut libc::c_void,
            Some(
                shellPutsFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_escape_crnl\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellEscapeCrnl
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_int32\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellInt32
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_idquote\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellIdQuote
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"usleep\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellUSleepFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"edit\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                editFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"edit\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                editFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        if (*p).openMode as libc::c_int == 3 as libc::c_int {
            let mut zSql: *mut libc::c_char = sqlite3_mprintf(
                b"CREATE VIRTUAL TABLE zip USING zipfile(%Q);\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
            );
            shell_check_oom(zSql as *mut libc::c_void);
            sqlite3_exec(
                (*p).db,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql as *mut libc::c_void);
        } else if (*p).openMode as libc::c_int == 5 as libc::c_int
            || (*p).openMode as libc::c_int == 6 as libc::c_int
        {
            let mut rc: libc::c_int = 0;
            let mut nData: libc::c_int = 0 as libc::c_int;
            let mut aData: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            if (*p).openMode as libc::c_int == 5 as libc::c_int {
                aData = readFile(zDbFilename, &mut nData) as *mut libc::c_uchar;
            } else {
                aData = readHexDb(p, &mut nData);
                if aData.is_null() {
                    return;
                }
            }
            rc = sqlite3_deserialize(
                (*p).db,
                b"main\0" as *const u8 as *const libc::c_char,
                aData,
                nData as sqlite3_int64,
                nData as sqlite3_int64,
                (2 as libc::c_int | 1 as libc::c_int) as libc::c_uint,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: sqlite3_deserialize() returns %d\n\0" as *const u8
                        as *const libc::c_char,
                    rc,
                );
            }
            if (*p).szMax > 0 as libc::c_int as libc::c_longlong {
                sqlite3_file_control(
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    36 as libc::c_int,
                    &mut (*p).szMax as *mut sqlite3_int64 as *mut libc::c_void,
                );
            }
        }
    }
    if (*p).bSafeModePersist as libc::c_int != 0 && !((*p).db).is_null() {
        sqlite3_set_authorizer(
            (*p).db,
            Some(
                safeModeAuth
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> libc::c_int,
            ),
            p as *mut libc::c_void,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn close_db(mut db: *mut sqlite3) {
    let mut rc: libc::c_int = sqlite3_close(db);
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: sqlite3_close() returns %d: %s\n\0" as *const u8
                as *const libc::c_char,
            rc,
            sqlite3_errmsg(db),
        );
    }
}
unsafe extern "C" fn resolve_backslashes(mut z: *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    while *z as libc::c_int != 0 && *z as libc::c_int != '\\' as i32 {
        z = z.offset(1);
    }
    j = 0 as libc::c_int;
    i = j;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int) {
            break;
        }
        if c as libc::c_int == '\\' as i32
            && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                != 0 as libc::c_int
        {
            i += 1;
            c = *z.offset(i as isize);
            if c as libc::c_int == 'a' as i32 {
                c = '\u{7}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'b' as i32 {
                c = '\u{8}' as i32 as libc::c_char;
            } else if c as libc::c_int == 't' as i32 {
                c = '\t' as i32 as libc::c_char;
            } else if c as libc::c_int == 'n' as i32 {
                c = '\n' as i32 as libc::c_char;
            } else if c as libc::c_int == 'v' as i32 {
                c = '\u{b}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'f' as i32 {
                c = '\u{c}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'r' as i32 {
                c = '\r' as i32 as libc::c_char;
            } else if c as libc::c_int == '"' as i32 {
                c = '"' as i32 as libc::c_char;
            } else if c as libc::c_int == '\'' as i32 {
                c = '\'' as i32 as libc::c_char;
            } else if c as libc::c_int == '\\' as i32 {
                c = '\\' as i32 as libc::c_char;
            } else if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '7' as i32 {
                c = (c as libc::c_int - '0' as i32) as libc::c_char;
                if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    >= '0' as i32
                    && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        <= '7' as i32
                {
                    i += 1;
                    c = (((c as libc::c_int) << 3 as libc::c_int)
                        + *z.offset(i as isize) as libc::c_int - '0' as i32)
                        as libc::c_char;
                    if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        >= '0' as i32
                        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                            <= '7' as i32
                    {
                        i += 1;
                        c = (((c as libc::c_int) << 3 as libc::c_int)
                            + *z.offset(i as isize) as libc::c_int - '0' as i32)
                            as libc::c_char;
                    }
                }
            }
        }
        *z.offset(j as isize) = c;
        i += 1;
        j += 1;
    }
    if j < i {
        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
    }
}
unsafe extern "C" fn booleanValue(mut zArg: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        i = 2 as libc::c_int;
        while hexDigitValue(*zArg.offset(i as isize)) >= 0 as libc::c_int {
            i += 1;
        }
    } else {
        i = 0 as libc::c_int;
        while *zArg.offset(i as isize) as libc::c_int >= '0' as i32
            && *zArg.offset(i as isize) as libc::c_int <= '9' as i32
        {
            i += 1;
        }
    }
    if i > 0 as libc::c_int
        && *zArg.offset(i as isize) as libc::c_int == 0 as libc::c_int
    {
        return (integerValue(zArg) & 0xffffffff as libc::c_uint as libc::c_longlong)
            as libc::c_int;
    }
    if sqlite3_stricmp(zArg, b"on\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"yes\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        return 1 as libc::c_int;
    }
    if sqlite3_stricmp(zArg, b"off\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"no\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    fprintf(
        stderr,
        b"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n\0" as *const u8
            as *const libc::c_char,
        zArg,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn setOrClearFlag(
    mut p: *mut ShellState,
    mut mFlag: libc::c_uint,
    mut zArg: *const libc::c_char,
) {
    if booleanValue(zArg) != 0 {
        (*p).shellFlgs |= mFlag;
    } else {
        (*p).shellFlgs &= !mFlag;
    };
}
unsafe extern "C" fn output_file_close(mut f: *mut FILE) {
    if !f.is_null() && f != stdout && f != stderr {
        fclose(f);
    }
}
unsafe extern "C" fn output_file_open(
    mut zFile: *const libc::c_char,
    mut bTextMode: libc::c_int,
) -> *mut FILE {
    let mut f: *mut FILE = 0 as *mut FILE;
    if strcmp(zFile, b"stdout\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
    {
        f = stdout;
    } else if strcmp(zFile, b"stderr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = stderr;
    } else if strcmp(zFile, b"off\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = 0 as *mut FILE;
    } else {
        f = fopen(
            zFile,
            if bTextMode != 0 {
                b"w\0" as *const u8 as *const libc::c_char
            } else {
                b"wb\0" as *const u8 as *const libc::c_char
            },
        );
        if f.is_null() {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
    return f;
}
unsafe extern "C" fn sql_trace_callback(
    mut mType: libc::c_uint,
    mut pArg: *mut libc::c_void,
    mut pP: *mut libc::c_void,
    mut pX: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ShellState = pArg as *mut ShellState;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut nSql: libc::c_int = 0;
    if ((*p).traceOut).is_null() {
        return 0 as libc::c_int;
    }
    if mType == 0x8 as libc::c_int as libc::c_uint {
        fprintf(
            (*p).traceOut,
            b"-- closing database connection\n\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if mType != 0x4 as libc::c_int as libc::c_uint
        && *(pX as *const libc::c_char).offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
    {
        zSql = pX as *const libc::c_char;
    } else {
        pStmt = pP as *mut sqlite3_stmt;
        match (*p).eTraceType as libc::c_int {
            1 => {
                zSql = sqlite3_expanded_sql(pStmt);
            }
            _ => {
                zSql = sqlite3_sql(pStmt);
            }
        }
    }
    if zSql.is_null() {
        return 0 as libc::c_int;
    }
    nSql = strlen30(zSql);
    while nSql > 0 as libc::c_int
        && *zSql.offset((nSql - 1 as libc::c_int) as isize) as libc::c_int == ';' as i32
    {
        nSql -= 1;
    }
    match mType {
        4 | 1 => {
            fprintf(
                (*p).traceOut,
                b"%.*s;\n\0" as *const u8 as *const libc::c_char,
                nSql,
                zSql,
            );
        }
        2 => {
            let mut nNanosec: sqlite3_int64 = *(pX as *mut sqlite3_int64);
            fprintf(
                (*p).traceOut,
                b"%.*s; -- %lld ns\n\0" as *const u8 as *const libc::c_char,
                nSql,
                zSql,
                nNanosec,
            );
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn test_breakpoint() {
    static mut nCall: libc::c_int = 0 as libc::c_int;
    nCall += 1;
}
unsafe extern "C" fn import_cleanup(mut p: *mut ImportCtx) {
    if !((*p).in_0).is_null() && ((*p).xCloser).is_some() {
        ((*p).xCloser).expect("non-null function pointer")((*p).in_0);
        (*p).in_0 = 0 as *mut FILE;
    }
    sqlite3_free((*p).z as *mut libc::c_void);
    (*p).z = 0 as *mut libc::c_char;
}
unsafe extern "C" fn import_append_char(mut p: *mut ImportCtx, mut c: libc::c_int) {
    if (*p).n + 1 as libc::c_int >= (*p).nAlloc {
        (*p).nAlloc += (*p).nAlloc + 100 as libc::c_int;
        (*p)
            .z = sqlite3_realloc64(
            (*p).z as *mut libc::c_void,
            (*p).nAlloc as sqlite3_uint64,
        ) as *mut libc::c_char;
        shell_check_oom((*p).z as *mut libc::c_void);
    }
    let fresh62 = (*p).n;
    (*p).n = (*p).n + 1;
    *((*p).z).offset(fresh62 as isize) = c as libc::c_char;
}
unsafe extern "C" fn csv_read_one_field(mut p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let mut cSep: libc::c_int = (*p).cColSep;
    let mut rSep: libc::c_int = (*p).cRowSep;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    }
    if c == '"' as i32 {
        let mut pc: libc::c_int = 0;
        let mut ppc: libc::c_int = 0;
        let mut startLine: libc::c_int = (*p).nLine;
        let mut cQuote: libc::c_int = c;
        ppc = 0 as libc::c_int;
        pc = ppc;
        loop {
            c = fgetc((*p).in_0);
            if c == rSep {
                (*p).nLine += 1;
            }
            if c == cQuote {
                if pc == cQuote {
                    pc = 0 as libc::c_int;
                    continue;
                }
            }
            if c == cSep && pc == cQuote || c == rSep && pc == cQuote
                || c == rSep && pc == '\r' as i32 && ppc == cQuote
                || c == -(1 as libc::c_int) && pc == cQuote
            {
                loop {
                    (*p).n -= 1;
                    if !(*((*p).z).offset((*p).n as isize) as libc::c_int != cQuote) {
                        break;
                    }
                }
                (*p).cTerm = c;
                break;
            } else {
                if pc == cQuote && c != '\r' as i32 {
                    fprintf(
                        stderr,
                        b"%s:%d: unescaped %c character\n\0" as *const u8
                            as *const libc::c_char,
                        (*p).zFile,
                        (*p).nLine,
                        cQuote,
                    );
                }
                if c == -(1 as libc::c_int) {
                    fprintf(
                        stderr,
                        b"%s:%d: unterminated %c-quoted field\n\0" as *const u8
                            as *const libc::c_char,
                        (*p).zFile,
                        startLine,
                        cQuote,
                    );
                    (*p).cTerm = c;
                    break;
                } else {
                    import_append_char(p, c);
                    ppc = pc;
                    pc = c;
                }
            }
        }
    } else {
        if c & 0xff as libc::c_int == 0xef as libc::c_int
            && (*p).bNotFirst == 0 as libc::c_int
        {
            import_append_char(p, c);
            c = fgetc((*p).in_0);
            if c & 0xff as libc::c_int == 0xbb as libc::c_int {
                import_append_char(p, c);
                c = fgetc((*p).in_0);
                if c & 0xff as libc::c_int == 0xbf as libc::c_int {
                    (*p).bNotFirst = 1 as libc::c_int;
                    (*p).n = 0 as libc::c_int;
                    return csv_read_one_field(p);
                }
            }
        }
        while c != -(1 as libc::c_int) && c != cSep && c != rSep {
            import_append_char(p, c);
            c = fgetc((*p).in_0);
        }
        if c == rSep {
            (*p).nLine += 1;
            if (*p).n > 0 as libc::c_int
                && *((*p).z).offset(((*p).n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\r' as i32
            {
                (*p).n -= 1;
            }
        }
        (*p).cTerm = c;
    }
    if !((*p).z).is_null() {
        *((*p).z).offset((*p).n as isize) = 0 as libc::c_int as libc::c_char;
    }
    (*p).bNotFirst = 1 as libc::c_int;
    return (*p).z;
}
unsafe extern "C" fn ascii_read_one_field(mut p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let mut cSep: libc::c_int = (*p).cColSep;
    let mut rSep: libc::c_int = (*p).cRowSep;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    }
    while c != -(1 as libc::c_int) && c != cSep && c != rSep {
        import_append_char(p, c);
        c = fgetc((*p).in_0);
    }
    if c == rSep {
        (*p).nLine += 1;
    }
    (*p).cTerm = c;
    if !((*p).z).is_null() {
        *((*p).z).offset((*p).n as isize) = 0 as libc::c_int as libc::c_char;
    }
    return (*p).z;
}
unsafe extern "C" fn tryToCloneData(
    mut p: *mut ShellState,
    mut newDb: *mut sqlite3,
    mut zTable: *const libc::c_char,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pInsert: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zInsert: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut nTable: libc::c_int = strlen30(zTable);
    let mut k: libc::c_int = 0 as libc::c_int;
    let mut cnt: libc::c_int = 0 as libc::c_int;
    let spinRate: libc::c_int = 10000 as libc::c_int;
    zQuery = sqlite3_mprintf(
        b"SELECT * FROM \"%w\"\0" as *const u8 as *const libc::c_char,
        zTable,
    );
    shell_check_oom(zQuery as *mut libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error %d: %s on [%s]\n\0" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        n = sqlite3_column_count(pQuery);
        zInsert = sqlite3_malloc64(
            (200 as libc::c_int + nTable + n * 3 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_char;
        shell_check_oom(zInsert as *mut libc::c_void);
        sqlite3_snprintf(
            200 as libc::c_int + nTable,
            zInsert,
            b"INSERT OR IGNORE INTO \"%s\" VALUES(?\0" as *const u8
                as *const libc::c_char,
            zTable,
        );
        i = strlen30(zInsert);
        j = 1 as libc::c_int;
        while j < n {
            memcpy(
                zInsert.offset(i as isize) as *mut libc::c_void,
                b",?\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                2 as libc::c_int as libc::c_ulong,
            );
            i += 2 as libc::c_int;
            j += 1;
        }
        memcpy(
            zInsert.offset(i as isize) as *mut libc::c_void,
            b");\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            3 as libc::c_int as libc::c_ulong,
        );
        rc = sqlite3_prepare_v2(
            newDb,
            zInsert,
            -(1 as libc::c_int),
            &mut pInsert,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error %d: %s on [%s]\n\0" as *const u8 as *const libc::c_char,
                sqlite3_extended_errcode(newDb),
                sqlite3_errmsg(newDb),
                zQuery,
            );
        } else {
            k = 0 as libc::c_int;
            while k < 2 as libc::c_int {
                loop {
                    rc = sqlite3_step(pQuery);
                    if !(rc == 100 as libc::c_int) {
                        break;
                    }
                    i = 0 as libc::c_int;
                    while i < n {
                        match sqlite3_column_type(pQuery, i) {
                            5 => {
                                sqlite3_bind_null(pInsert, i + 1 as libc::c_int);
                            }
                            1 => {
                                sqlite3_bind_int64(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_int64(pQuery, i),
                                );
                            }
                            2 => {
                                sqlite3_bind_double(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_double(pQuery, i),
                                );
                            }
                            3 => {
                                sqlite3_bind_text(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_text(pQuery, i) as *const libc::c_char,
                                    -(1 as libc::c_int),
                                    None,
                                );
                            }
                            4 => {
                                sqlite3_bind_blob(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_blob(pQuery, i),
                                    sqlite3_column_bytes(pQuery, i),
                                    None,
                                );
                            }
                            _ => {}
                        }
                        i += 1;
                    }
                    rc = sqlite3_step(pInsert);
                    if rc != 0 as libc::c_int && rc != 100 as libc::c_int
                        && rc != 101 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"Error %d: %s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_extended_errcode(newDb),
                            sqlite3_errmsg(newDb),
                        );
                    }
                    sqlite3_reset(pInsert);
                    cnt += 1;
                    if cnt % spinRate == 0 as libc::c_int {
                        printf(
                            b"%c\x08\0" as *const u8 as *const libc::c_char,
                            (*::core::mem::transmute::<
                                &[u8; 5],
                                &[libc::c_char; 5],
                            >(b"|/-\\\0"))[(cnt / spinRate % 4 as libc::c_int) as usize]
                                as libc::c_int,
                        );
                        fflush(stdout);
                    }
                }
                if rc == 101 as libc::c_int {
                    break;
                }
                sqlite3_finalize(pQuery);
                sqlite3_free(zQuery as *mut libc::c_void);
                zQuery = sqlite3_mprintf(
                    b"SELECT * FROM \"%w\" ORDER BY rowid DESC;\0" as *const u8
                        as *const libc::c_char,
                    zTable,
                );
                shell_check_oom(zQuery as *mut libc::c_void);
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zQuery,
                    -(1 as libc::c_int),
                    &mut pQuery,
                    0 as *mut *const libc::c_char,
                );
                if rc != 0 {
                    fprintf(
                        stderr,
                        b"Warning: cannot step \"%s\" backwards\0" as *const u8
                            as *const libc::c_char,
                        zTable,
                    );
                    break;
                } else {
                    k += 1;
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_finalize(pInsert);
    sqlite3_free(zQuery as *mut libc::c_void);
    sqlite3_free(zInsert as *mut libc::c_void);
}
unsafe extern "C" fn tryToCloneSchema(
    mut p: *mut ShellState,
    mut newDb: *mut sqlite3,
    mut zWhere: *const libc::c_char,
    mut xForEach: Option::<
        unsafe extern "C" fn(*mut ShellState, *mut sqlite3, *const libc::c_char) -> (),
    >,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut zName: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zSql: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    zQuery = sqlite3_mprintf(
        b"SELECT name, sql FROM sqlite_schema WHERE %s\0" as *const u8
            as *const libc::c_char,
        zWhere,
    );
    shell_check_oom(zQuery as *mut libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: (%d) %s on [%s]\n\0" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        loop {
            rc = sqlite3_step(pQuery);
            if !(rc == 100 as libc::c_int) {
                break;
            }
            zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
            zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
            if zName.is_null() || zSql.is_null() {
                continue;
            }
            printf(b"%s... \0" as *const u8 as *const libc::c_char, zName);
            fflush(stdout);
            sqlite3_exec(
                newDb,
                zSql as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                &mut zErrMsg,
            );
            if !zErrMsg.is_null() {
                fprintf(
                    stderr,
                    b"Error: %s\nSQL: [%s]\n\0" as *const u8 as *const libc::c_char,
                    zErrMsg,
                    zSql,
                );
                sqlite3_free(zErrMsg as *mut libc::c_void);
                zErrMsg = 0 as *mut libc::c_char;
            }
            if xForEach.is_some() {
                xForEach
                    .expect(
                        "non-null function pointer",
                    )(p, newDb, zName as *const libc::c_char);
            }
            printf(b"done\n\0" as *const u8 as *const libc::c_char);
        }
        if rc != 101 as libc::c_int {
            sqlite3_finalize(pQuery);
            sqlite3_free(zQuery as *mut libc::c_void);
            zQuery = sqlite3_mprintf(
                b"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\0"
                    as *const u8 as *const libc::c_char,
                zWhere,
            );
            shell_check_oom(zQuery as *mut libc::c_void);
            rc = sqlite3_prepare_v2(
                (*p).db,
                zQuery,
                -(1 as libc::c_int),
                &mut pQuery,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: (%d) %s on [%s]\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_extended_errcode((*p).db),
                    sqlite3_errmsg((*p).db),
                    zQuery,
                );
            } else {
                while sqlite3_step(pQuery) == 100 as libc::c_int {
                    zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
                    zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
                    if zName.is_null() || zSql.is_null() {
                        continue;
                    }
                    printf(b"%s... \0" as *const u8 as *const libc::c_char, zName);
                    fflush(stdout);
                    sqlite3_exec(
                        newDb,
                        zSql as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        &mut zErrMsg,
                    );
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\nSQL: [%s]\n\0" as *const u8
                                as *const libc::c_char,
                            zErrMsg,
                            zSql,
                        );
                        sqlite3_free(zErrMsg as *mut libc::c_void);
                        zErrMsg = 0 as *mut libc::c_char;
                    }
                    if xForEach.is_some() {
                        xForEach
                            .expect(
                                "non-null function pointer",
                            )(p, newDb, zName as *const libc::c_char);
                    }
                    printf(b"done\n\0" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_free(zQuery as *mut libc::c_void);
}
unsafe extern "C" fn tryToClone(
    mut p: *mut ShellState,
    mut zNewDb: *const libc::c_char,
) {
    let mut rc: libc::c_int = 0;
    let mut newDb: *mut sqlite3 = 0 as *mut sqlite3;
    if access(zNewDb, 0 as libc::c_int) == 0 as libc::c_int {
        fprintf(
            stderr,
            b"File \"%s\" already exists.\n\0" as *const u8 as *const libc::c_char,
            zNewDb,
        );
        return;
    }
    rc = sqlite3_open(zNewDb, &mut newDb);
    if rc != 0 {
        fprintf(
            stderr,
            b"Cannot create output database: %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(newDb),
        );
    } else {
        sqlite3_exec(
            (*p).db,
            b"PRAGMA writable_schema=ON;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        sqlite3_exec(
            newDb,
            b"BEGIN EXCLUSIVE;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        tryToCloneSchema(
            p,
            newDb,
            b"type='table'\0" as *const u8 as *const libc::c_char,
            Some(
                tryToCloneData
                    as unsafe extern "C" fn(
                        *mut ShellState,
                        *mut sqlite3,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        tryToCloneSchema(
            p,
            newDb,
            b"type!='table'\0" as *const u8 as *const libc::c_char,
            None,
        );
        sqlite3_exec(
            newDb,
            b"COMMIT;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        sqlite3_exec(
            (*p).db,
            b"PRAGMA writable_schema=OFF;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    close_db(newDb);
}
unsafe extern "C" fn output_reset(mut p: *mut ShellState) {
    if (*p).outfile[0 as libc::c_int as usize] as libc::c_int == '|' as i32 {
        pclose((*p).out);
    } else {
        output_file_close((*p).out);
        if (*p).doXdgOpen != 0 {
            let mut zXdgOpenCmd: *const libc::c_char = b"xdg-open\0" as *const u8
                as *const libc::c_char;
            let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
            zCmd = sqlite3_mprintf(
                b"%s %s\0" as *const u8 as *const libc::c_char,
                zXdgOpenCmd,
                (*p).zTempFile,
            );
            if system(zCmd) != 0 {
                fprintf(
                    stderr,
                    b"Failed: [%s]\n\0" as *const u8 as *const libc::c_char,
                    zCmd,
                );
            } else {
                sqlite3_sleep(2000 as libc::c_int);
            }
            sqlite3_free(zCmd as *mut libc::c_void);
            outputModePop(p);
            (*p).doXdgOpen = 0 as libc::c_int as u8_0;
        }
    }
    (*p).outfile[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    (*p).out = stdout;
}
unsafe extern "C" fn db_int(
    mut db: *mut sqlite3,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut res: libc::c_int = 0 as libc::c_int;
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if !pStmt.is_null() && sqlite3_step(pStmt) == 100 as libc::c_int {
        res = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    sqlite3_finalize(pStmt);
    return res;
}
unsafe extern "C" fn shellDatabaseError(mut db: *mut sqlite3) -> libc::c_int {
    let mut zErr: *const libc::c_char = sqlite3_errmsg(db);
    fprintf(stderr, b"Error: %s\n\0" as *const u8 as *const libc::c_char, zErr);
    return 1 as libc::c_int;
}
unsafe extern "C" fn testcase_glob(
    mut zGlob: *const libc::c_char,
    mut z: *const libc::c_char,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut invert: libc::c_int = 0;
    let mut seen: libc::c_int = 0;
    loop {
        let fresh63 = zGlob;
        zGlob = zGlob.offset(1);
        c = *fresh63 as libc::c_int;
        if !(c != 0 as libc::c_int) {
            break;
        }
        if *(*__ctype_b_loc()).offset(c as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            }
            while *(*__ctype_b_loc())
                .offset(*zGlob as libc::c_uchar as libc::c_int as isize) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zGlob = zGlob.offset(1);
            }
            while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                != 0
            {
                z = z.offset(1);
            }
        } else if c == '*' as i32 {
            loop {
                let fresh64 = zGlob;
                zGlob = zGlob.offset(1);
                c = *fresh64 as libc::c_int;
                if !(c == '*' as i32 || c == '?' as i32) {
                    break;
                }
                if c == '?' as i32
                    && {
                        let fresh65 = z;
                        z = z.offset(1);
                        *fresh65 as libc::c_int == 0 as libc::c_int
                    }
                {
                    return 0 as libc::c_int;
                }
            }
            if c == 0 as libc::c_int {
                return 1 as libc::c_int
            } else {
                if c == '[' as i32 {
                    while *z as libc::c_int != 0
                        && testcase_glob(zGlob.offset(-(1 as libc::c_int as isize)), z)
                            == 0 as libc::c_int
                    {
                        z = z.offset(1);
                    }
                    return (*z as libc::c_int != 0 as libc::c_int) as libc::c_int;
                }
            }
            loop {
                let fresh66 = z;
                z = z.offset(1);
                c2 = *fresh66 as libc::c_int;
                if !(c2 != 0 as libc::c_int) {
                    break;
                }
                while c2 != c {
                    let fresh67 = z;
                    z = z.offset(1);
                    c2 = *fresh67 as libc::c_int;
                    if c2 == 0 as libc::c_int {
                        return 0 as libc::c_int;
                    }
                }
                if testcase_glob(zGlob, z) != 0 {
                    return 1 as libc::c_int;
                }
            }
            return 0 as libc::c_int;
        } else {
            if c == '?' as i32 {
                let fresh68 = z;
                z = z.offset(1);
                if *fresh68 as libc::c_int == 0 as libc::c_int {
                    return 0 as libc::c_int;
                }
            } else if c == '[' as i32 {
                let mut prior_c: libc::c_int = 0 as libc::c_int;
                seen = 0 as libc::c_int;
                invert = 0 as libc::c_int;
                let fresh69 = z;
                z = z.offset(1);
                c = *fresh69 as libc::c_int;
                if c == 0 as libc::c_int {
                    return 0 as libc::c_int;
                }
                let fresh70 = zGlob;
                zGlob = zGlob.offset(1);
                c2 = *fresh70 as libc::c_int;
                if c2 == '^' as i32 {
                    invert = 1 as libc::c_int;
                    let fresh71 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh71 as libc::c_int;
                }
                if c2 == ']' as i32 {
                    if c == ']' as i32 {
                        seen = 1 as libc::c_int;
                    }
                    let fresh72 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh72 as libc::c_int;
                }
                while c2 != 0 && c2 != ']' as i32 {
                    if c2 == '-' as i32
                        && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                            != ']' as i32
                        && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                            != 0 as libc::c_int && prior_c > 0 as libc::c_int
                    {
                        let fresh73 = zGlob;
                        zGlob = zGlob.offset(1);
                        c2 = *fresh73 as libc::c_int;
                        if c >= prior_c && c <= c2 {
                            seen = 1 as libc::c_int;
                        }
                        prior_c = 0 as libc::c_int;
                    } else {
                        if c == c2 {
                            seen = 1 as libc::c_int;
                        }
                        prior_c = c2;
                    }
                    let fresh74 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh74 as libc::c_int;
                }
                if c2 == 0 as libc::c_int || seen ^ invert == 0 as libc::c_int {
                    return 0 as libc::c_int;
                }
            } else if c == '#' as i32 {
                if (*z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                    || *z.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32)
                    && *(*__ctype_b_loc())
                        .offset(
                            *z.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int as isize,
                        ) as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    z = z.offset(1);
                }
                if *(*__ctype_b_loc())
                    .offset(
                        *z.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
                {
                    return 0 as libc::c_int;
                }
                z = z.offset(1);
                while *(*__ctype_b_loc())
                    .offset(
                        *z.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    z = z.offset(1);
                }
            } else {
                let fresh75 = z;
                z = z.offset(1);
                if c != *fresh75 as libc::c_int {
                    return 0 as libc::c_int;
                }
            }
        }
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        z = z.offset(1);
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn optionMatch(
    mut zStr: *const libc::c_char,
    mut zOpt: *const libc::c_char,
) -> libc::c_int {
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
        return 0 as libc::c_int;
    }
    zStr = zStr.offset(1);
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        zStr = zStr.offset(1);
    }
    return (strcmp(zStr, zOpt) == 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn shellDeleteFile(
    mut zFilename: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    rc = unlink(zFilename);
    return rc;
}
unsafe extern "C" fn clearTempFile(mut p: *mut ShellState) {
    if ((*p).zTempFile).is_null() {
        return;
    }
    if (*p).doXdgOpen != 0 {
        return;
    }
    if shellDeleteFile((*p).zTempFile) != 0 {
        return;
    }
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    (*p).zTempFile = 0 as *mut libc::c_char;
}
unsafe extern "C" fn newTempFile(
    mut p: *mut ShellState,
    mut zSuffix: *const libc::c_char,
) {
    clearTempFile(p);
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    (*p).zTempFile = 0 as *mut libc::c_char;
    if !((*p).db).is_null() {
        sqlite3_file_control(
            (*p).db,
            0 as *const libc::c_char,
            16 as libc::c_int,
            &mut (*p).zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
        );
    }
    if ((*p).zTempFile).is_null() {
        let mut zTemp: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut r: sqlite3_uint64 = 0;
        sqlite3_randomness(
            ::core::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTemp = getenv(b"TEMP\0" as *const u8 as *const libc::c_char);
        if zTemp.is_null() {
            zTemp = getenv(b"TMP\0" as *const u8 as *const libc::c_char);
        }
        if zTemp.is_null() {
            zTemp = b"/tmp\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        (*p)
            .zTempFile = sqlite3_mprintf(
            b"%s/temp%llx.%s\0" as *const u8 as *const libc::c_char,
            zTemp,
            r,
            zSuffix,
        );
    } else {
        (*p)
            .zTempFile = sqlite3_mprintf(
            b"%z.%s\0" as *const u8 as *const libc::c_char,
            (*p).zTempFile,
            zSuffix,
        );
    }
    shell_check_oom((*p).zTempFile as *mut libc::c_void);
}
unsafe extern "C" fn shellFkeyCollateClause(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    let mut zParent: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChild: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    if nVal == 4 as libc::c_int {} else {
        __assert_fail(
            b"nVal==4\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            17245 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 70],
                &[libc::c_char; 70],
            >(
                b"void shellFkeyCollateClause(sqlite3_context *, int, sqlite3_value **)\0",
            ))
                .as_ptr(),
        );
    }
    zParent = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    zParentCol = sqlite3_value_text(*apVal.offset(1 as libc::c_int as isize))
        as *const libc::c_char;
    zChild = sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize))
        as *const libc::c_char;
    zChildCol = sqlite3_value_text(*apVal.offset(3 as libc::c_int as isize))
        as *const libc::c_char;
    sqlite3_result_text(
        pCtx,
        b"\0" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        None,
    );
    rc = sqlite3_table_column_metadata(
        db,
        b"main\0" as *const u8 as *const libc::c_char,
        zParent,
        zParentCol,
        0 as *mut *const libc::c_char,
        &mut zParentSeq,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_table_column_metadata(
            db,
            b"main\0" as *const u8 as *const libc::c_char,
            zChild,
            zChildCol,
            0 as *mut *const libc::c_char,
            &mut zChildSeq,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
    }
    if rc == 0 as libc::c_int && sqlite3_stricmp(zParentSeq, zChildSeq) != 0 {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b" COLLATE %s\0" as *const u8 as *const libc::c_char,
            zParentSeq,
        );
        sqlite3_result_text(
            pCtx,
            z,
            -(1 as libc::c_int),
            ::core::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
        sqlite3_free(z as *mut libc::c_void);
    }
}
unsafe extern "C" fn lintFkeyIndexes(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut db: *mut sqlite3 = (*pState).db;
    let mut out: *mut FILE = (*pState).out;
    let mut bVerbose: libc::c_int = 0 as libc::c_int;
    let mut bGroupByParent: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut zIndent: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *const libc::c_char = b"SELECT      'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?'   || fkey_collate_clause(       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND '),      'SEARCH ' || s.name || ' USING COVERING INDEX*('  || group_concat('*=?', ' AND ') || ')',      s.name  || '(' || group_concat(f.[from],  ', ') || ')',      f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')',      'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))  || ' ON ' || quote(s.name) || '('  || group_concat(quote(f.[from]) ||        fkey_collate_clause(          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')  || ');',      f.[table] FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) GROUP BY s.name, f.id ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)\0"
        as *const u8 as *const libc::c_char;
    let mut zGlobIPK: *const libc::c_char = b"SEARCH * USING INTEGER PRIMARY KEY (rowid=?)\0"
        as *const u8 as *const libc::c_char;
    i = 2 as libc::c_int;
    while i < nArg {
        let mut n: libc::c_int = strlen30(*azArg.offset(i as isize));
        if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-verbose\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bVerbose = 1 as libc::c_int;
        } else if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-groupbyparent\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bGroupByParent = 1 as libc::c_int;
            zIndent = b"    \0" as *const u8 as *const libc::c_char;
        } else {
            fprintf(
                stderr,
                b"Usage: %s %s ?-verbose? ?-groupbyparent?\n\0" as *const u8
                    as *const libc::c_char,
                *azArg.offset(0 as libc::c_int as isize),
                *azArg.offset(1 as libc::c_int as isize),
            );
            return 1 as libc::c_int;
        }
        i += 1;
    }
    rc = sqlite3_create_function(
        db,
        b"fkey_collate_clause\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            shellFkeyCollateClause
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pSql,
            0 as *mut *const libc::c_char,
        );
    }
    if rc == 0 as libc::c_int {
        sqlite3_bind_int(pSql, 1 as libc::c_int, bGroupByParent);
    }
    if rc == 0 as libc::c_int {
        let mut rc2: libc::c_int = 0;
        let mut zPrev: *mut libc::c_char = 0 as *mut libc::c_char;
        while 100 as libc::c_int == sqlite3_step(pSql) {
            let mut res: libc::c_int = -(1 as libc::c_int);
            let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut zEQP: *const libc::c_char = sqlite3_column_text(
                pSql,
                0 as libc::c_int,
            ) as *const libc::c_char;
            let mut zGlob: *const libc::c_char = sqlite3_column_text(
                pSql,
                1 as libc::c_int,
            ) as *const libc::c_char;
            let mut zFrom: *const libc::c_char = sqlite3_column_text(
                pSql,
                2 as libc::c_int,
            ) as *const libc::c_char;
            let mut zTarget: *const libc::c_char = sqlite3_column_text(
                pSql,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut zCI: *const libc::c_char = sqlite3_column_text(
                pSql,
                4 as libc::c_int,
            ) as *const libc::c_char;
            let mut zParent: *const libc::c_char = sqlite3_column_text(
                pSql,
                5 as libc::c_int,
            ) as *const libc::c_char;
            if zEQP.is_null() {
                continue;
            }
            if zGlob.is_null() {
                continue;
            }
            rc = sqlite3_prepare_v2(
                db,
                zEQP,
                -(1 as libc::c_int),
                &mut pExplain,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 as libc::c_int {
                break;
            }
            if 100 as libc::c_int == sqlite3_step(pExplain) {
                let mut zPlan: *const libc::c_char = sqlite3_column_text(
                    pExplain,
                    3 as libc::c_int,
                ) as *const libc::c_char;
                res = (!zPlan.is_null()
                    && (0 as libc::c_int == sqlite3_strglob(zGlob, zPlan)
                        || 0 as libc::c_int == sqlite3_strglob(zGlobIPK, zPlan)))
                    as libc::c_int;
            }
            rc = sqlite3_finalize(pExplain);
            if rc != 0 as libc::c_int {
                break;
            }
            if res < 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: internal error\0" as *const u8 as *const libc::c_char,
                );
                break;
            } else {
                if bGroupByParent != 0 && (bVerbose != 0 || res == 0 as libc::c_int)
                    && (zPrev.is_null() || sqlite3_stricmp(zParent, zPrev) != 0)
                {
                    fprintf(
                        out,
                        b"-- Parent table %s\n\0" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                    sqlite3_free(zPrev as *mut libc::c_void);
                    zPrev = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                }
                if res == 0 as libc::c_int {
                    fprintf(
                        out,
                        b"%s%s --> %s\n\0" as *const u8 as *const libc::c_char,
                        zIndent,
                        zCI,
                        zTarget,
                    );
                } else if bVerbose != 0 {
                    fprintf(
                        out,
                        b"%s/* no extra indexes required for %s -> %s */\n\0"
                            as *const u8 as *const libc::c_char,
                        zIndent,
                        zFrom,
                        zTarget,
                    );
                }
            }
        }
        sqlite3_free(zPrev as *mut libc::c_void);
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        rc2 = sqlite3_finalize(pSql);
        if rc == 0 as libc::c_int && rc2 != 0 as libc::c_int {
            rc = rc2;
            fprintf(
                stderr,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
    } else {
        fprintf(
            stderr,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(db),
        );
    }
    return rc;
}
unsafe extern "C" fn lintDotCommand(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    n = if nArg >= 2 as libc::c_int {
        strlen30(*azArg.offset(1 as libc::c_int as isize))
    } else {
        0 as libc::c_int
    };
    if n < 1 as libc::c_int
        || sqlite3_strnicmp(
            *azArg.offset(1 as libc::c_int as isize),
            b"fkey-indexes\0" as *const u8 as *const libc::c_char,
            n,
        ) != 0
    {
        fprintf(
            stderr,
            b"Usage %s sub-command ?switches...?\n\0" as *const u8
                as *const libc::c_char,
            *azArg.offset(0 as libc::c_int as isize),
        );
        fprintf(
            stderr,
            b"Where sub-commands are:\n\0" as *const u8 as *const libc::c_char,
        );
        fprintf(stderr, b"    fkey-indexes\n\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    } else {
        return lintFkeyIndexes(pState, azArg, nArg)
    };
}
unsafe extern "C" fn shellPrepare(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut zSql: *const libc::c_char,
    mut ppStmt: *mut *mut sqlite3_stmt,
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut rc: libc::c_int = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            ppStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"sql error: %s (%d)\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
                sqlite3_errcode(db),
            );
            *pRc = rc;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellPreparePrintf(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut ap: ::core::ffi::VaListImpl;
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            *pRc = 7 as libc::c_int;
        } else {
            shellPrepare(db, pRc, z, ppStmt);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellFinalize(
    mut pRc: *mut libc::c_int,
    mut pStmt: *mut sqlite3_stmt,
) {
    if !pStmt.is_null() {
        let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
        let mut rc: libc::c_int = sqlite3_finalize(pStmt);
        if *pRc == 0 as libc::c_int {
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"SQL error: %s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_errmsg(db),
                );
            }
            *pRc = rc;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellReset(
    mut pRc: *mut libc::c_int,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = sqlite3_reset(pStmt);
    if *pRc == 0 as libc::c_int {
        if rc != 0 as libc::c_int {
            let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
            fprintf(
                stderr,
                b"SQL error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        *pRc = rc;
    }
}
unsafe extern "C" fn rc_err_oom_die(mut rc: libc::c_int) {
    if rc == 7 as libc::c_int {
        shell_check_oom(0 as *mut libc::c_void);
    }
    if rc == 0 as libc::c_int || rc == 101 as libc::c_int {} else {
        __assert_fail(
            b"rc==SQLITE_OK||rc==SQLITE_DONE\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19011 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 25],
                &[libc::c_char; 25],
            >(b"void rc_err_oom_die(int)\0"))
                .as_ptr(),
        );
    };
}
static mut zCOL_DB: *const libc::c_char = b":memory:\0" as *const u8
    as *const libc::c_char;
unsafe extern "C" fn zAutoColumn(
    mut zColNew: *const libc::c_char,
    mut pDb: *mut *mut sqlite3,
    mut pzRenamed: *mut *mut libc::c_char,
) -> *mut libc::c_char {
    static mut zTabMake: *const libc::c_char = b"CREATE TABLE ColNames( cpos INTEGER PRIMARY KEY, name TEXT, nlen INT, chop INT, reps INT, suff TEXT);CREATE VIEW RepeatedNames AS SELECT DISTINCT t.name FROM ColNames t WHERE t.name COLLATE NOCASE IN ( SELECT o.name FROM ColNames o WHERE o.cpos<>t.cpos);\0"
        as *const u8 as *const libc::c_char;
    static mut zTabFill: *const libc::c_char = b"INSERT INTO ColNames(name,nlen,chop,reps,suff) VALUES(iif(length(?1)>0,?1,'?'),max(length(?1),1),0,0,'')\0"
        as *const u8 as *const libc::c_char;
    static mut zHasDupes: *const libc::c_char = b"SELECT count(DISTINCT (substring(name,1,nlen-chop)||suff) COLLATE NOCASE) <count(name) FROM ColNames\0"
        as *const u8 as *const libc::c_char;
    static mut zSetReps: *const libc::c_char = b"UPDATE ColNames AS t SET reps=(SELECT count(*) FROM ColNames d  WHERE substring(t.name,1,t.nlen-t.chop)=substring(d.name,1,d.nlen-d.chop) COLLATE NOCASE)\0"
        as *const u8 as *const libc::c_char;
    static mut zColDigits: *const libc::c_char = b"SELECT CASE WHEN (nc < 10) THEN 1 WHEN (nc < 100) THEN 2  WHEN (nc < 1000) THEN 3 WHEN (nc < 10000) THEN 4  ELSE 5 FROM (SELECT count(*) AS nc FROM ColNames) \0"
        as *const u8 as *const libc::c_char;
    static mut zRenameRank: *const libc::c_char = b"WITH Lzn(nlz) AS (  SELECT 0 AS nlz  UNION  SELECT nlz+1 AS nlz FROM Lzn  WHERE EXISTS(   SELECT 1   FROM ColNames t, ColNames o   WHERE    iif(t.name IN (SELECT * FROM RepeatedNames),     printf('%s_%s',      t.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,t.cpos),2)),     t.name    )    =    iif(o.name IN (SELECT * FROM RepeatedNames),     printf('%s_%s',      o.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,o.cpos),2)),     o.name    )    COLLATE NOCASE    AND o.cpos<>t.cpos   GROUP BY t.cpos  )) UPDATE Colnames AS t SET chop = 0, suff = iif(name IN (SELECT * FROM RepeatedNames),  printf('_%s', substring(   printf('%.*c%0.*d',(SELECT max(nlz) FROM Lzn)+1,'0',1,t.cpos),2)),  '' )\0"
        as *const u8 as *const libc::c_char;
    static mut zCollectVar: *const libc::c_char = b"SELECT '('||x'0a' || group_concat(  cname||' TEXT',  ','||iif((cpos-1)%4>0, ' ', x'0a'||' ')) ||')' AS ColsSpec FROM ( SELECT cpos, printf('\"%w\"',printf('%!.*s%s', nlen-chop,name,suff)) AS cname  FROM ColNames ORDER BY cpos)\0"
        as *const u8 as *const libc::c_char;
    static mut zRenamesDone: *const libc::c_char = b"SELECT group_concat( printf('\"%w\" to \"%w\"',name,printf('%!.*s%s', nlen-chop, name, suff)), ','||x'0a')FROM ColNames WHERE suff<>'' OR chop!=0\0"
        as *const u8 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if !pDb.is_null() {} else {
        __assert_fail(
            b"pDb!=0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19137 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 53],
                &[libc::c_char; 53],
            >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                .as_ptr(),
        );
    }
    if !zColNew.is_null() {
        if (*pDb).is_null() {
            if 0 as libc::c_int != sqlite3_open(zCOL_DB, pDb) {
                return 0 as *mut libc::c_char;
            }
            rc = sqlite3_exec(
                *pDb,
                zTabMake,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            rc_err_oom_die(rc);
        }
        if !(*pDb).is_null() {} else {
            __assert_fail(
                b"*pDb!=0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19150 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 53],
                    &[libc::c_char; 53],
                >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                    .as_ptr(),
            );
        }
        rc = sqlite3_prepare_v2(
            *pDb,
            zTabFill,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_bind_text(
            pStmt,
            1 as libc::c_int,
            zColNew,
            -(1 as libc::c_int),
            None,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_step(pStmt);
        rc_err_oom_die(rc);
        sqlite3_finalize(pStmt);
        return 0 as *mut libc::c_char;
    } else if (*pDb).is_null() {
        return 0 as *mut libc::c_char
    } else {
        let mut zColsSpec: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut hasDupes: libc::c_int = db_int(*pDb, zHasDupes);
        let mut nDigits: libc::c_int = if hasDupes != 0 {
            db_int(*pDb, zColDigits)
        } else {
            0 as libc::c_int
        };
        if hasDupes != 0 {
            rc = sqlite3_exec(
                *pDb,
                zSetReps,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            rc_err_oom_die(rc);
            rc = sqlite3_prepare_v2(
                *pDb,
                zRenameRank,
                -(1 as libc::c_int),
                &mut pStmt,
                0 as *mut *const libc::c_char,
            );
            rc_err_oom_die(rc);
            sqlite3_bind_int(pStmt, 1 as libc::c_int, nDigits);
            rc = sqlite3_step(pStmt);
            sqlite3_finalize(pStmt);
            if rc == 101 as libc::c_int {} else {
                __assert_fail(
                    b"rc==SQLITE_DONE\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    19178 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 53],
                        &[libc::c_char; 53],
                    >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                        .as_ptr(),
                );
            }
        }
        if db_int(*pDb, zHasDupes) == 0 as libc::c_int {} else {
            __assert_fail(
                b"db_int(*pDb, zHasDupes)==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19180 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 53],
                    &[libc::c_char; 53],
                >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                    .as_ptr(),
            );
        }
        rc = sqlite3_prepare_v2(
            *pDb,
            zCollectVar,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_step(pStmt);
        if rc == 100 as libc::c_int {
            zColsSpec = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, 0 as libc::c_int),
            );
        } else {
            zColsSpec = 0 as *mut libc::c_char;
        }
        if !pzRenamed.is_null() {
            if hasDupes == 0 {
                *pzRenamed = 0 as *mut libc::c_char;
            } else {
                sqlite3_finalize(pStmt);
                if 0 as libc::c_int
                    == sqlite3_prepare_v2(
                        *pDb,
                        zRenamesDone,
                        -(1 as libc::c_int),
                        &mut pStmt,
                        0 as *mut *const libc::c_char,
                    ) && 100 as libc::c_int == sqlite3_step(pStmt)
                {
                    *pzRenamed = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        sqlite3_column_text(pStmt, 0 as libc::c_int),
                    );
                } else {
                    *pzRenamed = 0 as *mut libc::c_char;
                }
            }
        }
        sqlite3_finalize(pStmt);
        sqlite3_close(*pDb);
        *pDb = 0 as *mut sqlite3;
        return zColsSpec;
    };
}
unsafe extern "C" fn do_meta_command(
    mut zLine: *mut libc::c_char,
    mut p: *mut ShellState,
) -> libc::c_int {
    let mut dbCols: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zRenames: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zColDefs: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut current_block: u64;
    let mut h: libc::c_int = 1 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut azArg: [*mut libc::c_char; 52] = [0 as *mut libc::c_char; 52];
    if !((*p).expert.pExpert).is_null() {
        expertFinish(p, 1 as libc::c_int, 0 as *mut *mut libc::c_char);
    }
    while *zLine.offset(h as isize) as libc::c_int != 0
        && nArg
            < (::core::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as libc::c_int - 1 as libc::c_int
    {
        while *(*__ctype_b_loc())
            .offset(*zLine.offset(h as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            h += 1;
        }
        if *zLine.offset(h as isize) as libc::c_int == 0 as libc::c_int {
            break;
        }
        if *zLine.offset(h as isize) as libc::c_int == '\'' as i32
            || *zLine.offset(h as isize) as libc::c_int == '"' as i32
        {
            let fresh76 = h;
            h = h + 1;
            let mut delim: libc::c_int = *zLine.offset(fresh76 as isize) as libc::c_int;
            let fresh77 = nArg;
            nArg = nArg + 1;
            azArg[fresh77
                as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *zLine.offset(h as isize) as libc::c_int != delim
            {
                if *zLine.offset(h as isize) as libc::c_int == '\\' as i32
                    && delim == '"' as i32
                    && *zLine.offset((h + 1 as libc::c_int) as isize) as libc::c_int
                        != 0 as libc::c_int
                {
                    h += 1;
                }
                h += 1;
            }
            if *zLine.offset(h as isize) as libc::c_int == delim {
                let fresh78 = h;
                h = h + 1;
                *zLine.offset(fresh78 as isize) = 0 as libc::c_int as libc::c_char;
            }
            if delim == '"' as i32 {
                resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
            }
        } else {
            let fresh79 = nArg;
            nArg = nArg + 1;
            azArg[fresh79
                as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *(*__ctype_b_loc())
                    .offset(
                        *zLine.offset(h as isize) as libc::c_uchar as libc::c_int
                            as isize,
                    ) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int == 0
            {
                h += 1;
            }
            if *zLine.offset(h as isize) != 0 {
                let fresh80 = h;
                h = h + 1;
                *zLine.offset(fresh80 as isize) = 0 as libc::c_int as libc::c_char;
            }
            resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
        }
    }
    azArg[nArg as usize] = 0 as *mut libc::c_char;
    if nArg == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    n = strlen30(azArg[0 as libc::c_int as usize]);
    c = *(azArg[0 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
        as libc::c_int;
    clearTempFile(p);
    if c == 'a' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"auth\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .auth ON|OFF\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            if booleanValue(azArg[1 as libc::c_int as usize]) != 0 {
                sqlite3_set_authorizer(
                    (*p).db,
                    Some(
                        shellAuth
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            } else if (*p).bSafeModePersist != 0 {
                sqlite3_set_authorizer(
                    (*p).db,
                    Some(
                        safeModeAuth
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            } else {
                sqlite3_set_authorizer((*p).db, None, 0 as *mut libc::c_void);
            }
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"backup\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
        || c == 's' as i32 && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"save\0" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
    {
        let mut zDestFile: *const libc::c_char = 0 as *const libc::c_char;
        let mut zDb: *const libc::c_char = 0 as *const libc::c_char;
        let mut pDest: *mut sqlite3 = 0 as *mut sqlite3;
        let mut pBackup: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
        let mut j: libc::c_int = 0;
        let mut bAsync: libc::c_int = 0 as libc::c_int;
        let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        j = 1 as libc::c_int;
        while j < nArg {
            let mut z: *const libc::c_char = azArg[j as usize];
            if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z = z.offset(1);
                }
                if strcmp(z, b"-append\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zVfs = b"apndvfs\0" as *const u8 as *const libc::c_char;
                } else if strcmp(z, b"-async\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bAsync = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                        azArg[j as usize],
                    );
                    return 1 as libc::c_int;
                }
            } else if zDestFile.is_null() {
                zDestFile = azArg[j as usize];
            } else if zDb.is_null() {
                zDb = zDestFile;
                zDestFile = azArg[j as usize];
            } else {
                fprintf(
                    stderr,
                    b"Usage: .backup ?DB? ?OPTIONS? FILENAME\n\0" as *const u8
                        as *const libc::c_char,
                );
                return 1 as libc::c_int;
            }
            j += 1;
        }
        if zDestFile.is_null() {
            fprintf(
                stderr,
                b"missing FILENAME argument on .backup\n\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        if zDb.is_null() {
            zDb = b"main\0" as *const u8 as *const libc::c_char;
        }
        rc = sqlite3_open_v2(
            zDestFile,
            &mut pDest,
            0x2 as libc::c_int | 0x4 as libc::c_int,
            zVfs,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zDestFile,
            );
            close_db(pDest);
            return 1 as libc::c_int;
        }
        if bAsync != 0 {
            sqlite3_exec(
                pDest,
                b"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\0" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
        }
        open_db(p, 0 as libc::c_int);
        pBackup = sqlite3_backup_init(
            pDest,
            b"main\0" as *const u8 as *const libc::c_char,
            (*p).db,
            zDb,
        );
        if pBackup.is_null() {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(pDest),
            );
            close_db(pDest);
            return 1 as libc::c_int;
        }
        loop {
            rc = sqlite3_backup_step(pBackup, 100 as libc::c_int);
            if !(rc == 0 as libc::c_int) {
                break;
            }
        }
        sqlite3_backup_finish(pBackup);
        if rc == 101 as libc::c_int {
            rc = 0 as libc::c_int;
        } else {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(pDest),
            );
            rc = 1 as libc::c_int;
        }
        close_db(pDest);
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"bail\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            bail_on_error = booleanValue(azArg[1 as libc::c_int as usize]);
        } else {
            fprintf(
                stderr,
                b"Usage: .bail on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"binary\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            booleanValue(azArg[1 as libc::c_int as usize]) != 0;
        } else {
            fprintf(
                stderr,
                b"Usage: .binary on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"breakpoint\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        test_breakpoint();
    } else if c == 'c' as i32
        && strcmp(
            azArg[0 as libc::c_int as usize],
            b"cd\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .cd in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            rc = chdir(azArg[1 as libc::c_int as usize]);
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Cannot change to directory \"%s\"\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                rc = 1 as libc::c_int;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .cd DIRECTORY\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"changes\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            setOrClearFlag(
                p,
                0x20 as libc::c_int as libc::c_uint,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .changes on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"check\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zRes: *mut libc::c_char = 0 as *mut libc::c_char;
        output_reset(p);
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .check GLOB-PATTERN\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 2 as libc::c_int;
        } else {
            zRes = readFile(
                b"testcase-out.txt\0" as *const u8 as *const libc::c_char,
                0 as *mut libc::c_int,
            );
            if zRes.is_null() {
                fprintf(
                    stderr,
                    b"Error: cannot read 'testcase-out.txt'\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 2 as libc::c_int;
            } else if testcase_glob(azArg[1 as libc::c_int as usize], zRes)
                == 0 as libc::c_int
            {
                fprintf(
                    stderr,
                    b"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n\0"
                        as *const u8 as *const libc::c_char,
                    ((*p).zTestcase).as_mut_ptr(),
                    azArg[1 as libc::c_int as usize],
                    zRes,
                );
                rc = 1 as libc::c_int;
            } else {
                fprintf(
                    stdout,
                    b"testcase-%s ok\n\0" as *const u8 as *const libc::c_char,
                    ((*p).zTestcase).as_mut_ptr(),
                );
                (*p).nCheck += 1;
            }
        }
        sqlite3_free(zRes as *mut libc::c_void);
    } else if c == 'c' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"clone\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .clone in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            tryToClone(p, azArg[1 as libc::c_int as usize]);
        } else {
            fprintf(
                stderr,
                b"Usage: .clone FILENAME\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"connection\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 1 as libc::c_int {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
                    as libc::c_int
            {
                let mut zFile: *const libc::c_char = (*p).aAuxDb[i as usize].zDbFilename;
                if ((*p).aAuxDb[i as usize].db).is_null()
                    && (*p).pAuxDb
                        != &mut *((*p).aAuxDb).as_mut_ptr().offset(i as isize)
                            as *mut AuxDb
                {
                    zFile = b"(not open)\0" as *const u8 as *const libc::c_char;
                } else if zFile.is_null() {
                    zFile = b"(memory)\0" as *const u8 as *const libc::c_char;
                } else if *zFile.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
                {
                    zFile = b"(temporary-file)\0" as *const u8 as *const libc::c_char;
                }
                if (*p).pAuxDb
                    == &mut *((*p).aAuxDb).as_mut_ptr().offset(i as isize) as *mut AuxDb
                {
                    fprintf(
                        stdout,
                        b"ACTIVE %d: %s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        zFile,
                    );
                } else if !((*p).aAuxDb[i as usize].db).is_null() {
                    fprintf(
                        stdout,
                        b"       %d: %s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        zFile,
                    );
                }
                i += 1;
            }
        } else if nArg == 2 as libc::c_int
            && *(*__ctype_b_loc())
                .offset(
                    *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            && *(azArg[1 as libc::c_int as usize]).offset(1 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            let mut i_0: libc::c_int = *(azArg[1 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32;
            if (*p).pAuxDb
                != &mut *((*p).aAuxDb).as_mut_ptr().offset(i_0 as isize) as *mut AuxDb
                && i_0 >= 0 as libc::c_int
                && i_0
                    < (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int
            {
                (*(*p).pAuxDb).db = (*p).db;
                (*p)
                    .pAuxDb = &mut *((*p).aAuxDb).as_mut_ptr().offset(i_0 as isize)
                    as *mut AuxDb;
                (*p).db = (*(*p).pAuxDb).db;
                globalDb = (*p).db;
                (*(*p).pAuxDb).db = 0 as *mut sqlite3;
            }
        } else if nArg == 3 as libc::c_int
            && strcmp(
                azArg[1 as libc::c_int as usize],
                b"close\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            && *(*__ctype_b_loc())
                .offset(
                    *(azArg[2 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            && *(azArg[2 as libc::c_int as usize]).offset(1 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            let mut i_1: libc::c_int = *(azArg[2 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32;
            if !(i_1 < 0 as libc::c_int
                || i_1
                    >= (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int)
            {
                if (*p).pAuxDb
                    == &mut *((*p).aAuxDb).as_mut_ptr().offset(i_1 as isize)
                        as *mut AuxDb
                {
                    fprintf(
                        stderr,
                        b"cannot close the active database connection\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                } else if !((*p).aAuxDb[i_1 as usize].db).is_null() {
                    close_db((*p).aAuxDb[i_1 as usize].db);
                    (*p).aAuxDb[i_1 as usize].db = 0 as *mut sqlite3;
                }
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .connection [close] [CONNECTION-NUMBER]\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'd' as i32 && n > 1 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"databases\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut azName: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut nName: libc::c_int = 0 as libc::c_int;
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut i_2: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg((*p).db),
            );
            rc = 1 as libc::c_int;
        } else {
            while sqlite3_step(pStmt) == 100 as libc::c_int {
                let mut zSchema: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                let mut zFile_0: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    2 as libc::c_int,
                ) as *const libc::c_char;
                if zSchema.is_null() || zFile_0.is_null() {
                    continue;
                }
                azName = sqlite3_realloc(
                    azName as *mut libc::c_void,
                    (((nName + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                        ) as libc::c_int,
                ) as *mut *mut libc::c_char;
                shell_check_oom(azName as *mut libc::c_void);
                let ref mut fresh81 = *azName
                    .offset((nName * 2 as libc::c_int) as isize);
                *fresh81 = strdup(zSchema);
                let ref mut fresh82 = *azName
                    .offset((nName * 2 as libc::c_int + 1 as libc::c_int) as isize);
                *fresh82 = strdup(zFile_0);
                nName += 1;
            }
        }
        sqlite3_finalize(pStmt);
        i_2 = 0 as libc::c_int;
        while i_2 < nName {
            let mut eTxn: libc::c_int = sqlite3_txn_state(
                (*p).db,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
            );
            let mut bRdonly: libc::c_int = sqlite3_db_readonly(
                (*p).db,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
            );
            let mut z_0: *const libc::c_char = *azName
                .offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize);
            fprintf(
                (*p).out,
                b"%s: %s %s%s\n\0" as *const u8 as *const libc::c_char,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
                if !z_0.is_null()
                    && *z_0.offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    z_0
                } else {
                    b"\"\"\0" as *const u8 as *const libc::c_char
                },
                if bRdonly != 0 {
                    b"r/o\0" as *const u8 as *const libc::c_char
                } else {
                    b"r/w\0" as *const u8 as *const libc::c_char
                },
                if eTxn == 0 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else if eTxn == 1 as libc::c_int {
                    b" read-txn\0" as *const u8 as *const libc::c_char
                } else {
                    b" write-txn\0" as *const u8 as *const libc::c_char
                },
            );
            free(*azName.offset((i_2 * 2 as libc::c_int) as isize) as *mut libc::c_void);
            free(
                *azName.offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize)
                    as *mut libc::c_void,
            );
            i_2 += 1;
        }
        sqlite3_free(azName as *mut libc::c_void);
    } else if c == 'd' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"dbconfig\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        static mut aDbConfig: [DbConfigChoices; 16] = [
            {
                let mut init = DbConfigChoices {
                    zName: b"defensive\0" as *const u8 as *const libc::c_char,
                    op: 1010 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"dqs_ddl\0" as *const u8 as *const libc::c_char,
                    op: 1014 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"dqs_dml\0" as *const u8 as *const libc::c_char,
                    op: 1013 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_fkey\0" as *const u8 as *const libc::c_char,
                    op: 1002 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_qpsg\0" as *const u8 as *const libc::c_char,
                    op: 1007 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_trigger\0" as *const u8 as *const libc::c_char,
                    op: 1003 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_view\0" as *const u8 as *const libc::c_char,
                    op: 1015 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"fts3_tokenizer\0" as *const u8 as *const libc::c_char,
                    op: 1004 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"legacy_alter_table\0" as *const u8 as *const libc::c_char,
                    op: 1012 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"legacy_file_format\0" as *const u8 as *const libc::c_char,
                    op: 1016 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"load_extension\0" as *const u8 as *const libc::c_char,
                    op: 1005 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"no_ckpt_on_close\0" as *const u8 as *const libc::c_char,
                    op: 1006 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"reset_database\0" as *const u8 as *const libc::c_char,
                    op: 1009 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"trigger_eqp\0" as *const u8 as *const libc::c_char,
                    op: 1008 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"trusted_schema\0" as *const u8 as *const libc::c_char,
                    op: 1017 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"writable_schema\0" as *const u8 as *const libc::c_char,
                    op: 1011 as libc::c_int,
                };
                init
            },
        ];
        let mut ii: libc::c_int = 0;
        let mut v: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        ii = 0 as libc::c_int;
        while ii
            < (::core::mem::size_of::<[DbConfigChoices; 16]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<DbConfigChoices>() as libc::c_ulong)
                as libc::c_int
        {
            if !(nArg > 1 as libc::c_int
                && strcmp(azArg[1 as libc::c_int as usize], aDbConfig[ii as usize].zName)
                    != 0 as libc::c_int)
            {
                if nArg >= 3 as libc::c_int {
                    sqlite3_db_config(
                        (*p).db,
                        aDbConfig[ii as usize].op,
                        booleanValue(azArg[2 as libc::c_int as usize]),
                        0 as libc::c_int,
                    );
                }
                sqlite3_db_config(
                    (*p).db,
                    aDbConfig[ii as usize].op,
                    -(1 as libc::c_int),
                    &mut v as *mut libc::c_int,
                );
                fprintf(
                    (*p).out,
                    b"%19s %s\n\0" as *const u8 as *const libc::c_char,
                    aDbConfig[ii as usize].zName,
                    if v != 0 {
                        b"on\0" as *const u8 as *const libc::c_char
                    } else {
                        b"off\0" as *const u8 as *const libc::c_char
                    },
                );
                if nArg > 1 as libc::c_int {
                    break;
                }
            }
            ii += 1;
        }
        if nArg > 1 as libc::c_int
            && ii
                == (::core::mem::size_of::<[DbConfigChoices; 16]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<DbConfigChoices>() as libc::c_ulong,
                    ) as libc::c_int
        {
            fprintf(
                stderr,
                b"Error: unknown dbconfig \"%s\"\n\0" as *const u8
                    as *const libc::c_char,
                azArg[1 as libc::c_int as usize],
            );
            fprintf(
                stderr,
                b"Enter \".dbconfig\" with no arguments for a list\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else if c == 'd' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"dump\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zLike: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut i_3: libc::c_int = 0;
        let mut savedShowHeader: libc::c_int = (*p).showHeader;
        let mut savedShellFlags: libc::c_int = (*p).shellFlgs as libc::c_int;
        (*p).shellFlgs
            &= !(0x8 as libc::c_int | 0x10 as libc::c_int | 0x40 as libc::c_int
                | 0x100 as libc::c_int | 0x200 as libc::c_int) as libc::c_uint;
        i_3 = 1 as libc::c_int;
        loop {
            if !(i_3 < nArg) {
                current_block = 13714309095952152938;
                break;
            }
            if *(azArg[i_3 as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '-' as i32
            {
                let mut z_1: *const libc::c_char = (azArg[i_3 as usize])
                    .offset(1 as libc::c_int as isize);
                if *z_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_1 = z_1.offset(1);
                }
                if strcmp(z_1, b"preserve-rowids\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x8 as libc::c_int as libc::c_uint;
                } else if strcmp(z_1, b"newlines\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x10 as libc::c_int as libc::c_uint;
                } else if strcmp(z_1, b"data-only\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x100 as libc::c_int as libc::c_uint;
                } else if strcmp(z_1, b"nosys\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x200 as libc::c_int as libc::c_uint;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \".dump\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_3 as usize],
                    );
                    rc = 1 as libc::c_int;
                    sqlite3_free(zLike as *mut libc::c_void);
                    current_block = 5240171864706220143;
                    break;
                }
            } else {
                let mut zExpr: *mut libc::c_char = sqlite3_mprintf(
                    b"name LIKE %Q ESCAPE '\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE '\\' AND    sql LIKE 'CREATE VIRTUAL TABLE%%' AND    substr(o.name, 1, length(name)+1) == (name||'_'))\0"
                        as *const u8 as *const libc::c_char,
                    azArg[i_3 as usize],
                    azArg[i_3 as usize],
                );
                if !zLike.is_null() {
                    zLike = sqlite3_mprintf(
                        b"%z OR %z\0" as *const u8 as *const libc::c_char,
                        zLike,
                        zExpr,
                    );
                } else {
                    zLike = zExpr;
                }
            }
            i_3 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                open_db(p, 0 as libc::c_int);
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*p).out,
                        b"PRAGMA foreign_keys=OFF;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"BEGIN TRANSACTION;\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                (*p).writableSchema = 0 as libc::c_int;
                (*p).showHeader = 0 as libc::c_int;
                sqlite3_exec(
                    (*p).db,
                    b"SAVEPOINT dump; PRAGMA writable_schema=ON\0" as *const u8
                        as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                (*p).nErr = 0 as libc::c_int;
                if zLike.is_null() {
                    zLike = sqlite3_mprintf(
                        b"true\0" as *const u8 as *const libc::c_char,
                    );
                }
                zSql = sqlite3_mprintf(
                    b"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type=='table'  AND sql NOT NULL ORDER BY tbl_name='sqlite_sequence', rowid\0"
                        as *const u8 as *const libc::c_char,
                    zLike,
                );
                run_schema_dump_query(p, zSql);
                sqlite3_free(zSql as *mut libc::c_void);
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    zSql = sqlite3_mprintf(
                        b"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN ('index','trigger','view')\0"
                            as *const u8 as *const libc::c_char,
                        zLike,
                    );
                    run_table_dump_query(p, zSql);
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                sqlite3_free(zLike as *mut libc::c_void);
                if (*p).writableSchema != 0 {
                    fprintf(
                        (*p).out,
                        b"PRAGMA writable_schema=OFF;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*p).writableSchema = 0 as libc::c_int;
                }
                sqlite3_exec(
                    (*p).db,
                    b"PRAGMA writable_schema=OFF;\0" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_exec(
                    (*p).db,
                    b"RELEASE dump;\0" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*p).out,
                        if (*p).nErr != 0 {
                            b"ROLLBACK; -- due to errors\n\0" as *const u8
                                as *const libc::c_char
                        } else {
                            b"COMMIT;\n\0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                (*p).showHeader = savedShowHeader;
                (*p).shellFlgs = savedShellFlags as libc::c_uint;
            }
        }
    } else if c == 'e' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"echo\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            setOrClearFlag(
                p,
                0x40 as libc::c_int as libc::c_uint,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .echo on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'e' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"eqp\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).autoEQPtest = 0 as libc::c_int as u8_0;
            if (*p).autoEQPtrace != 0 {
                if !((*p).db).is_null() {
                    sqlite3_exec(
                        (*p).db,
                        b"PRAGMA vdbe_trace=OFF;\0" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                }
                (*p).autoEQPtrace = 0 as libc::c_int as u8_0;
            }
            if strcmp(
                azArg[1 as libc::c_int as usize],
                b"full\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).autoEQP = 3 as libc::c_int as u8_0;
            } else if strcmp(
                azArg[1 as libc::c_int as usize],
                b"trigger\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).autoEQP = 2 as libc::c_int as u8_0;
            } else {
                (*p).autoEQP = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .eqp off|on|trace|trigger|full\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'e' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"exit\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg > 1 as libc::c_int
            && {
                rc = integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int;
                rc != 0 as libc::c_int
            }
        {
            exit(rc);
        }
        rc = 2 as libc::c_int;
    } else if c == 'e' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"explain\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut val: libc::c_int = 1 as libc::c_int;
        if nArg >= 2 as libc::c_int {
            if strcmp(
                azArg[1 as libc::c_int as usize],
                b"auto\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                val = 99 as libc::c_int;
            } else {
                val = booleanValue(azArg[1 as libc::c_int as usize]);
            }
        }
        if val == 1 as libc::c_int && (*p).mode != 9 as libc::c_int {
            (*p).normalMode = (*p).mode;
            (*p).mode = 9 as libc::c_int;
            (*p).autoExplain = 0 as libc::c_int as u8_0;
        } else if val == 0 as libc::c_int {
            if (*p).mode == 9 as libc::c_int {
                (*p).mode = (*p).normalMode;
            }
            (*p).autoExplain = 0 as libc::c_int as u8_0;
        } else if val == 99 as libc::c_int {
            if (*p).mode == 9 as libc::c_int {
                (*p).mode = (*p).normalMode;
            }
            (*p).autoExplain = 1 as libc::c_int as u8_0;
        }
    } else if c == 'e' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"expert\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if (*p).bSafeMode != 0 {
            fprintf(
                stderr,
                b"Cannot run experimental commands such as \"%s\" in safe mode\n\0"
                    as *const u8 as *const libc::c_char,
                azArg[0 as libc::c_int as usize],
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            expertDotCommand(p, azArg.as_mut_ptr(), nArg);
        }
    } else if c == 'f' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"filectrl\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        static mut aCtrl: [C2RustUnnamed_21; 9] = [
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"chunk_size\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 6 as libc::c_int,
                    zUsage: b"SIZE\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"data_version\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 35 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"has_moved\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 20 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"lock_timeout\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 34 as libc::c_int,
                    zUsage: b"MILLISEC\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"persist_wal\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 10 as libc::c_int,
                    zUsage: b"[BOOLEAN]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"psow\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 13 as libc::c_int,
                    zUsage: b"[BOOLEAN]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"reserve_bytes\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 38 as libc::c_int,
                    zUsage: b"[N]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"size_limit\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 36 as libc::c_int,
                    zUsage: b"[LIMIT]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"tempfilename\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 16 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
        ];
        let mut filectrl: libc::c_int = -(1 as libc::c_int);
        let mut iCtrl: libc::c_int = -(1 as libc::c_int);
        let mut iRes: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut isOk: libc::c_int = 0 as libc::c_int;
        let mut n2: libc::c_int = 0;
        let mut i_4: libc::c_int = 0;
        let mut zCmd: *const libc::c_char = 0 as *const libc::c_char;
        let mut zSchema_0: *const libc::c_char = 0 as *const libc::c_char;
        open_db(p, 0 as libc::c_int);
        zCmd = if nArg >= 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"help\0" as *const u8 as *const libc::c_char
        };
        if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && (strcmp(zCmd, b"--schema\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
                || strcmp(zCmd, b"-schema\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int) && nArg >= 4 as libc::c_int
        {
            zSchema_0 = azArg[2 as libc::c_int as usize];
            i_4 = 3 as libc::c_int;
            while i_4 < nArg {
                azArg[(i_4 - 2 as libc::c_int) as usize] = azArg[i_4 as usize];
                i_4 += 1;
            }
            nArg -= 2 as libc::c_int;
            zCmd = azArg[1 as libc::c_int as usize];
        }
        if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
        {
            zCmd = zCmd.offset(1);
            if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd = zCmd.offset(1);
            }
        }
        if strcmp(zCmd, b"help\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"Available file-controls:\n\0" as *const u8 as *const libc::c_char,
            );
            i_4 = 0 as libc::c_int;
            while i_4
                < (::core::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong,
                    ) as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"  .filectrl %s %s\n\0" as *const u8 as *const libc::c_char,
                    aCtrl[i_4 as usize].zCtrlName,
                    aCtrl[i_4 as usize].zUsage,
                );
                i_4 += 1;
            }
            rc = 1 as libc::c_int;
        } else {
            n2 = strlen30(zCmd);
            i_4 = 0 as libc::c_int;
            loop {
                if !(i_4
                    < (::core::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 15508192053828812388;
                    break;
                }
                if strncmp(zCmd, aCtrl[i_4 as usize].zCtrlName, n2 as libc::c_ulong)
                    == 0 as libc::c_int
                {
                    if filectrl < 0 as libc::c_int {
                        filectrl = aCtrl[i_4 as usize].ctrlCode;
                        iCtrl = i_4;
                    } else {
                        fprintf(
                            stderr,
                            b"Error: ambiguous file-control: \"%s\"\nUse \".filectrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 5240171864706220143;
                        break;
                    }
                }
                i_4 += 1;
            }
            match current_block {
                5240171864706220143 => {}
                _ => {
                    if filectrl < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: unknown file-control: %s\nUse \".filectrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd,
                        );
                    } else {
                        match filectrl {
                            36 => {
                                if !(nArg != 2 as libc::c_int && nArg != 3 as libc::c_int) {
                                    iRes = if nArg == 3 as libc::c_int {
                                        integerValue(azArg[2 as libc::c_int as usize])
                                    } else {
                                        -(1 as libc::c_int) as libc::c_longlong
                                    };
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        36 as libc::c_int,
                                        &mut iRes as *mut sqlite3_int64 as *mut libc::c_void,
                                    );
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            34 | 6 => {
                                let mut x: libc::c_int = 0;
                                if !(nArg != 3 as libc::c_int) {
                                    x = integerValue(azArg[2 as libc::c_int as usize])
                                        as libc::c_int;
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    isOk = 2 as libc::c_int;
                                }
                            }
                            10 | 13 => {
                                let mut x_0: libc::c_int = 0;
                                if !(nArg != 2 as libc::c_int && nArg != 3 as libc::c_int) {
                                    x_0 = if nArg == 3 as libc::c_int {
                                        booleanValue(azArg[2 as libc::c_int as usize])
                                    } else {
                                        -(1 as libc::c_int)
                                    };
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_0 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    iRes = x_0 as sqlite3_int64;
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            35 | 20 => {
                                let mut x_1: libc::c_int = 0;
                                if !(nArg != 2 as libc::c_int) {
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_1 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    iRes = x_1 as sqlite3_int64;
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            16 => {
                                let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                if !(nArg != 2 as libc::c_int) {
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut z_2 as *mut *mut libc::c_char as *mut libc::c_void,
                                    );
                                    if !z_2.is_null() {
                                        fprintf(
                                            (*p).out,
                                            b"%s\n\0" as *const u8 as *const libc::c_char,
                                            z_2,
                                        );
                                        sqlite3_free(z_2 as *mut libc::c_void);
                                    }
                                    isOk = 2 as libc::c_int;
                                }
                            }
                            38 => {
                                let mut x_2: libc::c_int = 0;
                                if nArg >= 3 as libc::c_int {
                                    x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                }
                                x_2 = -(1 as libc::c_int);
                                sqlite3_file_control(
                                    (*p).db,
                                    zSchema_0,
                                    filectrl,
                                    &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%d\n\0" as *const u8 as *const libc::c_char,
                                    x_2,
                                );
                                isOk = 2 as libc::c_int;
                            }
                            _ => {}
                        }
                    }
                    if isOk == 0 as libc::c_int && iCtrl >= 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Usage: .filectrl %s %s\n\0" as *const u8
                                as *const libc::c_char,
                            zCmd,
                            aCtrl[iCtrl as usize].zUsage,
                        );
                        rc = 1 as libc::c_int;
                    } else if isOk == 1 as libc::c_int {
                        let mut zBuf: [libc::c_char; 100] = [0; 100];
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 100]>()
                                as libc::c_ulong as libc::c_int,
                            zBuf.as_mut_ptr(),
                            b"%lld\0" as *const u8 as *const libc::c_char,
                            iRes,
                        );
                        fprintf(
                            (*p).out,
                            b"%s\n\0" as *const u8 as *const libc::c_char,
                            zBuf.as_mut_ptr(),
                        );
                    }
                }
            }
        }
    } else if c == 'f' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"fullschema\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut data: ShellState = ShellState {
            db: 0 as *mut sqlite3,
            autoExplain: 0,
            autoEQP: 0,
            autoEQPtest: 0,
            autoEQPtrace: 0,
            scanstatsOn: 0,
            openMode: 0,
            doXdgOpen: 0,
            nEqpLevel: 0,
            eTraceType: 0,
            bSafeMode: 0,
            bSafeModePersist: 0,
            cmOpts: ColModeOpts {
                iWrap: 0,
                bQuote: 0,
                bWordWrap: 0,
            },
            statsOn: 0,
            mEqpLines: 0,
            inputNesting: 0,
            outCount: 0,
            cnt: 0,
            lineno: 0,
            openFlags: 0,
            in_0: 0 as *mut FILE,
            out: 0 as *mut FILE,
            traceOut: 0 as *mut FILE,
            nErr: 0,
            mode: 0,
            modePrior: 0,
            cMode: 0,
            normalMode: 0,
            writableSchema: 0,
            showHeader: 0,
            nCheck: 0,
            nProgress: 0,
            mxProgress: 0,
            flgProgress: 0,
            shellFlgs: 0,
            priorShFlgs: 0,
            szMax: 0,
            zDestTable: 0 as *mut libc::c_char,
            zTempFile: 0 as *mut libc::c_char,
            zTestcase: [0; 30],
            colSeparator: [0; 20],
            rowSeparator: [0; 20],
            colSepPrior: [0; 20],
            rowSepPrior: [0; 20],
            colWidth: 0 as *mut libc::c_int,
            actualWidth: 0 as *mut libc::c_int,
            nWidth: 0,
            nullValue: [0; 20],
            outfile: [0; 4096],
            pStmt: 0 as *mut sqlite3_stmt,
            pLog: 0 as *mut FILE,
            aAuxDb: [AuxDb {
                db: 0 as *mut sqlite3,
                zDbFilename: 0 as *const libc::c_char,
                zFreeOnClose: 0 as *mut libc::c_char,
            }; 5],
            pAuxDb: 0 as *mut AuxDb,
            aiIndent: 0 as *mut libc::c_int,
            nIndent: 0,
            iIndent: 0,
            zNonce: 0 as *mut libc::c_char,
            sGraph: EQPGraph {
                pRow: 0 as *mut EQPGraphRow,
                pLast: 0 as *mut EQPGraphRow,
                zPrefix: [0; 100],
            },
            expert: ExpertInfo {
                pExpert: 0 as *mut sqlite3expert,
                bVerbose: 0,
            },
        };
        let mut doStats: libc::c_int = 0 as libc::c_int;
        memcpy(
            &mut data as *mut ShellState as *mut libc::c_void,
            p as *const libc::c_void,
            ::core::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        data.showHeader = 0 as libc::c_int;
        data.mode = 3 as libc::c_int;
        data.cMode = data.mode;
        if nArg == 2 as libc::c_int
            && optionMatch(
                azArg[1 as libc::c_int as usize],
                b"indent\0" as *const u8 as *const libc::c_char,
            ) != 0
        {
            data.mode = 11 as libc::c_int;
            data.cMode = data.mode;
            nArg = 1 as libc::c_int;
        }
        if nArg != 1 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .fullschema ?--indent?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_exec(
                (*p).db,
                b"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' ORDER BY x\0"
                    as *const u8 as *const libc::c_char,
                Some(
                    callback
                        as unsafe extern "C" fn(
                            *mut libc::c_void,
                            libc::c_int,
                            *mut *mut libc::c_char,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                &mut data as *mut ShellState as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                let mut pStmt_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT rowid FROM sqlite_schema WHERE name GLOB 'sqlite_stat[134]'\0"
                        as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_0,
                    0 as *mut *const libc::c_char,
                );
                doStats = (sqlite3_step(pStmt_0) == 100 as libc::c_int) as libc::c_int;
                sqlite3_finalize(pStmt_0);
            }
            if doStats == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"/* No STAT tables available */\n\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
                );
                data.mode = 5 as libc::c_int;
                data.cMode = data.mode;
                data
                    .zDestTable = b"sqlite_stat1\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                shell_exec(
                    &mut data,
                    b"SELECT * FROM sqlite_stat1\0" as *const u8 as *const libc::c_char,
                    0 as *mut *mut libc::c_char,
                );
                data
                    .zDestTable = b"sqlite_stat4\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                shell_exec(
                    &mut data,
                    b"SELECT * FROM sqlite_stat4\0" as *const u8 as *const libc::c_char,
                    0 as *mut *mut libc::c_char,
                );
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    } else if c == 'h' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"headers\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).showHeader = booleanValue(azArg[1 as libc::c_int as usize]);
            (*p).shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
        } else {
            fprintf(
                stderr,
                b"Usage: .headers on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'h' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"help\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg >= 2 as libc::c_int {
            n = showHelp((*p).out, azArg[1 as libc::c_int as usize]);
            if n == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"Nothing matches '%s'\n\0" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
            }
        } else {
            showHelp((*p).out, 0 as *const libc::c_char);
        }
    } else if c == 'i' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"import\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zTable: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSchema_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zFile_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pStmt_1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut nCol: libc::c_int = 0;
        let mut nByte: libc::c_int = 0;
        let mut i_5: libc::c_int = 0;
        let mut j_0: libc::c_int = 0;
        let mut needCommit: libc::c_int = 0;
        let mut nSep: libc::c_int = 0;
        let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zFullTabName: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut sCtx: ImportCtx = ImportCtx {
            zFile: 0 as *const libc::c_char,
            in_0: 0 as *mut FILE,
            xCloser: None,
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
            nLine: 0,
            nRow: 0,
            nErr: 0,
            bNotFirst: 0,
            cTerm: 0,
            cColSep: 0,
            cRowSep: 0,
        };
        let mut xRead: Option::<
            unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
        > = None;
        let mut eVerbose: libc::c_int = 0 as libc::c_int;
        let mut nSkip: libc::c_int = 0 as libc::c_int;
        let mut useOutputMode: libc::c_int = 1 as libc::c_int;
        let mut zCreate: *mut libc::c_char = 0 as *mut libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .import in safe mode\0" as *const u8 as *const libc::c_char,
        );
        memset(
            &mut sCtx as *mut ImportCtx as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<ImportCtx>() as libc::c_ulong,
        );
        if (*p).mode == 10 as libc::c_int {
            xRead = Some(
                ascii_read_one_field
                    as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
            );
        } else {
            xRead = Some(
                csv_read_one_field
                    as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
            );
        }
        rc = 1 as libc::c_int;
        i_5 = 1 as libc::c_int;
        loop {
            if !(i_5 < nArg) {
                current_block = 5946490239152004759;
                break;
            }
            let mut z_3: *mut libc::c_char = azArg[i_5 as usize];
            if *z_3.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *z_3.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                z_3 = z_3.offset(1);
            }
            if *z_3.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                if zFile_1.is_null() {
                    zFile_1 = z_3;
                } else if zTable.is_null() {
                    zTable = z_3;
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: extra argument: \"%s\".  Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        z_3,
                    );
                    showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                    current_block = 5240171864706220143;
                    break;
                }
            } else if strcmp(z_3, b"-v\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                eVerbose += 1;
            } else if strcmp(z_3, b"-schema\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && i_5 < nArg - 1 as libc::c_int
            {
                i_5 += 1;
                zSchema_1 = azArg[i_5 as usize];
            } else if strcmp(z_3, b"-skip\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && i_5 < nArg - 1 as libc::c_int
            {
                i_5 += 1;
                nSkip = integerValue(azArg[i_5 as usize]) as libc::c_int;
            } else if strcmp(z_3, b"-ascii\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sCtx
                    .cColSep = (*::core::mem::transmute::<
                    &[u8; 2],
                    &[libc::c_char; 2],
                >(b"\x1F\0"))[0 as libc::c_int as usize] as libc::c_int;
                sCtx
                    .cRowSep = (*::core::mem::transmute::<
                    &[u8; 2],
                    &[libc::c_char; 2],
                >(b"\x1E\0"))[0 as libc::c_int as usize] as libc::c_int;
                xRead = Some(
                    ascii_read_one_field
                        as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
                );
                useOutputMode = 0 as libc::c_int;
            } else if strcmp(z_3, b"-csv\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sCtx.cColSep = ',' as i32;
                sCtx.cRowSep = '\n' as i32;
                xRead = Some(
                    csv_read_one_field
                        as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
                );
                useOutputMode = 0 as libc::c_int;
            } else {
                fprintf(
                    (*p).out,
                    b"ERROR: unknown option: \"%s\".  Usage:\n\0" as *const u8
                        as *const libc::c_char,
                    z_3,
                );
                showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                current_block = 5240171864706220143;
                break;
            }
            i_5 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if zTable.is_null() {
                    fprintf(
                        (*p).out,
                        b"ERROR: missing %s argument. Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        if zFile_1.is_null() {
                            b"FILE\0" as *const u8 as *const libc::c_char
                        } else {
                            b"TABLE\0" as *const u8 as *const libc::c_char
                        },
                    );
                    showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                } else {
                    ::core::ptr::write_volatile(
                        &mut seenInterrupt as *mut libc::c_int,
                        0 as libc::c_int,
                    );
                    open_db(p, 0 as libc::c_int);
                    if useOutputMode != 0 {
                        nSep = strlen30(((*p).colSeparator).as_mut_ptr());
                        if nSep == 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: non-null column separator required for import\n\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 5240171864706220143;
                        } else if nSep > 1 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: multi-character column separators not allowed for import\n\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 5240171864706220143;
                        } else {
                            nSep = strlen30(((*p).rowSeparator).as_mut_ptr());
                            if nSep == 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: non-null row separator required for import\n\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                current_block = 5240171864706220143;
                            } else {
                                if nSep == 2 as libc::c_int && (*p).mode == 8 as libc::c_int
                                    && strcmp(
                                        ((*p).rowSeparator).as_mut_ptr(),
                                        b"\r\n\0" as *const u8 as *const libc::c_char,
                                    ) == 0 as libc::c_int
                                {
                                    sqlite3_snprintf(
                                        ::core::mem::size_of::<[libc::c_char; 20]>()
                                            as libc::c_ulong as libc::c_int,
                                        ((*p).rowSeparator).as_mut_ptr(),
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                    nSep = strlen30(((*p).rowSeparator).as_mut_ptr());
                                }
                                if nSep > 1 as libc::c_int {
                                    fprintf(
                                        stderr,
                                        b"Error: multi-character row separators not allowed for import\n\0"
                                            as *const u8 as *const libc::c_char,
                                    );
                                    current_block = 5240171864706220143;
                                } else {
                                    sCtx
                                        .cColSep = (*p).colSeparator[0 as libc::c_int as usize]
                                        as libc::c_int;
                                    sCtx
                                        .cRowSep = (*p).rowSeparator[0 as libc::c_int as usize]
                                        as libc::c_int;
                                    current_block = 6940122889508134762;
                                }
                            }
                        }
                    } else {
                        current_block = 6940122889508134762;
                    }
                    match current_block {
                        5240171864706220143 => {}
                        _ => {
                            sCtx.zFile = zFile_1;
                            sCtx.nLine = 1 as libc::c_int;
                            if *(sCtx.zFile).offset(0 as libc::c_int as isize)
                                as libc::c_int == '|' as i32
                            {
                                sCtx
                                    .in_0 = popen(
                                    (sCtx.zFile).offset(1 as libc::c_int as isize),
                                    b"r\0" as *const u8 as *const libc::c_char,
                                );
                                sCtx
                                    .zFile = b"<pipe>\0" as *const u8 as *const libc::c_char;
                                sCtx
                                    .xCloser = Some(
                                    pclose as unsafe extern "C" fn(*mut FILE) -> libc::c_int,
                                );
                            } else {
                                sCtx
                                    .in_0 = fopen(
                                    sCtx.zFile,
                                    b"rb\0" as *const u8 as *const libc::c_char,
                                );
                                sCtx
                                    .xCloser = Some(
                                    fclose as unsafe extern "C" fn(*mut FILE) -> libc::c_int,
                                );
                            }
                            if (sCtx.in_0).is_null() {
                                fprintf(
                                    stderr,
                                    b"Error: cannot open \"%s\"\n\0" as *const u8
                                        as *const libc::c_char,
                                    zFile_1,
                                );
                            } else {
                                if eVerbose >= 2 as libc::c_int
                                    || eVerbose >= 1 as libc::c_int && useOutputMode != 0
                                {
                                    let mut zSep: [libc::c_char; 2] = [0; 2];
                                    zSep[1 as libc::c_int
                                        as usize] = 0 as libc::c_int as libc::c_char;
                                    zSep[0 as libc::c_int
                                        as usize] = sCtx.cColSep as libc::c_char;
                                    fprintf(
                                        (*p).out,
                                        b"Column separator \0" as *const u8 as *const libc::c_char,
                                    );
                                    output_c_string((*p).out, zSep.as_mut_ptr());
                                    fprintf(
                                        (*p).out,
                                        b", row separator \0" as *const u8 as *const libc::c_char,
                                    );
                                    zSep[0 as libc::c_int
                                        as usize] = sCtx.cRowSep as libc::c_char;
                                    output_c_string((*p).out, zSep.as_mut_ptr());
                                    fprintf(
                                        (*p).out,
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                sCtx
                                    .z = sqlite3_malloc64(120 as libc::c_int as sqlite3_uint64)
                                    as *mut libc::c_char;
                                if (sCtx.z).is_null() {
                                    import_cleanup(&mut sCtx);
                                    shell_out_of_memory();
                                }
                                loop {
                                    let fresh83 = nSkip;
                                    nSkip = nSkip - 1;
                                    if !(fresh83 > 0 as libc::c_int) {
                                        break;
                                    }
                                    while !(xRead
                                        .expect("non-null function pointer")(&mut sCtx))
                                        .is_null() && sCtx.cTerm == sCtx.cColSep
                                    {}
                                }
                                if !zSchema_1.is_null() {
                                    zFullTabName = sqlite3_mprintf(
                                        b"\"%w\".\"%w\"\0" as *const u8 as *const libc::c_char,
                                        zSchema_1,
                                        zTable,
                                    );
                                } else {
                                    zFullTabName = sqlite3_mprintf(
                                        b"\"%w\"\0" as *const u8 as *const libc::c_char,
                                        zTable,
                                    );
                                }
                                zSql_0 = sqlite3_mprintf(
                                    b"SELECT * FROM %s\0" as *const u8 as *const libc::c_char,
                                    zFullTabName,
                                );
                                if zSql_0.is_null() || zFullTabName.is_null() {
                                    import_cleanup(&mut sCtx);
                                    shell_out_of_memory();
                                }
                                nByte = strlen30(zSql_0);
                                rc = sqlite3_prepare_v2(
                                    (*p).db,
                                    zSql_0,
                                    -(1 as libc::c_int),
                                    &mut pStmt_1,
                                    0 as *mut *const libc::c_char,
                                );
                                import_append_char(&mut sCtx, 0 as libc::c_int);
                                if rc != 0
                                    && sqlite3_strglob(
                                        b"no such table: *\0" as *const u8 as *const libc::c_char,
                                        sqlite3_errmsg((*p).db),
                                    ) == 0 as libc::c_int
                                {
                                    dbCols = 0 as *mut sqlite3;
                                    zRenames = 0 as *mut libc::c_char;
                                    zColDefs = 0 as *mut libc::c_char;
                                    zCreate = sqlite3_mprintf(
                                        b"CREATE TABLE %s\0" as *const u8 as *const libc::c_char,
                                        zFullTabName,
                                    );
                                    while !(xRead
                                        .expect("non-null function pointer")(&mut sCtx))
                                        .is_null()
                                    {
                                        zAutoColumn(
                                            sCtx.z,
                                            &mut dbCols,
                                            0 as *mut *mut libc::c_char,
                                        );
                                        if sCtx.cTerm != sCtx.cColSep {
                                            break;
                                        }
                                    }
                                    zColDefs = zAutoColumn(
                                        0 as *const libc::c_char,
                                        &mut dbCols,
                                        &mut zRenames,
                                    );
                                    if !zRenames.is_null() {
                                        fprintf(
                                            if stdin_is_interactive != 0 && (*p).in_0 == stdin {
                                                (*p).out
                                            } else {
                                                stderr
                                            },
                                            b"Columns renamed during .import %s due to duplicates:\n%s\n\0"
                                                as *const u8 as *const libc::c_char,
                                            sCtx.zFile,
                                            zRenames,
                                        );
                                        sqlite3_free(zRenames as *mut libc::c_void);
                                    }
                                    if dbCols.is_null() {} else {
                                        __assert_fail(
                                            b"dbCols==0\0" as *const u8 as *const libc::c_char,
                                            b"shell.c\0" as *const u8 as *const libc::c_char,
                                            20178 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 42],
                                                &[libc::c_char; 42],
                                            >(b"int do_meta_command(char *, ShellState *)\0"))
                                                .as_ptr(),
                                        );
                                    }
                                    if zColDefs.is_null() {
                                        fprintf(
                                            stderr,
                                            b"%s: empty file\n\0" as *const u8 as *const libc::c_char,
                                            sCtx.zFile,
                                        );
                                        current_block = 3776591993419627335;
                                    } else {
                                        zCreate = sqlite3_mprintf(
                                            b"%z%z\n\0" as *const u8 as *const libc::c_char,
                                            zCreate,
                                            zColDefs,
                                        );
                                        if eVerbose >= 1 as libc::c_int {
                                            fprintf(
                                                (*p).out,
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                zCreate,
                                            );
                                        }
                                        rc = sqlite3_exec(
                                            (*p).db,
                                            zCreate,
                                            None,
                                            0 as *mut libc::c_void,
                                            0 as *mut *mut libc::c_char,
                                        );
                                        if rc != 0 {
                                            fprintf(
                                                stderr,
                                                b"%s failed:\n%s\n\0" as *const u8 as *const libc::c_char,
                                                zCreate,
                                                sqlite3_errmsg((*p).db),
                                            );
                                            current_block = 3776591993419627335;
                                        } else {
                                            sqlite3_free(zCreate as *mut libc::c_void);
                                            zCreate = 0 as *mut libc::c_char;
                                            rc = sqlite3_prepare_v2(
                                                (*p).db,
                                                zSql_0,
                                                -(1 as libc::c_int),
                                                &mut pStmt_1,
                                                0 as *mut *const libc::c_char,
                                            );
                                            current_block = 4948376380723518226;
                                        }
                                    }
                                } else {
                                    current_block = 4948376380723518226;
                                }
                                match current_block {
                                    4948376380723518226 => {
                                        if rc != 0 {
                                            if !pStmt_1.is_null() {
                                                sqlite3_finalize(pStmt_1);
                                            }
                                            fprintf(
                                                stderr,
                                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                                sqlite3_errmsg((*p).db),
                                            );
                                            current_block = 3776591993419627335;
                                        } else {
                                            sqlite3_free(zSql_0 as *mut libc::c_void);
                                            nCol = sqlite3_column_count(pStmt_1);
                                            sqlite3_finalize(pStmt_1);
                                            pStmt_1 = 0 as *mut sqlite3_stmt;
                                            if nCol == 0 as libc::c_int {
                                                return 0 as libc::c_int;
                                            }
                                            zSql_0 = sqlite3_malloc64(
                                                (nByte * 2 as libc::c_int + 20 as libc::c_int
                                                    + nCol * 2 as libc::c_int) as sqlite3_uint64,
                                            ) as *mut libc::c_char;
                                            if zSql_0.is_null() {
                                                import_cleanup(&mut sCtx);
                                                shell_out_of_memory();
                                            }
                                            sqlite3_snprintf(
                                                nByte + 20 as libc::c_int,
                                                zSql_0,
                                                b"INSERT INTO %s VALUES(?\0" as *const u8
                                                    as *const libc::c_char,
                                                zFullTabName,
                                            );
                                            j_0 = strlen30(zSql_0);
                                            i_5 = 1 as libc::c_int;
                                            while i_5 < nCol {
                                                let fresh84 = j_0;
                                                j_0 = j_0 + 1;
                                                *zSql_0
                                                    .offset(fresh84 as isize) = ',' as i32 as libc::c_char;
                                                let fresh85 = j_0;
                                                j_0 = j_0 + 1;
                                                *zSql_0
                                                    .offset(fresh85 as isize) = '?' as i32 as libc::c_char;
                                                i_5 += 1;
                                            }
                                            let fresh86 = j_0;
                                            j_0 = j_0 + 1;
                                            *zSql_0
                                                .offset(fresh86 as isize) = ')' as i32 as libc::c_char;
                                            *zSql_0
                                                .offset(j_0 as isize) = 0 as libc::c_int as libc::c_char;
                                            if eVerbose >= 2 as libc::c_int {
                                                fprintf(
                                                    (*p).out,
                                                    b"Insert using: %s\n\0" as *const u8 as *const libc::c_char,
                                                    zSql_0,
                                                );
                                            }
                                            rc = sqlite3_prepare_v2(
                                                (*p).db,
                                                zSql_0,
                                                -(1 as libc::c_int),
                                                &mut pStmt_1,
                                                0 as *mut *const libc::c_char,
                                            );
                                            if rc != 0 {
                                                fprintf(
                                                    stderr,
                                                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                                    sqlite3_errmsg((*p).db),
                                                );
                                                if !pStmt_1.is_null() {
                                                    sqlite3_finalize(pStmt_1);
                                                }
                                                current_block = 3776591993419627335;
                                            } else {
                                                sqlite3_free(zSql_0 as *mut libc::c_void);
                                                sqlite3_free(zFullTabName as *mut libc::c_void);
                                                needCommit = sqlite3_get_autocommit((*p).db);
                                                if needCommit != 0 {
                                                    sqlite3_exec(
                                                        (*p).db,
                                                        b"BEGIN\0" as *const u8 as *const libc::c_char,
                                                        None,
                                                        0 as *mut libc::c_void,
                                                        0 as *mut *mut libc::c_char,
                                                    );
                                                }
                                                loop {
                                                    let mut startLine: libc::c_int = sCtx.nLine;
                                                    i_5 = 0 as libc::c_int;
                                                    while i_5 < nCol {
                                                        let mut z_4: *mut libc::c_char = xRead
                                                            .expect("non-null function pointer")(&mut sCtx);
                                                        if z_4.is_null() && i_5 == 0 as libc::c_int {
                                                            break;
                                                        }
                                                        if (*p).mode == 10 as libc::c_int
                                                            && (z_4.is_null()
                                                                || *z_4.offset(0 as libc::c_int as isize) as libc::c_int
                                                                    == 0 as libc::c_int) && i_5 == 0 as libc::c_int
                                                        {
                                                            break;
                                                        }
                                                        sqlite3_bind_text(
                                                            pStmt_1,
                                                            i_5 + 1 as libc::c_int,
                                                            z_4,
                                                            -(1 as libc::c_int),
                                                            ::core::mem::transmute::<
                                                                libc::intptr_t,
                                                                sqlite3_destructor_type,
                                                            >(-(1 as libc::c_int) as libc::intptr_t),
                                                        );
                                                        if i_5 < nCol - 1 as libc::c_int
                                                            && sCtx.cTerm != sCtx.cColSep
                                                        {
                                                            fprintf(
                                                                stderr,
                                                                b"%s:%d: expected %d columns but found %d - filling the rest with NULL\n\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                sCtx.zFile,
                                                                startLine,
                                                                nCol,
                                                                i_5 + 1 as libc::c_int,
                                                            );
                                                            i_5 += 2 as libc::c_int;
                                                            while i_5 <= nCol {
                                                                sqlite3_bind_null(pStmt_1, i_5);
                                                                i_5 += 1;
                                                            }
                                                        }
                                                        i_5 += 1;
                                                    }
                                                    if sCtx.cTerm == sCtx.cColSep {
                                                        loop {
                                                            xRead.expect("non-null function pointer")(&mut sCtx);
                                                            i_5 += 1;
                                                            if !(sCtx.cTerm == sCtx.cColSep) {
                                                                break;
                                                            }
                                                        }
                                                        fprintf(
                                                            stderr,
                                                            b"%s:%d: expected %d columns but found %d - extras ignored\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            sCtx.zFile,
                                                            startLine,
                                                            nCol,
                                                            i_5,
                                                        );
                                                    }
                                                    if i_5 >= nCol {
                                                        sqlite3_step(pStmt_1);
                                                        rc = sqlite3_reset(pStmt_1);
                                                        if rc != 0 as libc::c_int {
                                                            fprintf(
                                                                stderr,
                                                                b"%s:%d: INSERT failed: %s\n\0" as *const u8
                                                                    as *const libc::c_char,
                                                                sCtx.zFile,
                                                                startLine,
                                                                sqlite3_errmsg((*p).db),
                                                            );
                                                            sCtx.nErr += 1;
                                                        } else {
                                                            sCtx.nRow += 1;
                                                        }
                                                    }
                                                    if !(sCtx.cTerm != -(1 as libc::c_int)) {
                                                        break;
                                                    }
                                                }
                                                import_cleanup(&mut sCtx);
                                                sqlite3_finalize(pStmt_1);
                                                if needCommit != 0 {
                                                    sqlite3_exec(
                                                        (*p).db,
                                                        b"COMMIT\0" as *const u8 as *const libc::c_char,
                                                        None,
                                                        0 as *mut libc::c_void,
                                                        0 as *mut *mut libc::c_char,
                                                    );
                                                }
                                                if eVerbose > 0 as libc::c_int {
                                                    fprintf(
                                                        (*p).out,
                                                        b"Added %d rows with %d errors using %d lines of input\n\0"
                                                            as *const u8 as *const libc::c_char,
                                                        sCtx.nRow,
                                                        sCtx.nErr,
                                                        sCtx.nLine - 1 as libc::c_int,
                                                    );
                                                }
                                                current_block = 5240171864706220143;
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                match current_block {
                                    5240171864706220143 => {}
                                    _ => {
                                        sqlite3_free(zCreate as *mut libc::c_void);
                                        sqlite3_free(zSql_0 as *mut libc::c_void);
                                        sqlite3_free(zFullTabName as *mut libc::c_void);
                                        import_cleanup(&mut sCtx);
                                        rc = 1 as libc::c_int;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if c == 'i' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"imposter\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zSql_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zCollist: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pStmt_2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut tnum: libc::c_int = 0 as libc::c_int;
        let mut isWO: libc::c_int = 0 as libc::c_int;
        let mut lenPK: libc::c_int = 0 as libc::c_int;
        let mut i_6: libc::c_int = 0;
        if !(nArg == 3 as libc::c_int
            || nArg == 2 as libc::c_int
                && sqlite3_stricmp(
                    azArg[1 as libc::c_int as usize],
                    b"off\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int)
        {
            fprintf(
                stderr,
                b"Usage: .imposter INDEX IMPOSTER\n       .imposter off\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            if nArg == 2 as libc::c_int {
                sqlite3_test_control(
                    25 as libc::c_int,
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int,
                    1 as libc::c_int,
                );
            } else {
                zSql_1 = sqlite3_mprintf(
                    b"SELECT rootpage, 0 FROM sqlite_schema WHERE name='%q' AND type='index'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name='%q' AND type='table'   AND sql LIKE '%%without%%rowid%%'\0"
                        as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                    azArg[1 as libc::c_int as usize],
                );
                sqlite3_prepare_v2(
                    (*p).db,
                    zSql_1,
                    -(1 as libc::c_int),
                    &mut pStmt_2,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_1 as *mut libc::c_void);
                if sqlite3_step(pStmt_2) == 100 as libc::c_int {
                    tnum = sqlite3_column_int(pStmt_2, 0 as libc::c_int);
                    isWO = sqlite3_column_int(pStmt_2, 1 as libc::c_int);
                }
                sqlite3_finalize(pStmt_2);
                zSql_1 = sqlite3_mprintf(
                    b"PRAGMA index_xinfo='%q'\0" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_1,
                    -(1 as libc::c_int),
                    &mut pStmt_2,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_1 as *mut libc::c_void);
                i_6 = 0 as libc::c_int;
                while rc == 0 as libc::c_int
                    && sqlite3_step(pStmt_2) == 100 as libc::c_int
                {
                    let mut zLabel: [libc::c_char; 20] = [0; 20];
                    let mut zCol: *const libc::c_char = sqlite3_column_text(
                        pStmt_2,
                        2 as libc::c_int,
                    ) as *const libc::c_char;
                    i_6 += 1;
                    if zCol.is_null() {
                        if sqlite3_column_int(pStmt_2, 1 as libc::c_int)
                            == -(1 as libc::c_int)
                        {
                            zCol = b"_ROWID_\0" as *const u8 as *const libc::c_char;
                        } else {
                            sqlite3_snprintf(
                                ::core::mem::size_of::<[libc::c_char; 20]>()
                                    as libc::c_ulong as libc::c_int,
                                zLabel.as_mut_ptr(),
                                b"expr%d\0" as *const u8 as *const libc::c_char,
                                i_6,
                            );
                            zCol = zLabel.as_mut_ptr();
                        }
                    }
                    if isWO != 0 && lenPK == 0 as libc::c_int
                        && sqlite3_column_int(pStmt_2, 5 as libc::c_int)
                            == 0 as libc::c_int && !zCollist.is_null()
                    {
                        lenPK = strlen(zCollist) as libc::c_int;
                    }
                    if zCollist.is_null() {
                        zCollist = sqlite3_mprintf(
                            b"\"%w\"\0" as *const u8 as *const libc::c_char,
                            zCol,
                        );
                    } else {
                        zCollist = sqlite3_mprintf(
                            b"%z,\"%w\"\0" as *const u8 as *const libc::c_char,
                            zCollist,
                            zCol,
                        );
                    }
                }
                sqlite3_finalize(pStmt_2);
                if i_6 == 0 as libc::c_int || tnum == 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"no such index: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                    sqlite3_free(zCollist as *mut libc::c_void);
                } else {
                    if lenPK == 0 as libc::c_int {
                        lenPK = 100000 as libc::c_int;
                    }
                    zSql_1 = sqlite3_mprintf(
                        b"CREATE TABLE \"%w\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\0"
                            as *const u8 as *const libc::c_char,
                        azArg[2 as libc::c_int as usize],
                        zCollist,
                        lenPK,
                        zCollist,
                    );
                    sqlite3_free(zCollist as *mut libc::c_void);
                    rc = sqlite3_test_control(
                        25 as libc::c_int,
                        (*p).db,
                        b"main\0" as *const u8 as *const libc::c_char,
                        1 as libc::c_int,
                        tnum,
                    );
                    if rc == 0 as libc::c_int {
                        rc = sqlite3_exec(
                            (*p).db,
                            zSql_1,
                            None,
                            0 as *mut libc::c_void,
                            0 as *mut *mut libc::c_char,
                        );
                        sqlite3_test_control(
                            25 as libc::c_int,
                            (*p).db,
                            b"main\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                        if rc != 0 {
                            fprintf(
                                stderr,
                                b"Error in [%s]: %s\n\0" as *const u8
                                    as *const libc::c_char,
                                zSql_1,
                                sqlite3_errmsg((*p).db),
                            );
                        } else {
                            fprintf(
                                stdout,
                                b"%s;\n\0" as *const u8 as *const libc::c_char,
                                zSql_1,
                            );
                            fprintf(
                                stdout,
                                b"WARNING: writing to an imposter table will corrupt the \"%s\" %s!\n\0"
                                    as *const u8 as *const libc::c_char,
                                azArg[1 as libc::c_int as usize],
                                if isWO != 0 {
                                    b"table\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"index\0" as *const u8 as *const libc::c_char
                                },
                            );
                        }
                    } else {
                        fprintf(
                            stderr,
                            b"SQLITE_TESTCTRL_IMPOSTER returns %d\n\0" as *const u8
                                as *const libc::c_char,
                            rc,
                        );
                        rc = 1 as libc::c_int;
                    }
                    sqlite3_free(zSql_1 as *mut libc::c_void);
                }
            }
        }
    } else if c == 'l' as i32 && n >= 5 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"limits\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        static mut aLimit: [C2RustUnnamed_20; 12] = [
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"length\0" as *const u8 as *const libc::c_char,
                    limitCode: 0 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"sql_length\0" as *const u8 as *const libc::c_char,
                    limitCode: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"column\0" as *const u8 as *const libc::c_char,
                    limitCode: 2 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"expr_depth\0" as *const u8 as *const libc::c_char,
                    limitCode: 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"compound_select\0" as *const u8 as *const libc::c_char,
                    limitCode: 4 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"vdbe_op\0" as *const u8 as *const libc::c_char,
                    limitCode: 5 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"function_arg\0" as *const u8 as *const libc::c_char,
                    limitCode: 6 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"attached\0" as *const u8 as *const libc::c_char,
                    limitCode: 7 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"like_pattern_length\0" as *const u8
                        as *const libc::c_char,
                    limitCode: 8 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"variable_number\0" as *const u8 as *const libc::c_char,
                    limitCode: 9 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"trigger_depth\0" as *const u8 as *const libc::c_char,
                    limitCode: 10 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"worker_threads\0" as *const u8 as *const libc::c_char,
                    limitCode: 11 as libc::c_int,
                };
                init
            },
        ];
        let mut i_7: libc::c_int = 0;
        let mut n2_0: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        if nArg == 1 as libc::c_int {
            i_7 = 0 as libc::c_int;
            while i_7
                < (::core::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong,
                    ) as libc::c_int
            {
                printf(
                    b"%20s %d\n\0" as *const u8 as *const libc::c_char,
                    aLimit[i_7 as usize].zLimitName,
                    sqlite3_limit(
                        (*p).db,
                        aLimit[i_7 as usize].limitCode,
                        -(1 as libc::c_int),
                    ),
                );
                i_7 += 1;
            }
        } else if nArg > 3 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .limit NAME ?NEW-VALUE?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            let mut iLimit: libc::c_int = -(1 as libc::c_int);
            n2_0 = strlen30(azArg[1 as libc::c_int as usize]);
            i_7 = 0 as libc::c_int;
            loop {
                if !(i_7
                    < (::core::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 2027797428995195695;
                    break;
                }
                if sqlite3_strnicmp(
                    aLimit[i_7 as usize].zLimitName,
                    azArg[1 as libc::c_int as usize],
                    n2_0,
                ) == 0 as libc::c_int
                {
                    if iLimit < 0 as libc::c_int {
                        iLimit = i_7;
                    } else {
                        fprintf(
                            stderr,
                            b"ambiguous limit: \"%s\"\n\0" as *const u8
                                as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                        current_block = 5240171864706220143;
                        break;
                    }
                }
                i_7 += 1;
            }
            match current_block {
                5240171864706220143 => {}
                _ => {
                    if iLimit < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"unknown limit: \"%s\"\nenter \".limits\" with no arguments for a list.\n\0"
                                as *const u8 as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                    } else {
                        if nArg == 3 as libc::c_int {
                            sqlite3_limit(
                                (*p).db,
                                aLimit[iLimit as usize].limitCode,
                                integerValue(azArg[2 as libc::c_int as usize])
                                    as libc::c_int,
                            );
                        }
                        printf(
                            b"%20s %d\n\0" as *const u8 as *const libc::c_char,
                            aLimit[iLimit as usize].zLimitName,
                            sqlite3_limit(
                                (*p).db,
                                aLimit[iLimit as usize].limitCode,
                                -(1 as libc::c_int),
                            ),
                        );
                    }
                }
            }
        }
    } else if c == 'l' as i32 && n > 2 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"lint\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        lintDotCommand(p, azArg.as_mut_ptr(), nArg);
    } else if c == 'l' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"load\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zFile_2: *const libc::c_char = 0 as *const libc::c_char;
        let mut zProc: *const libc::c_char = 0 as *const libc::c_char;
        let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .load in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg < 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .load FILE ?ENTRYPOINT?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            zFile_2 = azArg[1 as libc::c_int as usize];
            zProc = if nArg >= 3 as libc::c_int {
                azArg[2 as libc::c_int as usize]
            } else {
                0 as *mut libc::c_char
            };
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_load_extension((*p).db, zFile_2, zProc, &mut zErrMsg);
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                    zErrMsg,
                );
                sqlite3_free(zErrMsg as *mut libc::c_void);
                rc = 1 as libc::c_int;
            }
        }
    } else if c == 'l' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"log\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .log in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .log FILENAME\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            let mut zFile_3: *const libc::c_char = azArg[1 as libc::c_int as usize];
            output_file_close((*p).pLog);
            (*p).pLog = output_file_open(zFile_3, 0 as libc::c_int);
        }
    } else if c == 'm' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"mode\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zMode: *const libc::c_char = 0 as *const libc::c_char;
        let mut zTabname: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_8: libc::c_int = 0;
        let mut n2_1: libc::c_int = 0;
        let mut cmOpts: ColModeOpts = {
            let mut init = ColModeOpts {
                iWrap: 60 as libc::c_int,
                bQuote: 0 as libc::c_int as u8_0,
                bWordWrap: 0 as libc::c_int as u8_0,
            };
            init
        };
        i_8 = 1 as libc::c_int;
        loop {
            if !(i_8 < nArg) {
                current_block = 15868221551087540686;
                break;
            }
            let mut z_5: *const libc::c_char = azArg[i_8 as usize];
            if optionMatch(z_5, b"wrap\0" as *const u8 as *const libc::c_char) != 0
                && (i_8 + 1 as libc::c_int) < nArg
            {
                i_8 += 1;
                cmOpts.iWrap = integerValue(azArg[i_8 as usize]) as libc::c_int;
            } else if optionMatch(z_5, b"ww\0" as *const u8 as *const libc::c_char) != 0
            {
                cmOpts.bWordWrap = 1 as libc::c_int as u8_0;
            } else if optionMatch(z_5, b"wordwrap\0" as *const u8 as *const libc::c_char)
                != 0 && (i_8 + 1 as libc::c_int) < nArg
            {
                i_8 += 1;
                cmOpts.bWordWrap = booleanValue(azArg[i_8 as usize]) as u8_0;
            } else if optionMatch(z_5, b"quote\0" as *const u8 as *const libc::c_char)
                != 0
            {
                cmOpts.bQuote = 1 as libc::c_int as u8_0;
            } else if optionMatch(z_5, b"noquote\0" as *const u8 as *const libc::c_char)
                != 0
            {
                cmOpts.bQuote = 0 as libc::c_int as u8_0;
            } else if zMode.is_null() {
                zMode = z_5;
                if strcmp(z_5, b"qbox\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    let mut cmo: ColModeOpts = {
                        let mut init = ColModeOpts {
                            iWrap: 60 as libc::c_int,
                            bQuote: 1 as libc::c_int as u8_0,
                            bWordWrap: 0 as libc::c_int as u8_0,
                        };
                        init
                    };
                    zMode = b"box\0" as *const u8 as *const libc::c_char;
                    cmOpts = cmo;
                }
            } else if zTabname.is_null() {
                zTabname = z_5;
            } else if *z_5.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                    z_5,
                );
                fprintf(
                    stderr,
                    b"options:\n  --noquote\n  --quote\n  --wordwrap on/off\n  --wrap N\n  --ww\n\0"
                        as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            } else {
                fprintf(
                    stderr,
                    b"extra argument: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    z_5,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            }
            i_8 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if zMode.is_null() {
                    if (*p).mode == 1 as libc::c_int
                        || (*p).mode >= 14 as libc::c_int
                            && (*p).mode <= 16 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"current output mode: %s --wrap %d --wordwrap %s --%squote\n\0"
                                as *const u8 as *const libc::c_char,
                            modeDescr[(*p).mode as usize],
                            (*p).cmOpts.iWrap,
                            if (*p).cmOpts.bWordWrap as libc::c_int != 0 {
                                b"on\0" as *const u8 as *const libc::c_char
                            } else {
                                b"off\0" as *const u8 as *const libc::c_char
                            },
                            if (*p).cmOpts.bQuote as libc::c_int != 0 {
                                b"\0" as *const u8 as *const libc::c_char
                            } else {
                                b"no\0" as *const u8 as *const libc::c_char
                            },
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"current output mode: %s\n\0" as *const u8
                                as *const libc::c_char,
                            modeDescr[(*p).mode as usize],
                        );
                    }
                    zMode = modeDescr[(*p).mode as usize];
                }
                n2_1 = strlen30(zMode);
                if strncmp(
                    zMode,
                    b"lines\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 0 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"columns\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 1 as libc::c_int;
                    if (*p).shellFlgs & 0x80 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        (*p).showHeader = 1 as libc::c_int;
                    }
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                    (*p).cmOpts = cmOpts;
                } else if strncmp(
                    zMode,
                    b"list\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"|\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"html\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 4 as libc::c_int;
                } else if strncmp(
                    zMode,
                    b"tcl\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 7 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b" \0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"csv\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 8 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b",\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\r\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"tabs\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"\t\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"insert\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 5 as libc::c_int;
                    set_table_name(
                        p,
                        if !zTabname.is_null() {
                            zTabname
                        } else {
                            b"table\0" as *const u8 as *const libc::c_char
                        },
                    );
                } else if strncmp(
                    zMode,
                    b"quote\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 6 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b",\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"ascii\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 10 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"\x1F\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\x1E\0" as *const u8 as *const libc::c_char,
                    );
                } else if strncmp(
                    zMode,
                    b"markdown\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 14 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if strncmp(
                    zMode,
                    b"table\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 15 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if strncmp(
                    zMode,
                    b"box\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 16 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if strncmp(
                    zMode,
                    b"count\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 17 as libc::c_int;
                } else if strncmp(
                    zMode,
                    b"off\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 18 as libc::c_int;
                } else if strncmp(
                    zMode,
                    b"json\0" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 13 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Error: mode should be one of: ascii box column csv html insert json line list markdown qbox quote table tabs tcl\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                }
                (*p).cMode = (*p).mode;
            }
        }
    } else if c == 'n' as i32
        && strcmp(
            azArg[0 as libc::c_int as usize],
            b"nonce\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .nonce NONCE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else if ((*p).zNonce).is_null()
            || strcmp(azArg[1 as libc::c_int as usize], (*p).zNonce) != 0 as libc::c_int
        {
            fprintf(
                stderr,
                b"line %d: incorrect nonce: \"%s\"\n\0" as *const u8
                    as *const libc::c_char,
                (*p).lineno,
                azArg[1 as libc::c_int as usize],
            );
            exit(1 as libc::c_int);
        } else {
            (*p).bSafeMode = 0 as libc::c_int as u8_0;
            return 0 as libc::c_int;
        }
    } else if c == 'n' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"nullvalue\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).nullValue).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .nullvalue STRING\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'o' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"open\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int && n >= 2 as libc::c_int
    {
        let mut zFN: *const libc::c_char = 0 as *const libc::c_char;
        let mut zNewFilename: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut iName: libc::c_int = 1 as libc::c_int;
        let mut newFlag: libc::c_int = 0 as libc::c_int;
        let mut openMode: libc::c_int = 0 as libc::c_int;
        iName = 1 as libc::c_int;
        loop {
            if !(iName < nArg) {
                current_block = 15261013481348428112;
                break;
            }
            let mut z_6: *const libc::c_char = azArg[iName as usize];
            if optionMatch(z_6, b"new\0" as *const u8 as *const libc::c_char) != 0 {
                newFlag = 1 as libc::c_int;
            } else if optionMatch(z_6, b"append\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 2 as libc::c_int;
            } else if optionMatch(z_6, b"readonly\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 4 as libc::c_int;
            } else if optionMatch(z_6, b"nofollow\0" as *const u8 as *const libc::c_char)
                != 0
            {
                (*p).openFlags |= 0x1000000 as libc::c_int;
            } else if optionMatch(
                z_6,
                b"deserialize\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                openMode = 5 as libc::c_int;
            } else if optionMatch(z_6, b"hexdb\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 6 as libc::c_int;
            } else if optionMatch(z_6, b"maxsize\0" as *const u8 as *const libc::c_char)
                != 0 && (iName + 1 as libc::c_int) < nArg
            {
                iName += 1;
                (*p).szMax = integerValue(azArg[iName as usize]);
            } else if *z_6.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                    z_6,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            } else if !zFN.is_null() {
                fprintf(
                    stderr,
                    b"extra argument: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    z_6,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            } else {
                zFN = z_6;
            }
            iName += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                close_db((*p).db);
                (*p).db = 0 as *mut sqlite3;
                (*(*p).pAuxDb).zDbFilename = 0 as *const libc::c_char;
                sqlite3_free((*(*p).pAuxDb).zFreeOnClose as *mut libc::c_void);
                (*(*p).pAuxDb).zFreeOnClose = 0 as *mut libc::c_char;
                (*p).openMode = openMode as u8_0;
                (*p).openFlags = 0 as libc::c_int;
                (*p).szMax = 0 as libc::c_int as sqlite3_int64;
                if !zFN.is_null() || (*p).openMode as libc::c_int == 6 as libc::c_int {
                    if newFlag != 0 && !zFN.is_null() && (*p).bSafeMode == 0 {
                        shellDeleteFile(zFN);
                    }
                    if (*p).bSafeMode as libc::c_int != 0
                        && (*p).openMode as libc::c_int != 6 as libc::c_int
                        && !zFN.is_null()
                        && strcmp(zFN, b":memory:\0" as *const u8 as *const libc::c_char)
                            != 0 as libc::c_int
                    {
                        failIfSafeMode(
                            p,
                            b"cannot open disk-based database files in safe mode\0"
                                as *const u8 as *const libc::c_char,
                        );
                    }
                    if !zFN.is_null() {
                        zNewFilename = sqlite3_mprintf(
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFN,
                        );
                        shell_check_oom(zNewFilename as *mut libc::c_void);
                    } else {
                        zNewFilename = 0 as *mut libc::c_char;
                    }
                    (*(*p).pAuxDb).zDbFilename = zNewFilename;
                    open_db(p, 0x1 as libc::c_int);
                    if ((*p).db).is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open '%s'\n\0" as *const u8
                                as *const libc::c_char,
                            zNewFilename,
                        );
                        sqlite3_free(zNewFilename as *mut libc::c_void);
                    } else {
                        (*(*p).pAuxDb).zFreeOnClose = zNewFilename;
                    }
                }
                if ((*p).db).is_null() {
                    (*(*p).pAuxDb).zDbFilename = 0 as *const libc::c_char;
                    open_db(p, 0 as libc::c_int);
                }
            }
        }
    } else if c == 'o' as i32
        && (strncmp(
            azArg[0 as libc::c_int as usize],
            b"output\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
            || strncmp(
                azArg[0 as libc::c_int as usize],
                b"once\0" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int)
        || c == 'e' as i32 && n == 5 as libc::c_int
            && strcmp(
                azArg[0 as libc::c_int as usize],
                b"excel\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
    {
        let mut zFile_4: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut bTxtMode: libc::c_int = 0 as libc::c_int;
        let mut i_9: libc::c_int = 0;
        let mut eMode: libc::c_int = 0 as libc::c_int;
        let mut bOnce: libc::c_int = 0 as libc::c_int;
        let mut zBOM: [libc::c_uchar; 4] = [0; 4];
        zBOM[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        if c == 'e' as i32 {
            eMode = 'x' as i32;
            bOnce = 2 as libc::c_int;
        } else if strncmp(
            azArg[0 as libc::c_int as usize],
            b"once\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            bOnce = 1 as libc::c_int;
        }
        i_9 = 1 as libc::c_int;
        loop {
            if !(i_9 < nArg) {
                current_block = 3435079061329681511;
                break;
            }
            let mut z_7: *mut libc::c_char = azArg[i_9 as usize];
            if *z_7.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if *z_7.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_7 = z_7.offset(1);
                }
                if strcmp(z_7, b"-bom\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zBOM[0 as libc::c_int
                        as usize] = 0xef as libc::c_int as libc::c_uchar;
                    zBOM[1 as libc::c_int
                        as usize] = 0xbb as libc::c_int as libc::c_uchar;
                    zBOM[2 as libc::c_int
                        as usize] = 0xbf as libc::c_int as libc::c_uchar;
                    zBOM[3 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
                } else if c != 'e' as i32
                    && strcmp(z_7, b"-x\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    eMode = 'x' as i32;
                } else if c != 'e' as i32
                    && strcmp(z_7, b"-e\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    eMode = 'e' as i32;
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: unknown option: \"%s\".  Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_9 as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    current_block = 5240171864706220143;
                    break;
                }
            } else if zFile_4.is_null() && eMode != 'e' as i32 && eMode != 'x' as i32 {
                zFile_4 = sqlite3_mprintf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    z_7,
                );
                if !zFile_4.is_null()
                    && *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int
                        == '|' as i32
                {
                    while (i_9 + 1 as libc::c_int) < nArg {
                        i_9 += 1;
                        zFile_4 = sqlite3_mprintf(
                            b"%z %s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                            azArg[i_9 as usize],
                        );
                    }
                    current_block = 3435079061329681511;
                    break;
                }
            } else {
                fprintf(
                    (*p).out,
                    b"ERROR: extra parameter: \"%s\".  Usage:\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[i_9 as usize],
                );
                showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                rc = 1 as libc::c_int;
                sqlite3_free(zFile_4 as *mut libc::c_void);
                current_block = 5240171864706220143;
                break;
            }
            i_9 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if zFile_4.is_null() {
                    zFile_4 = sqlite3_mprintf(
                        b"stdout\0" as *const u8 as *const libc::c_char,
                    );
                }
                if bOnce != 0 {
                    (*p).outCount = 2 as libc::c_int;
                } else {
                    (*p).outCount = 0 as libc::c_int;
                }
                output_reset(p);
                if eMode == 'e' as i32 || eMode == 'x' as i32 {
                    (*p).doXdgOpen = 1 as libc::c_int as u8_0;
                    outputModePush(p);
                    if eMode == 'x' as i32 {
                        newTempFile(p, b"csv\0" as *const u8 as *const libc::c_char);
                        (*p).shellFlgs &= !(0x40 as libc::c_int) as libc::c_uint;
                        (*p).mode = 8 as libc::c_int;
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                as libc::c_int,
                            ((*p).colSeparator).as_mut_ptr(),
                            b",\0" as *const u8 as *const libc::c_char,
                        );
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                as libc::c_int,
                            ((*p).rowSeparator).as_mut_ptr(),
                            b"\r\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        newTempFile(p, b"txt\0" as *const u8 as *const libc::c_char);
                        bTxtMode = 1 as libc::c_int;
                    }
                    sqlite3_free(zFile_4 as *mut libc::c_void);
                    zFile_4 = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        (*p).zTempFile,
                    );
                }
                shell_check_oom(zFile_4 as *mut libc::c_void);
                if *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int
                    == '|' as i32
                {
                    (*p)
                        .out = popen(
                        zFile_4.offset(1 as libc::c_int as isize),
                        b"w\0" as *const u8 as *const libc::c_char,
                    );
                    if ((*p).out).is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open pipe \"%s\"\n\0" as *const u8
                                as *const libc::c_char,
                            zFile_4.offset(1 as libc::c_int as isize),
                        );
                        (*p).out = stdout;
                        rc = 1 as libc::c_int;
                    } else {
                        if zBOM[0 as libc::c_int as usize] != 0 {
                            fwrite(
                                zBOM.as_mut_ptr() as *const libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                3 as libc::c_int as libc::c_ulong,
                                (*p).out,
                            );
                        }
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 4096]>()
                                as libc::c_ulong as libc::c_int,
                            ((*p).outfile).as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                        );
                    }
                } else {
                    (*p).out = output_file_open(zFile_4, bTxtMode);
                    if ((*p).out).is_null() {
                        if strcmp(zFile_4, b"off\0" as *const u8 as *const libc::c_char)
                            != 0 as libc::c_int
                        {
                            fprintf(
                                stderr,
                                b"Error: cannot write to \"%s\"\n\0" as *const u8
                                    as *const libc::c_char,
                                zFile_4,
                            );
                        }
                        (*p).out = stdout;
                        rc = 1 as libc::c_int;
                    } else {
                        if zBOM[0 as libc::c_int as usize] != 0 {
                            fwrite(
                                zBOM.as_mut_ptr() as *const libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                3 as libc::c_int as libc::c_ulong,
                                (*p).out,
                            );
                        }
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 4096]>()
                                as libc::c_ulong as libc::c_int,
                            ((*p).outfile).as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                        );
                    }
                }
                sqlite3_free(zFile_4 as *mut libc::c_void);
            }
        }
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"parameter\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut current_block_1079: u64;
        open_db(p, 0 as libc::c_int);
        if nArg <= 1 as libc::c_int {
            current_block_1079 = 5648565205831007635;
        } else if nArg == 2 as libc::c_int
            && strcmp(
                azArg[1 as libc::c_int as usize],
                b"clear\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            sqlite3_exec(
                (*p).db,
                b"DROP TABLE IF EXISTS temp.sqlite_parameters;\0" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            current_block_1079 = 16090971439598032253;
        } else if nArg == 2 as libc::c_int
            && strcmp(
                azArg[1 as libc::c_int as usize],
                b"list\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut pStmt_3: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut rx: libc::c_int = 0;
            let mut len: libc::c_int = 0 as libc::c_int;
            rx = sqlite3_prepare_v2(
                (*p).db,
                b"SELECT max(length(key)) FROM temp.sqlite_parameters;\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
                &mut pStmt_3,
                0 as *mut *const libc::c_char,
            );
            if rx == 0 as libc::c_int && sqlite3_step(pStmt_3) == 100 as libc::c_int {
                len = sqlite3_column_int(pStmt_3, 0 as libc::c_int);
                if len > 40 as libc::c_int {
                    len = 40 as libc::c_int;
                }
            }
            sqlite3_finalize(pStmt_3);
            pStmt_3 = 0 as *mut sqlite3_stmt;
            if len != 0 {
                rx = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT key, quote(value) FROM temp.sqlite_parameters;\0"
                        as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_3,
                    0 as *mut *const libc::c_char,
                );
                while rx == 0 as libc::c_int
                    && sqlite3_step(pStmt_3) == 100 as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"%-*s %s\n\0" as *const u8 as *const libc::c_char,
                        len,
                        sqlite3_column_text(pStmt_3, 0 as libc::c_int),
                        sqlite3_column_text(pStmt_3, 1 as libc::c_int),
                    );
                }
                sqlite3_finalize(pStmt_3);
            }
            current_block_1079 = 16090971439598032253;
        } else if nArg == 2 as libc::c_int
            && strcmp(
                azArg[1 as libc::c_int as usize],
                b"init\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            bind_table_init(p);
            current_block_1079 = 16090971439598032253;
        } else if nArg == 4 as libc::c_int
            && strcmp(
                azArg[1 as libc::c_int as usize],
                b"set\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut rx_0: libc::c_int = 0;
            let mut zSql_2: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut pStmt_4: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut zKey: *const libc::c_char = azArg[2 as libc::c_int as usize];
            let mut zValue: *const libc::c_char = azArg[3 as libc::c_int as usize];
            bind_table_init(p);
            zSql_2 = sqlite3_mprintf(
                b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\0"
                    as *const u8 as *const libc::c_char,
                zKey,
                zValue,
            );
            shell_check_oom(zSql_2 as *mut libc::c_void);
            pStmt_4 = 0 as *mut sqlite3_stmt;
            rx_0 = sqlite3_prepare_v2(
                (*p).db,
                zSql_2,
                -(1 as libc::c_int),
                &mut pStmt_4,
                0 as *mut *const libc::c_char,
            );
            sqlite3_free(zSql_2 as *mut libc::c_void);
            if rx_0 != 0 as libc::c_int {
                sqlite3_finalize(pStmt_4);
                pStmt_4 = 0 as *mut sqlite3_stmt;
                zSql_2 = sqlite3_mprintf(
                    b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\0"
                        as *const u8 as *const libc::c_char,
                    zKey,
                    zValue,
                );
                shell_check_oom(zSql_2 as *mut libc::c_void);
                rx_0 = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_2,
                    -(1 as libc::c_int),
                    &mut pStmt_4,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_2 as *mut libc::c_void);
                if rx_0 != 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    sqlite3_finalize(pStmt_4);
                    pStmt_4 = 0 as *mut sqlite3_stmt;
                    rc = 1 as libc::c_int;
                }
            }
            sqlite3_step(pStmt_4);
            sqlite3_finalize(pStmt_4);
            current_block_1079 = 16090971439598032253;
        } else if nArg == 3 as libc::c_int
            && strcmp(
                azArg[1 as libc::c_int as usize],
                b"unset\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut zSql_3: *mut libc::c_char = sqlite3_mprintf(
                b"DELETE FROM temp.sqlite_parameters WHERE key=%Q\0" as *const u8
                    as *const libc::c_char,
                azArg[2 as libc::c_int as usize],
            );
            shell_check_oom(zSql_3 as *mut libc::c_void);
            sqlite3_exec(
                (*p).db,
                zSql_3,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql_3 as *mut libc::c_void);
            current_block_1079 = 16090971439598032253;
        } else {
            current_block_1079 = 5648565205831007635;
        }
        match current_block_1079 {
            5648565205831007635 => {
                showHelp((*p).out, b"parameter\0" as *const u8 as *const libc::c_char);
            }
            _ => {}
        }
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"print\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut i_10: libc::c_int = 0;
        i_10 = 1 as libc::c_int;
        while i_10 < nArg {
            if i_10 > 1 as libc::c_int {
                fprintf((*p).out, b" \0" as *const u8 as *const libc::c_char);
            }
            fprintf(
                (*p).out,
                b"%s\0" as *const u8 as *const libc::c_char,
                azArg[i_10 as usize],
            );
            i_10 += 1;
        }
        fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"progress\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut i_11: libc::c_int = 0;
        let mut nn: libc::c_int = 0 as libc::c_int;
        (*p).flgProgress = 0 as libc::c_int as libc::c_uint;
        (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
        (*p).nProgress = 0 as libc::c_int as libc::c_uint;
        i_11 = 1 as libc::c_int;
        loop {
            if !(i_11 < nArg) {
                current_block = 16622677065440087404;
                break;
            }
            let mut z_8: *const libc::c_char = azArg[i_11 as usize];
            if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_8 = z_8.offset(1);
                if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_8 = z_8.offset(1);
                }
                if strcmp(z_8, b"quiet\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    || strcmp(z_8, b"q\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x1 as libc::c_int as libc::c_uint;
                } else if strcmp(z_8, b"reset\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x2 as libc::c_int as libc::c_uint;
                } else if strcmp(z_8, b"once\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x4 as libc::c_int as libc::c_uint;
                } else if strcmp(z_8, b"limit\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    if i_11 + 1 as libc::c_int >= nArg {
                        fprintf(
                            stderr,
                            b"Error: missing argument on --limit\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 5240171864706220143;
                        break;
                    } else {
                        i_11 += 1;
                        (*p)
                            .mxProgress = integerValue(azArg[i_11 as usize])
                            as libc::c_int as libc::c_uint;
                    }
                } else {
                    fprintf(
                        stderr,
                        b"Error: unknown option: \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_11 as usize],
                    );
                    rc = 1 as libc::c_int;
                    current_block = 5240171864706220143;
                    break;
                }
            } else {
                nn = integerValue(z_8) as libc::c_int;
            }
            i_11 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                open_db(p, 0 as libc::c_int);
                sqlite3_progress_handler(
                    (*p).db,
                    nn,
                    Some(
                        progress_handler
                            as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            }
        }
    } else if c == 'p' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"prompt\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg >= 2 as libc::c_int {
            strncpy(
                mainPrompt.as_mut_ptr(),
                azArg[1 as libc::c_int as usize],
                ((::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
            );
        }
        if nArg >= 3 as libc::c_int {
            strncpy(
                continuePrompt.as_mut_ptr(),
                azArg[2 as libc::c_int as usize],
                ((::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
            );
        }
    } else if c == 'q' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"quit\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        rc = 2 as libc::c_int;
    } else if c == 'r' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"read\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut inSaved: *mut FILE = (*p).in_0;
        let mut savedLineno: libc::c_int = (*p).lineno;
        failIfSafeMode(
            p,
            b"cannot run .read in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .read FILE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            if *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == '|' as i32
            {
                (*p)
                    .in_0 = popen(
                    (azArg[1 as libc::c_int as usize]).offset(1 as libc::c_int as isize),
                    b"r\0" as *const u8 as *const libc::c_char,
                );
                if ((*p).in_0).is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                } else {
                    rc = process_input(p);
                    pclose((*p).in_0);
                }
            } else {
                (*p).in_0 = openChrSource(azArg[1 as libc::c_int as usize]);
                if ((*p).in_0).is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                } else {
                    rc = process_input(p);
                    fclose((*p).in_0);
                }
            }
            (*p).in_0 = inSaved;
            (*p).lineno = savedLineno;
        }
    } else if c == 'r' as i32 && n >= 3 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"restore\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zSrcFile: *const libc::c_char = 0 as *const libc::c_char;
        let mut zDb_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut pSrc: *mut sqlite3 = 0 as *mut sqlite3;
        let mut pBackup_0: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
        let mut nTimeout: libc::c_int = 0 as libc::c_int;
        failIfSafeMode(
            p,
            b"cannot run .restore in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            zSrcFile = azArg[1 as libc::c_int as usize];
            zDb_0 = b"main\0" as *const u8 as *const libc::c_char;
            current_block = 9898047525107966717;
        } else if nArg == 3 as libc::c_int {
            zSrcFile = azArg[2 as libc::c_int as usize];
            zDb_0 = azArg[1 as libc::c_int as usize];
            current_block = 9898047525107966717;
        } else {
            fprintf(
                stderr,
                b"Usage: .restore ?DB? FILE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
            current_block = 5240171864706220143;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                rc = sqlite3_open(zSrcFile, &mut pSrc);
                if rc != 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        zSrcFile,
                    );
                    close_db(pSrc);
                    return 1 as libc::c_int;
                }
                open_db(p, 0 as libc::c_int);
                pBackup_0 = sqlite3_backup_init(
                    (*p).db,
                    zDb_0,
                    pSrc,
                    b"main\0" as *const u8 as *const libc::c_char,
                );
                if pBackup_0.is_null() {
                    fprintf(
                        stderr,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    close_db(pSrc);
                    return 1 as libc::c_int;
                }
                loop {
                    rc = sqlite3_backup_step(pBackup_0, 100 as libc::c_int);
                    if !(rc == 0 as libc::c_int || rc == 5 as libc::c_int) {
                        break;
                    }
                    if !(rc == 5 as libc::c_int) {
                        continue;
                    }
                    let fresh87 = nTimeout;
                    nTimeout = nTimeout + 1;
                    if fresh87 >= 3 as libc::c_int {
                        break;
                    }
                    sqlite3_sleep(100 as libc::c_int);
                }
                sqlite3_backup_finish(pBackup_0);
                if rc == 101 as libc::c_int {
                    rc = 0 as libc::c_int;
                } else if rc == 5 as libc::c_int || rc == 6 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: source database is busy\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    rc = 1 as libc::c_int;
                }
                close_db(pSrc);
            }
        }
    } else if c == 's' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"scanstats\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).scanstatsOn = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0;
            fprintf(
                stderr,
                b"Warning: .scanstats not available in this build.\n\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .scanstats on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 's' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"schema\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut sSelect: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut data_0: ShellState = ShellState {
            db: 0 as *mut sqlite3,
            autoExplain: 0,
            autoEQP: 0,
            autoEQPtest: 0,
            autoEQPtrace: 0,
            scanstatsOn: 0,
            openMode: 0,
            doXdgOpen: 0,
            nEqpLevel: 0,
            eTraceType: 0,
            bSafeMode: 0,
            bSafeModePersist: 0,
            cmOpts: ColModeOpts {
                iWrap: 0,
                bQuote: 0,
                bWordWrap: 0,
            },
            statsOn: 0,
            mEqpLines: 0,
            inputNesting: 0,
            outCount: 0,
            cnt: 0,
            lineno: 0,
            openFlags: 0,
            in_0: 0 as *mut FILE,
            out: 0 as *mut FILE,
            traceOut: 0 as *mut FILE,
            nErr: 0,
            mode: 0,
            modePrior: 0,
            cMode: 0,
            normalMode: 0,
            writableSchema: 0,
            showHeader: 0,
            nCheck: 0,
            nProgress: 0,
            mxProgress: 0,
            flgProgress: 0,
            shellFlgs: 0,
            priorShFlgs: 0,
            szMax: 0,
            zDestTable: 0 as *mut libc::c_char,
            zTempFile: 0 as *mut libc::c_char,
            zTestcase: [0; 30],
            colSeparator: [0; 20],
            rowSeparator: [0; 20],
            colSepPrior: [0; 20],
            rowSepPrior: [0; 20],
            colWidth: 0 as *mut libc::c_int,
            actualWidth: 0 as *mut libc::c_int,
            nWidth: 0,
            nullValue: [0; 20],
            outfile: [0; 4096],
            pStmt: 0 as *mut sqlite3_stmt,
            pLog: 0 as *mut FILE,
            aAuxDb: [AuxDb {
                db: 0 as *mut sqlite3,
                zDbFilename: 0 as *const libc::c_char,
                zFreeOnClose: 0 as *mut libc::c_char,
            }; 5],
            pAuxDb: 0 as *mut AuxDb,
            aiIndent: 0 as *mut libc::c_int,
            nIndent: 0,
            iIndent: 0,
            zNonce: 0 as *mut libc::c_char,
            sGraph: EQPGraph {
                pRow: 0 as *mut EQPGraphRow,
                pLast: 0 as *mut EQPGraphRow,
                zPrefix: [0; 100],
            },
            expert: ExpertInfo {
                pExpert: 0 as *mut sqlite3expert,
                bVerbose: 0,
            },
        };
        let mut zErrMsg_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zDiv: *const libc::c_char = b"(\0" as *const u8 as *const libc::c_char;
        let mut zName: *const libc::c_char = 0 as *const libc::c_char;
        let mut iSchema: libc::c_int = 0 as libc::c_int;
        let mut bDebug: libc::c_int = 0 as libc::c_int;
        let mut bNoSystemTabs: libc::c_int = 0 as libc::c_int;
        let mut ii_0: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        memcpy(
            &mut data_0 as *mut ShellState as *mut libc::c_void,
            p as *const libc::c_void,
            ::core::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        data_0.showHeader = 0 as libc::c_int;
        data_0.mode = 3 as libc::c_int;
        data_0.cMode = data_0.mode;
        initText(&mut sSelect);
        ii_0 = 1 as libc::c_int;
        loop {
            if !(ii_0 < nArg) {
                current_block = 8586487098565199158;
                break;
            }
            if optionMatch(
                azArg[ii_0 as usize],
                b"indent\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                data_0.mode = 11 as libc::c_int;
                data_0.cMode = data_0.mode;
            } else if optionMatch(
                azArg[ii_0 as usize],
                b"debug\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                bDebug = 1 as libc::c_int;
            } else if optionMatch(
                azArg[ii_0 as usize],
                b"nosys\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                bNoSystemTabs = 1 as libc::c_int;
            } else if *(azArg[ii_0 as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"Unknown option: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    azArg[ii_0 as usize],
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            } else if zName.is_null() {
                zName = azArg[ii_0 as usize];
            } else {
                fprintf(
                    stderr,
                    b"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\n\0"
                        as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            }
            ii_0 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if !zName.is_null() {
                    let mut isSchema: libc::c_int = (sqlite3_strlike(
                        zName,
                        b"sqlite_master\0" as *const u8 as *const libc::c_char,
                        '\\' as i32 as libc::c_uint,
                    ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_schema\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_temp_master\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_temp_schema\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int) as libc::c_int;
                    if isSchema != 0 {
                        let mut new_argv: [*mut libc::c_char; 2] = [0
                            as *mut libc::c_char; 2];
                        let mut new_colv: [*mut libc::c_char; 2] = [0
                            as *mut libc::c_char; 2];
                        new_argv[0 as libc::c_int
                            as usize] = sqlite3_mprintf(
                            b"CREATE TABLE %s (\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)\0"
                                as *const u8 as *const libc::c_char,
                            zName,
                        );
                        shell_check_oom(
                            new_argv[0 as libc::c_int as usize] as *mut libc::c_void,
                        );
                        new_argv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                        new_colv[0 as libc::c_int
                            as usize] = b"sql\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                        new_colv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                        callback(
                            &mut data_0 as *mut ShellState as *mut libc::c_void,
                            1 as libc::c_int,
                            new_argv.as_mut_ptr(),
                            new_colv.as_mut_ptr(),
                        );
                        sqlite3_free(
                            new_argv[0 as libc::c_int as usize] as *mut libc::c_void,
                        );
                    }
                }
                if !zDiv.is_null() {
                    let mut pStmt_5: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    rc = sqlite3_prepare_v2(
                        (*p).db,
                        b"SELECT name FROM pragma_database_list\0" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pStmt_5,
                        0 as *mut *const libc::c_char,
                    );
                    if rc != 0 {
                        fprintf(
                            stderr,
                            b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_errmsg((*p).db),
                        );
                        sqlite3_finalize(pStmt_5);
                        rc = 1 as libc::c_int;
                        current_block = 5240171864706220143;
                    } else {
                        appendText(
                            &mut sSelect,
                            b"SELECT sql FROM\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        iSchema = 0 as libc::c_int;
                        while sqlite3_step(pStmt_5) == 100 as libc::c_int {
                            let mut zDb_1: *const libc::c_char = sqlite3_column_text(
                                pStmt_5,
                                0 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zScNum: [libc::c_char; 30] = [0; 30];
                            iSchema += 1;
                            sqlite3_snprintf(
                                ::core::mem::size_of::<[libc::c_char; 30]>()
                                    as libc::c_ulong as libc::c_int,
                                zScNum.as_mut_ptr(),
                                b"%d\0" as *const u8 as *const libc::c_char,
                                iSchema,
                            );
                            appendText(
                                &mut sSelect,
                                zDiv,
                                0 as libc::c_int as libc::c_char,
                            );
                            zDiv = b" UNION ALL \0" as *const u8 as *const libc::c_char;
                            appendText(
                                &mut sSelect,
                                b"SELECT shell_add_schema(sql,\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            if sqlite3_stricmp(
                                zDb_1,
                                b"main\0" as *const u8 as *const libc::c_char,
                            ) != 0 as libc::c_int
                            {
                                appendText(
                                    &mut sSelect,
                                    zDb_1,
                                    '\'' as i32 as libc::c_char,
                                );
                            } else {
                                appendText(
                                    &mut sSelect,
                                    b"NULL\0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b",name) AS sql, type, tbl_name, name, rowid,\0"
                                    as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                zScNum.as_mut_ptr(),
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                b" AS snum, \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sSelect, zDb_1, '\'' as i32 as libc::c_char);
                            appendText(
                                &mut sSelect,
                                b" AS sname FROM \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sSelect, zDb_1, quoteChar(zDb_1));
                            appendText(
                                &mut sSelect,
                                b".sqlite_schema\0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        sqlite3_finalize(pStmt_5);
                        if !zName.is_null() {
                            appendText(
                                &mut sSelect,
                                b" UNION ALL SELECT shell_module_schema(name), 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list\0"
                                    as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(
                            &mut sSelect,
                            b") WHERE \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if !zName.is_null() {
                            let mut zQarg: *mut libc::c_char = sqlite3_mprintf(
                                b"%Q\0" as *const u8 as *const libc::c_char,
                                zName,
                            );
                            let mut bGlob: libc::c_int = 0;
                            shell_check_oom(zQarg as *mut libc::c_void);
                            bGlob = (!(strchr(zName, '*' as i32)).is_null()
                                || !(strchr(zName, '?' as i32)).is_null()
                                || !(strchr(zName, '[' as i32)).is_null()) as libc::c_int;
                            if !(strchr(zName, '.' as i32)).is_null() {
                                appendText(
                                    &mut sSelect,
                                    b"lower(printf('%s.%s',sname,tbl_name))\0" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            } else {
                                appendText(
                                    &mut sSelect,
                                    b"lower(tbl_name)\0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                if bGlob != 0 {
                                    b" GLOB \0" as *const u8 as *const libc::c_char
                                } else {
                                    b" LIKE \0" as *const u8 as *const libc::c_char
                                },
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                zQarg,
                                0 as libc::c_int as libc::c_char,
                            );
                            if bGlob == 0 {
                                appendText(
                                    &mut sSelect,
                                    b" ESCAPE '\\' \0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b" AND \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            sqlite3_free(zQarg as *mut libc::c_void);
                        }
                        if bNoSystemTabs != 0 {
                            appendText(
                                &mut sSelect,
                                b"name NOT LIKE 'sqlite_%%' AND \0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(
                            &mut sSelect,
                            b"sql IS NOT NULL ORDER BY snum, rowid\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if bDebug != 0 {
                            fprintf(
                                (*p).out,
                                b"SQL: %s;\n\0" as *const u8 as *const libc::c_char,
                                sSelect.z,
                            );
                        } else {
                            rc = sqlite3_exec(
                                (*p).db,
                                sSelect.z,
                                Some(
                                    callback
                                        as unsafe extern "C" fn(
                                            *mut libc::c_void,
                                            libc::c_int,
                                            *mut *mut libc::c_char,
                                            *mut *mut libc::c_char,
                                        ) -> libc::c_int,
                                ),
                                &mut data_0 as *mut ShellState as *mut libc::c_void,
                                &mut zErrMsg_0,
                            );
                        }
                        freeText(&mut sSelect);
                        current_block = 9397180409927122761;
                    }
                } else {
                    current_block = 9397180409927122761;
                }
                match current_block {
                    5240171864706220143 => {}
                    _ => {
                        if !zErrMsg_0.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                zErrMsg_0,
                            );
                            sqlite3_free(zErrMsg_0 as *mut libc::c_void);
                            rc = 1 as libc::c_int;
                        } else if rc != 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: querying schema information\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                            rc = 1 as libc::c_int;
                        } else {
                            rc = 0 as libc::c_int;
                        }
                    }
                }
            }
        }
    } else if c == 's' as i32 && n == 11 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"selecttrace\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
        || c == 't' as i32 && n == 9 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"treetrace\0" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
    {
        let mut x_3: libc::c_uint = if nArg >= 2 as libc::c_int {
            integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
        } else {
            0xffffffff as libc::c_uint
        };
        sqlite3_test_control(
            31 as libc::c_int,
            1 as libc::c_int,
            &mut x_3 as *mut libc::c_uint,
        );
    } else if c == 's' as i32 && n >= 4 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"selftest\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut bIsInit: libc::c_int = 0 as libc::c_int;
        let mut bVerbose: libc::c_int = 0 as libc::c_int;
        let mut bSelftestExists: libc::c_int = 0;
        let mut i_12: libc::c_int = 0;
        let mut k: libc::c_int = 0;
        let mut nTest: libc::c_int = 0 as libc::c_int;
        let mut nErr: libc::c_int = 0 as libc::c_int;
        let mut str: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut pStmt_6: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        open_db(p, 0 as libc::c_int);
        i_12 = 1 as libc::c_int;
        loop {
            if !(i_12 < nArg) {
                current_block = 13478971412006294660;
                break;
            }
            let mut z_9: *const libc::c_char = azArg[i_12 as usize];
            if *z_9.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *z_9.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                z_9 = z_9.offset(1);
            }
            if strcmp(z_9, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bIsInit = 1 as libc::c_int;
            } else if strcmp(z_9, b"-v\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bVerbose += 1;
            } else {
                fprintf(
                    stderr,
                    b"Unknown option \"%s\" on \"%s\"\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[i_12 as usize],
                    azArg[0 as libc::c_int as usize],
                );
                fprintf(
                    stderr,
                    b"Should be one of: --init -v\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            }
            i_12 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if sqlite3_table_column_metadata(
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    b"selftest\0" as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                ) != 0 as libc::c_int
                {
                    bSelftestExists = 0 as libc::c_int;
                } else {
                    bSelftestExists = 1 as libc::c_int;
                }
                if bIsInit != 0 {
                    createSelftestTable(p);
                    bSelftestExists = 1 as libc::c_int;
                }
                initText(&mut str);
                appendText(
                    &mut str,
                    b"x\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                k = bSelftestExists;
                loop {
                    if !(k >= 0 as libc::c_int) {
                        current_block = 16565263184454850237;
                        break;
                    }
                    if k == 1 as libc::c_int {
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\0"
                                as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_6,
                            0 as *mut *const libc::c_char,
                        );
                    } else {
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),      (1,'run','PRAGMA integrity_check','ok')\0"
                                as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_6,
                            0 as *mut *const libc::c_char,
                        );
                    }
                    if rc != 0 {
                        fprintf(
                            stderr,
                            b"Error querying the selftest table\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        sqlite3_finalize(pStmt_6);
                        current_block = 5240171864706220143;
                        break;
                    } else {
                        i_12 = 1 as libc::c_int;
                        while sqlite3_step(pStmt_6) == 100 as libc::c_int {
                            let mut tno: libc::c_int = sqlite3_column_int(
                                pStmt_6,
                                0 as libc::c_int,
                            );
                            let mut zOp: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                1 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zSql_4: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                2 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zAns: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                3 as libc::c_int,
                            ) as *const libc::c_char;
                            if !zOp.is_null() {
                                if !zSql_4.is_null() {
                                    if !zAns.is_null() {
                                        k = 0 as libc::c_int;
                                        if bVerbose > 0 as libc::c_int {
                                            printf(
                                                b"%d: %s %s\n\0" as *const u8 as *const libc::c_char,
                                                tno,
                                                zOp,
                                                zSql_4,
                                            );
                                        }
                                        if strcmp(
                                            zOp,
                                            b"memo\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                        {
                                            fprintf(
                                                (*p).out,
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                zSql_4,
                                            );
                                        } else if strcmp(
                                            zOp,
                                            b"run\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                        {
                                            let mut zErrMsg_1: *mut libc::c_char = 0
                                                as *mut libc::c_char;
                                            str.n = 0 as libc::c_int;
                                            *(str.z)
                                                .offset(
                                                    0 as libc::c_int as isize,
                                                ) = 0 as libc::c_int as libc::c_char;
                                            rc = sqlite3_exec(
                                                (*p).db,
                                                zSql_4,
                                                Some(
                                                    captureOutputCallback
                                                        as unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            libc::c_int,
                                                            *mut *mut libc::c_char,
                                                            *mut *mut libc::c_char,
                                                        ) -> libc::c_int,
                                                ),
                                                &mut str as *mut ShellText as *mut libc::c_void,
                                                &mut zErrMsg_1,
                                            );
                                            nTest += 1;
                                            if bVerbose != 0 {
                                                fprintf(
                                                    (*p).out,
                                                    b"Result: %s\n\0" as *const u8 as *const libc::c_char,
                                                    str.z,
                                                );
                                            }
                                            if rc != 0 || !zErrMsg_1.is_null() {
                                                nErr += 1;
                                                rc = 1 as libc::c_int;
                                                fprintf(
                                                    (*p).out,
                                                    b"%d: error-code-%d: %s\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    rc,
                                                    zErrMsg_1,
                                                );
                                                sqlite3_free(zErrMsg_1 as *mut libc::c_void);
                                            } else if strcmp(zAns, str.z) != 0 as libc::c_int {
                                                nErr += 1;
                                                rc = 1 as libc::c_int;
                                                fprintf(
                                                    (*p).out,
                                                    b"%d: Expected: [%s]\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    zAns,
                                                );
                                                fprintf(
                                                    (*p).out,
                                                    b"%d:      Got: [%s]\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    str.z,
                                                );
                                            }
                                        } else {
                                            fprintf(
                                                stderr,
                                                b"Unknown operation \"%s\" on selftest line %d\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                zOp,
                                                tno,
                                            );
                                            rc = 1 as libc::c_int;
                                            break;
                                        }
                                    }
                                }
                            }
                            i_12 += 1;
                        }
                        sqlite3_finalize(pStmt_6);
                        k -= 1;
                    }
                }
                match current_block {
                    5240171864706220143 => {}
                    _ => {
                        freeText(&mut str);
                        fprintf(
                            (*p).out,
                            b"%d errors out of %d tests\n\0" as *const u8
                                as *const libc::c_char,
                            nErr,
                            nTest,
                        );
                    }
                }
            }
        }
    } else if c == 's' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"separator\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg < 2 as libc::c_int || nArg > 3 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .separator COL ?ROW?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
        if nArg >= 2 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).colSeparator).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int,
                azArg[1 as libc::c_int as usize],
            );
        }
        if nArg >= 3 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).rowSeparator).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int,
                azArg[2 as libc::c_int as usize],
            );
        }
    } else if c == 's' as i32 && n >= 4 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"sha3sum\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zLike_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_13: libc::c_int = 0;
        let mut bSchema: libc::c_int = 0 as libc::c_int;
        let mut bSeparate: libc::c_int = 0 as libc::c_int;
        let mut iSize: libc::c_int = 224 as libc::c_int;
        let mut bDebug_0: libc::c_int = 0 as libc::c_int;
        let mut pStmt_7: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zSql_5: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSep_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut sSql: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut sQuery: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        open_db(p, 0 as libc::c_int);
        i_13 = 1 as libc::c_int;
        loop {
            if !(i_13 < nArg) {
                current_block = 14729575995664663948;
                break;
            }
            let mut z_10: *const libc::c_char = azArg[i_13 as usize];
            if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_10 = z_10.offset(1);
                if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_10 = z_10.offset(1);
                }
                if strcmp(z_10, b"schema\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bSchema = 1 as libc::c_int;
                } else if strcmp(z_10, b"sha3-224\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    || strcmp(z_10, b"sha3-256\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    || strcmp(z_10, b"sha3-384\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    || strcmp(z_10, b"sha3-512\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    iSize = atoi(&*z_10.offset(5 as libc::c_int as isize));
                } else if strcmp(z_10, b"debug\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bDebug_0 = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_13 as usize],
                        azArg[0 as libc::c_int as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    current_block = 5240171864706220143;
                    break;
                }
            } else if !zLike_0.is_null() {
                fprintf(
                    stderr,
                    b"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 5240171864706220143;
                break;
            } else {
                zLike_0 = z_10;
                bSeparate = 1 as libc::c_int;
                if sqlite3_strlike(
                    b"sqlite\\_%\0" as *const u8 as *const libc::c_char,
                    zLike_0,
                    '\\' as i32 as libc::c_uint,
                ) == 0 as libc::c_int
                {
                    bSchema = 1 as libc::c_int;
                }
            }
            i_13 += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if bSchema != 0 {
                    zSql_5 = b"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 UNION ALL SELECT 'sqlite_schema' ORDER BY 1 collate nocase\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                } else {
                    zSql_5 = b"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 AND name NOT LIKE 'sqlite_%' ORDER BY 1 collate nocase\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                }
                sqlite3_prepare_v2(
                    (*p).db,
                    zSql_5,
                    -(1 as libc::c_int),
                    &mut pStmt_7,
                    0 as *mut *const libc::c_char,
                );
                initText(&mut sQuery);
                initText(&mut sSql);
                appendText(
                    &mut sSql,
                    b"WITH [sha3sum$query](a,b) AS(\0" as *const u8
                        as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                zSep_0 = b"VALUES(\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                while 100 as libc::c_int == sqlite3_step(pStmt_7) {
                    let mut zTab: *const libc::c_char = sqlite3_column_text(
                        pStmt_7,
                        0 as libc::c_int,
                    ) as *const libc::c_char;
                    if zTab.is_null() {
                        continue;
                    }
                    if !zLike_0.is_null()
                        && sqlite3_strlike(
                            zLike_0,
                            zTab,
                            0 as libc::c_int as libc::c_uint,
                        ) != 0 as libc::c_int
                    {
                        continue;
                    }
                    if strncmp(
                        zTab,
                        b"sqlite_\0" as *const u8 as *const libc::c_char,
                        7 as libc::c_int as libc::c_ulong,
                    ) != 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT * FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sQuery, zTab, '"' as i32 as libc::c_char);
                        appendText(
                            &mut sQuery,
                            b" NOT INDEXED;\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if strcmp(
                        zTab,
                        b"sqlite_schema\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if strcmp(
                        zTab,
                        b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT name,seq FROM sqlite_sequence ORDER BY name;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if strcmp(
                        zTab,
                        b"sqlite_stat1\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if strcmp(
                        zTab,
                        b"sqlite_stat4\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT * FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sQuery, zTab, 0 as libc::c_int as libc::c_char);
                        appendText(
                            &mut sQuery,
                            b" ORDER BY tbl, idx, rowid;\n\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    appendText(&mut sSql, zSep_0, 0 as libc::c_int as libc::c_char);
                    appendText(&mut sSql, sQuery.z, '\'' as i32 as libc::c_char);
                    sQuery.n = 0 as libc::c_int;
                    appendText(
                        &mut sSql,
                        b",\0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    appendText(&mut sSql, zTab, '\'' as i32 as libc::c_char);
                    zSep_0 = b"),(\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                }
                sqlite3_finalize(pStmt_7);
                if bSeparate != 0 {
                    zSql_5 = sqlite3_mprintf(
                        b"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\0"
                            as *const u8 as *const libc::c_char,
                        sSql.z,
                        iSize,
                    );
                } else {
                    zSql_5 = sqlite3_mprintf(
                        b"%s)) SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash   FROM [sha3sum$query]\0"
                            as *const u8 as *const libc::c_char,
                        sSql.z,
                        iSize,
                    );
                }
                shell_check_oom(zSql_5 as *mut libc::c_void);
                freeText(&mut sQuery);
                freeText(&mut sSql);
                if bDebug_0 != 0 {
                    fprintf(
                        (*p).out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        zSql_5,
                    );
                } else {
                    shell_exec(p, zSql_5, 0 as *mut *mut libc::c_char);
                }
                sqlite3_free(zSql_5 as *mut libc::c_void);
            }
        }
    } else if c == 's' as i32
        && (strncmp(
            azArg[0 as libc::c_int as usize],
            b"shell\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
            || strncmp(
                azArg[0 as libc::c_int as usize],
                b"system\0" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int)
    {
        let mut zCmd_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut i_14: libc::c_int = 0;
        let mut x_4: libc::c_int = 0;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        if nArg < 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .system COMMAND\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            zCmd_0 = sqlite3_mprintf(
                if (strchr(azArg[1 as libc::c_int as usize], ' ' as i32)).is_null() {
                    b"%s\0" as *const u8 as *const libc::c_char
                } else {
                    b"\"%s\"\0" as *const u8 as *const libc::c_char
                },
                azArg[1 as libc::c_int as usize],
            );
            i_14 = 2 as libc::c_int;
            while i_14 < nArg && !zCmd_0.is_null() {
                zCmd_0 = sqlite3_mprintf(
                    if (strchr(azArg[i_14 as usize], ' ' as i32)).is_null() {
                        b"%z %s\0" as *const u8 as *const libc::c_char
                    } else {
                        b"%z \"%s\"\0" as *const u8 as *const libc::c_char
                    },
                    zCmd_0,
                    azArg[i_14 as usize],
                );
                i_14 += 1;
            }
            x_4 = if !zCmd_0.is_null() { system(zCmd_0) } else { 1 as libc::c_int };
            sqlite3_free(zCmd_0 as *mut libc::c_void);
            if x_4 != 0 {
                fprintf(
                    stderr,
                    b"System command returns %d\n\0" as *const u8 as *const libc::c_char,
                    x_4,
                );
            }
        }
    } else if c == 's' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"show\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        static mut azBool: [*const libc::c_char; 4] = [
            b"off\0" as *const u8 as *const libc::c_char,
            b"on\0" as *const u8 as *const libc::c_char,
            b"trigger\0" as *const u8 as *const libc::c_char,
            b"full\0" as *const u8 as *const libc::c_char,
        ];
        let mut zOut: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_15: libc::c_int = 0;
        if nArg != 1 as libc::c_int {
            fprintf(stderr, b"Usage: .show\n\0" as *const u8 as *const libc::c_char);
            rc = 1 as libc::c_int;
        } else {
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"echo\0" as *const u8 as *const libc::c_char,
                azBool[((*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint) as libc::c_int as usize],
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"eqp\0" as *const u8 as *const libc::c_char,
                azBool[((*p).autoEQP as libc::c_int & 3 as libc::c_int) as usize],
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"explain\0" as *const u8 as *const libc::c_char,
                if (*p).mode == 9 as libc::c_int {
                    b"on\0" as *const u8 as *const libc::c_char
                } else if (*p).autoExplain as libc::c_int != 0 {
                    b"auto\0" as *const u8 as *const libc::c_char
                } else {
                    b"off\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"headers\0" as *const u8 as *const libc::c_char,
                azBool[((*p).showHeader != 0 as libc::c_int) as libc::c_int as usize],
            );
            if (*p).mode == 1 as libc::c_int
                || (*p).mode >= 14 as libc::c_int && (*p).mode <= 16 as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s --wrap %d --wordwrap %s --%squote\n\0" as *const u8
                        as *const libc::c_char,
                    b"mode\0" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                    (*p).cmOpts.iWrap,
                    if (*p).cmOpts.bWordWrap as libc::c_int != 0 {
                        b"on\0" as *const u8 as *const libc::c_char
                    } else {
                        b"off\0" as *const u8 as *const libc::c_char
                    },
                    if (*p).cmOpts.bQuote as libc::c_int != 0 {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b"no\0" as *const u8 as *const libc::c_char
                    },
                );
            } else {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                    b"mode\0" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                );
            }
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"nullvalue\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).nullValue).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"output\0" as *const u8 as *const libc::c_char,
                if strlen30(((*p).outfile).as_mut_ptr()) != 0 {
                    ((*p).outfile).as_mut_ptr() as *const libc::c_char
                } else {
                    b"stdout\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"colseparator\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).colSeparator).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"rowseparator\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).rowSeparator).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            match (*p).statsOn {
                0 => {
                    zOut = b"off\0" as *const u8 as *const libc::c_char;
                }
                2 => {
                    zOut = b"stmt\0" as *const u8 as *const libc::c_char;
                }
                3 => {
                    zOut = b"vmstep\0" as *const u8 as *const libc::c_char;
                }
                _ => {
                    zOut = b"on\0" as *const u8 as *const libc::c_char;
                }
            }
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"stats\0" as *const u8 as *const libc::c_char,
                zOut,
            );
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"width\0" as *const u8 as *const libc::c_char,
            );
            i_15 = 0 as libc::c_int;
            while i_15 < (*p).nWidth {
                fprintf(
                    (*p).out,
                    b"%d \0" as *const u8 as *const libc::c_char,
                    *((*p).colWidth).offset(i_15 as isize),
                );
                i_15 += 1;
            }
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"filename\0" as *const u8 as *const libc::c_char,
                if !((*(*p).pAuxDb).zDbFilename).is_null() {
                    (*(*p).pAuxDb).zDbFilename
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
        }
    } else if c == 's' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"stats\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            if strcmp(
                azArg[1 as libc::c_int as usize],
                b"stmt\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).statsOn = 2 as libc::c_int as libc::c_uint;
            } else if strcmp(
                azArg[1 as libc::c_int as usize],
                b"vmstep\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).statsOn = 3 as libc::c_int as libc::c_uint;
            } else {
                (*p)
                    .statsOn = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0
                    as libc::c_uint;
            }
        } else if nArg == 1 as libc::c_int {
            display_stats((*p).db, p, 0 as libc::c_int);
        } else {
            fprintf(
                stderr,
                b"Usage: .stats ?on|off|stmt|vmstep?\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 't' as i32 && n > 1 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"tables\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
        || c == 'i' as i32
            && (strncmp(
                azArg[0 as libc::c_int as usize],
                b"indices\0" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
                || strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"indexes\0" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                ) == 0 as libc::c_int)
    {
        let mut pStmt_8: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut azResult: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut nRow: libc::c_int = 0;
        let mut nAlloc: libc::c_int = 0;
        let mut ii_1: libc::c_int = 0;
        let mut s: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        initText(&mut s);
        open_db(p, 0 as libc::c_int);
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt_8,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            sqlite3_finalize(pStmt_8);
            return shellDatabaseError((*p).db);
        }
        if nArg > 2 as libc::c_int && c == 'i' as i32 {
            fprintf(
                stderr,
                b"Usage: .indexes ?LIKE-PATTERN?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
            sqlite3_finalize(pStmt_8);
        } else {
            ii_1 = 0 as libc::c_int;
            while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                let mut zDbName: *const libc::c_char = sqlite3_column_text(
                    pStmt_8,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                if !zDbName.is_null() {
                    if !(s.z).is_null()
                        && *(s.z).offset(0 as libc::c_int as isize) as libc::c_int != 0
                    {
                        appendText(
                            &mut s,
                            b" UNION ALL \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    if sqlite3_stricmp(
                        zDbName,
                        b"main\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut s,
                            b"SELECT name FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else {
                        appendText(
                            &mut s,
                            b"SELECT \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut s, zDbName, '\'' as i32 as libc::c_char);
                        appendText(
                            &mut s,
                            b"||'.'||name FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    appendText(&mut s, zDbName, '"' as i32 as libc::c_char);
                    appendText(
                        &mut s,
                        b".sqlite_schema \0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    if c == 't' as i32 {
                        appendText(
                            &mut s,
                            b" WHERE type IN ('table','view')   AND name NOT LIKE 'sqlite_%'   AND name LIKE ?1\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else {
                        appendText(
                            &mut s,
                            b" WHERE type='index'   AND tbl_name LIKE ?1\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                }
                ii_1 += 1;
            }
            rc = sqlite3_finalize(pStmt_8);
            if rc == 0 as libc::c_int {
                appendText(
                    &mut s,
                    b" ORDER BY 1\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    s.z,
                    -(1 as libc::c_int),
                    &mut pStmt_8,
                    0 as *mut *const libc::c_char,
                );
            }
            freeText(&mut s);
            if rc != 0 {
                return shellDatabaseError((*p).db);
            }
            nAlloc = 0 as libc::c_int;
            nRow = nAlloc;
            azResult = 0 as *mut *mut libc::c_char;
            if nArg > 1 as libc::c_int {
                sqlite3_bind_text(
                    pStmt_8,
                    1 as libc::c_int,
                    azArg[1 as libc::c_int as usize],
                    -(1 as libc::c_int),
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            } else {
                sqlite3_bind_text(
                    pStmt_8,
                    1 as libc::c_int,
                    b"%\0" as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    None,
                );
            }
            while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                if nRow >= nAlloc {
                    let mut azNew: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
                    let mut n2_2: libc::c_int = nAlloc * 2 as libc::c_int
                        + 10 as libc::c_int;
                    azNew = sqlite3_realloc64(
                        azResult as *mut libc::c_void,
                        (::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                            .wrapping_mul(n2_2 as libc::c_ulong) as sqlite3_uint64,
                    ) as *mut *mut libc::c_char;
                    shell_check_oom(azNew as *mut libc::c_void);
                    nAlloc = n2_2;
                    azResult = azNew;
                }
                let ref mut fresh88 = *azResult.offset(nRow as isize);
                *fresh88 = sqlite3_mprintf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pStmt_8, 0 as libc::c_int),
                );
                shell_check_oom(*azResult.offset(nRow as isize) as *mut libc::c_void);
                nRow += 1;
            }
            if sqlite3_finalize(pStmt_8) != 0 as libc::c_int {
                rc = shellDatabaseError((*p).db);
            }
            if rc == 0 as libc::c_int && nRow > 0 as libc::c_int {
                let mut len_0: libc::c_int = 0;
                let mut maxlen: libc::c_int = 0 as libc::c_int;
                let mut i_16: libc::c_int = 0;
                let mut j_1: libc::c_int = 0;
                let mut nPrintCol: libc::c_int = 0;
                let mut nPrintRow: libc::c_int = 0;
                i_16 = 0 as libc::c_int;
                while i_16 < nRow {
                    len_0 = strlen30(*azResult.offset(i_16 as isize));
                    if len_0 > maxlen {
                        maxlen = len_0;
                    }
                    i_16 += 1;
                }
                nPrintCol = 80 as libc::c_int / (maxlen + 2 as libc::c_int);
                if nPrintCol < 1 as libc::c_int {
                    nPrintCol = 1 as libc::c_int;
                }
                nPrintRow = (nRow + nPrintCol - 1 as libc::c_int) / nPrintCol;
                i_16 = 0 as libc::c_int;
                while i_16 < nPrintRow {
                    j_1 = i_16;
                    while j_1 < nRow {
                        let mut zSp: *mut libc::c_char = (if j_1 < nPrintRow {
                            b"\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        }) as *mut libc::c_char;
                        fprintf(
                            (*p).out,
                            b"%s%-*s\0" as *const u8 as *const libc::c_char,
                            zSp,
                            maxlen,
                            if !(*azResult.offset(j_1 as isize)).is_null() {
                                *azResult.offset(j_1 as isize) as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                        );
                        j_1 += nPrintRow;
                    }
                    fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
                    i_16 += 1;
                }
            }
            ii_1 = 0 as libc::c_int;
            while ii_1 < nRow {
                sqlite3_free(*azResult.offset(ii_1 as isize) as *mut libc::c_void);
                ii_1 += 1;
            }
            sqlite3_free(azResult as *mut libc::c_void);
        }
    } else if c == 't' as i32
        && strcmp(
            azArg[0 as libc::c_int as usize],
            b"testcase\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        output_reset(p);
        (*p)
            .out = output_file_open(
            b"testcase-out.txt\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
        );
        if ((*p).out).is_null() {
            fprintf(
                stderr,
                b"Error: cannot open 'testcase-out.txt'\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if nArg >= 2 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).zTestcase).as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).zTestcase).as_mut_ptr(),
                b"?\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if c == 't' as i32 && n >= 8 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"testctrl\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        static mut aCtrl_0: [C2RustUnnamed_19; 16] = [
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"always\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 13 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"assert\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 12 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"byteorder\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 22 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"extra_schema_checks\0" as *const u8
                        as *const libc::c_char,
                    ctrlCode: 29 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"imposter\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 25 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"SCHEMA ON/OFF ROOTPAGE\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"internal_functions\0" as *const u8
                        as *const libc::c_char,
                    ctrlCode: 17 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"localtime_fault\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 18 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"never_corrupt\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 20 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"optimizations\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 15 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"DISABLE-MASK\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"pending_byte\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 11 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"OFFSET  \0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_restore\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 6 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_save\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 5 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_seed\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 28 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"SEED ?db?\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"seek_count\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 30 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"sorter_mmap\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 24 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"NMAX\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"tune\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 32 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"ID VALUE\0" as *const u8 as *const libc::c_char,
                };
                init
            },
        ];
        let mut testctrl: libc::c_int = -(1 as libc::c_int);
        let mut iCtrl_0: libc::c_int = -(1 as libc::c_int);
        let mut rc2: libc::c_int = 0 as libc::c_int;
        let mut isOk_0: libc::c_int = 0 as libc::c_int;
        let mut i_17: libc::c_int = 0;
        let mut n2_3: libc::c_int = 0;
        let mut zCmd_1: *const libc::c_char = 0 as *const libc::c_char;
        open_db(p, 0 as libc::c_int);
        zCmd_1 = if nArg >= 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"help\0" as *const u8 as *const libc::c_char
        };
        if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
        {
            zCmd_1 = zCmd_1.offset(1);
            if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd_1 = zCmd_1.offset(1);
            }
        }
        if strcmp(zCmd_1, b"help\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"Available test-controls:\n\0" as *const u8 as *const libc::c_char,
            );
            i_17 = 0 as libc::c_int;
            while i_17
                < (::core::mem::size_of::<[C2RustUnnamed_19; 16]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong,
                    ) as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"  .testctrl %s %s\n\0" as *const u8 as *const libc::c_char,
                    aCtrl_0[i_17 as usize].zCtrlName,
                    aCtrl_0[i_17 as usize].zUsage,
                );
                i_17 += 1;
            }
            rc = 1 as libc::c_int;
        } else {
            n2_3 = strlen30(zCmd_1);
            i_17 = 0 as libc::c_int;
            loop {
                if !(i_17
                    < (::core::mem::size_of::<[C2RustUnnamed_19; 16]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 2793958312656670831;
                    break;
                }
                if strncmp(
                    zCmd_1,
                    aCtrl_0[i_17 as usize].zCtrlName,
                    n2_3 as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    if testctrl < 0 as libc::c_int {
                        testctrl = aCtrl_0[i_17 as usize].ctrlCode;
                        iCtrl_0 = i_17;
                    } else {
                        fprintf(
                            stderr,
                            b"Error: ambiguous test-control: \"%s\"\nUse \".testctrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd_1,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 5240171864706220143;
                        break;
                    }
                }
                i_17 += 1;
            }
            match current_block {
                5240171864706220143 => {}
                _ => {
                    if testctrl < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: unknown test-control: %s\nUse \".testctrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd_1,
                        );
                    } else if aCtrl_0[iCtrl_0 as usize].unSafe != 0
                        && (*p).bSafeMode as libc::c_int != 0
                    {
                        fprintf(
                            stderr,
                            b"line %d: \".testctrl %s\" may not be used in safe mode\n\0"
                                as *const u8 as *const libc::c_char,
                            (*p).lineno,
                            aCtrl_0[iCtrl_0 as usize].zCtrlName,
                        );
                        exit(1 as libc::c_int);
                    } else {
                        match testctrl {
                            15 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt: libc::c_uint = strtol(
                                        azArg[2 as libc::c_int as usize],
                                        0 as *mut *mut libc::c_char,
                                        0 as libc::c_int,
                                    ) as libc::c_uint;
                                    rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            5 | 6 | 22 => {
                                if nArg == 2 as libc::c_int {
                                    rc2 = sqlite3_test_control(testctrl);
                                    isOk_0 = if testctrl == 22 as libc::c_int {
                                        1 as libc::c_int
                                    } else {
                                        3 as libc::c_int
                                    };
                                }
                            }
                            11 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_0: libc::c_uint = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_uint;
                                    rc2 = sqlite3_test_control(testctrl, opt_0);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            28 => {
                                if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int {
                                    let mut ii_2: libc::c_int = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_int;
                                    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                    if ii_2 == 0 as libc::c_int
                                        && strcmp(
                                            azArg[2 as libc::c_int as usize],
                                            b"random\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                    {
                                        sqlite3_randomness(
                                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                                                as libc::c_int,
                                            &mut ii_2 as *mut libc::c_int as *mut libc::c_void,
                                        );
                                        printf(
                                            b"-- random seed: %d\n\0" as *const u8
                                                as *const libc::c_char,
                                            ii_2,
                                        );
                                    }
                                    if nArg == 3 as libc::c_int {
                                        db = 0 as *mut sqlite3;
                                    } else {
                                        db = (*p).db;
                                        sqlite3_table_column_metadata(
                                            db,
                                            0 as *const libc::c_char,
                                            b"x\0" as *const u8 as *const libc::c_char,
                                            0 as *const libc::c_char,
                                            0 as *mut *const libc::c_char,
                                            0 as *mut *const libc::c_char,
                                            0 as *mut libc::c_int,
                                            0 as *mut libc::c_int,
                                            0 as *mut libc::c_int,
                                        );
                                    }
                                    rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            12 | 13 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_1: libc::c_int = booleanValue(
                                        azArg[2 as libc::c_int as usize],
                                    );
                                    rc2 = sqlite3_test_control(testctrl, opt_1);
                                    isOk_0 = 1 as libc::c_int;
                                }
                            }
                            18 | 20 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_2: libc::c_int = booleanValue(
                                        azArg[2 as libc::c_int as usize],
                                    );
                                    rc2 = sqlite3_test_control(testctrl, opt_2);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            17 => {
                                rc2 = sqlite3_test_control(testctrl, (*p).db);
                                isOk_0 = 3 as libc::c_int;
                            }
                            25 => {
                                if nArg == 5 as libc::c_int {
                                    rc2 = sqlite3_test_control(
                                        testctrl,
                                        (*p).db,
                                        azArg[2 as libc::c_int as usize],
                                        integerValue(azArg[3 as libc::c_int as usize]),
                                        integerValue(azArg[4 as libc::c_int as usize]),
                                    );
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            30 => {
                                let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                rc2 = sqlite3_test_control(
                                    testctrl,
                                    (*p).db,
                                    &mut x_5 as *mut u64_0,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%llu\n\0" as *const u8 as *const libc::c_char,
                                    x_5,
                                );
                                isOk_0 = 3 as libc::c_int;
                            }
                            24 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_3: libc::c_int = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_uint as libc::c_int;
                                    rc2 = sqlite3_test_control(testctrl, (*p).db, opt_3);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            _ => {}
                        }
                    }
                    if isOk_0 == 0 as libc::c_int && iCtrl_0 >= 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Usage: .testctrl %s %s\n\0" as *const u8
                                as *const libc::c_char,
                            zCmd_1,
                            aCtrl_0[iCtrl_0 as usize].zUsage,
                        );
                        rc = 1 as libc::c_int;
                    } else if isOk_0 == 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%d\n\0" as *const u8 as *const libc::c_char,
                            rc2,
                        );
                    } else if isOk_0 == 2 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"0x%08x\n\0" as *const u8 as *const libc::c_char,
                            rc2,
                        );
                    }
                }
            }
        }
    } else if c == 't' as i32 && n > 4 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"timeout\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        sqlite3_busy_timeout(
            (*p).db,
            if nArg >= 2 as libc::c_int {
                integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int
            } else {
                0 as libc::c_int
            },
        );
    } else if c == 't' as i32 && n >= 5 as libc::c_int
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"timer\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            enableTimer = booleanValue(azArg[1 as libc::c_int as usize]);
            if enableTimer != 0 && 1 as libc::c_int == 0 {
                fprintf(
                    stderr,
                    b"Error: timer not available on this system.\n\0" as *const u8
                        as *const libc::c_char,
                );
                enableTimer = 0 as libc::c_int;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .timer on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 't' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"trace\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut mType: libc::c_int = 0 as libc::c_int;
        let mut jj: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        jj = 1 as libc::c_int;
        loop {
            if !(jj < nArg) {
                current_block = 8721444885065720400;
                break;
            }
            let mut z_11: *const libc::c_char = azArg[jj as usize];
            if *z_11.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if optionMatch(z_11, b"expanded\0" as *const u8 as *const libc::c_char)
                    != 0
                {
                    (*p).eTraceType = 1 as libc::c_int as u8_0;
                } else if optionMatch(
                    z_11,
                    b"plain\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    (*p).eTraceType = 0 as libc::c_int as u8_0;
                } else if optionMatch(
                    z_11,
                    b"profile\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x2 as libc::c_int;
                } else if optionMatch(z_11, b"row\0" as *const u8 as *const libc::c_char)
                    != 0
                {
                    mType |= 0x4 as libc::c_int;
                } else if optionMatch(
                    z_11,
                    b"stmt\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x1 as libc::c_int;
                } else if optionMatch(
                    z_11,
                    b"close\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x8 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \".trace\"\n\0" as *const u8
                            as *const libc::c_char,
                        z_11,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 5240171864706220143;
                    break;
                }
            } else {
                output_file_close((*p).traceOut);
                (*p)
                    .traceOut = output_file_open(
                    azArg[1 as libc::c_int as usize],
                    0 as libc::c_int,
                );
            }
            jj += 1;
        }
        match current_block {
            5240171864706220143 => {}
            _ => {
                if ((*p).traceOut).is_null() {
                    sqlite3_trace_v2(
                        (*p).db,
                        0 as libc::c_int as libc::c_uint,
                        None,
                        0 as *mut libc::c_void,
                    );
                } else {
                    if mType == 0 as libc::c_int {
                        mType = 0x1 as libc::c_int;
                    }
                    sqlite3_trace_v2(
                        (*p).db,
                        mType as libc::c_uint,
                        Some(
                            sql_trace_callback
                                as unsafe extern "C" fn(
                                    libc::c_uint,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> libc::c_int,
                        ),
                        p as *mut libc::c_void,
                    );
                }
            }
        }
    } else if c == 'v' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"version\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        fprintf(
            (*p).out,
            b"SQLite %s %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_libversion(),
            sqlite3_sourceid(),
        );
        fprintf((*p).out, b"clang-10.0.0\n\0" as *const u8 as *const libc::c_char);
    } else if c == 'v' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfsinfo\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zDbName_0: *const libc::c_char = if nArg == 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        };
        let mut pVfs: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                zDbName_0,
                27 as libc::c_int,
                &mut pVfs as *mut *mut sqlite3_vfs as *mut libc::c_void,
            );
            if !pVfs.is_null() {
                fprintf(
                    (*p).out,
                    b"vfs.zName      = \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).zName,
                );
                fprintf(
                    (*p).out,
                    b"vfs.iVersion   = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).iVersion,
                );
                fprintf(
                    (*p).out,
                    b"vfs.szOsFile   = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).szOsFile,
                );
                fprintf(
                    (*p).out,
                    b"vfs.mxPathname = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).mxPathname,
                );
            }
        }
    } else if c == 'v' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfslist\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut pVfs_0: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        let mut pCurrent: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                b"main\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                &mut pCurrent as *mut *mut sqlite3_vfs as *mut libc::c_void,
            );
        }
        pVfs_0 = sqlite3_vfs_find(0 as *const libc::c_char);
        while !pVfs_0.is_null() {
            fprintf(
                (*p).out,
                b"vfs.zName      = \"%s\"%s\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).zName,
                if pVfs_0 == pCurrent {
                    b"  <--- CURRENT\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"vfs.iVersion   = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).iVersion,
            );
            fprintf(
                (*p).out,
                b"vfs.szOsFile   = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).szOsFile,
            );
            fprintf(
                (*p).out,
                b"vfs.mxPathname = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).mxPathname,
            );
            if !((*pVfs_0).pNext).is_null() {
                fprintf(
                    (*p).out,
                    b"-----------------------------------\n\0" as *const u8
                        as *const libc::c_char,
                );
            }
            pVfs_0 = (*pVfs_0).pNext;
        }
    } else if c == 'v' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfsname\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut zDbName_1: *const libc::c_char = if nArg == 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        };
        let mut zVfsName: *mut libc::c_char = 0 as *mut libc::c_char;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                zDbName_1,
                12 as libc::c_int,
                &mut zVfsName as *mut *mut libc::c_char as *mut libc::c_void,
            );
            if !zVfsName.is_null() {
                fprintf(
                    (*p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    zVfsName,
                );
                sqlite3_free(zVfsName as *mut libc::c_void);
            }
        }
    } else if c == 'w' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"wheretrace\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut x_6: libc::c_uint = if nArg >= 2 as libc::c_int {
            integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
        } else {
            0xffffffff as libc::c_uint
        };
        sqlite3_test_control(
            31 as libc::c_int,
            3 as libc::c_int,
            &mut x_6 as *mut libc::c_uint,
        );
    } else if c == 'w' as i32
        && strncmp(
            azArg[0 as libc::c_int as usize],
            b"width\0" as *const u8 as *const libc::c_char,
            n as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        let mut j_2: libc::c_int = 0;
        if nArg
            <= (::core::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {} else {
            __assert_fail(
                b"nArg<=ArraySize(azArg)\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                22446 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 42],
                    &[libc::c_char; 42],
                >(b"int do_meta_command(char *, ShellState *)\0"))
                    .as_ptr(),
            );
        }
        (*p).nWidth = nArg - 1 as libc::c_int;
        (*p)
            .colWidth = realloc(
            (*p).colWidth as *mut libc::c_void,
            (((*p).nWidth + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong),
        ) as *mut libc::c_int;
        if ((*p).colWidth).is_null() && (*p).nWidth > 0 as libc::c_int {
            shell_out_of_memory();
        }
        if (*p).nWidth != 0 {
            (*p)
                .actualWidth = &mut *((*p).colWidth).offset((*p).nWidth as isize)
                as *mut libc::c_int;
        }
        j_2 = 1 as libc::c_int;
        while j_2 < nArg {
            *((*p).colWidth)
                .offset(
                    (j_2 - 1 as libc::c_int) as isize,
                ) = integerValue(azArg[j_2 as usize]) as libc::c_int;
            j_2 += 1;
        }
    } else {
        fprintf(
            stderr,
            b"Error: unknown command or invalid arguments:  \"%s\". Enter \".help\" for help\n\0"
                as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        rc = 1 as libc::c_int;
    }
    if (*p).outCount != 0 {
        (*p).outCount -= 1;
        if (*p).outCount == 0 as libc::c_int {
            output_reset(p);
        }
    }
    (*p).bSafeMode = (*p).bSafeModePersist;
    return rc;
}
unsafe extern "C" fn quickscan(
    mut zLine: *mut libc::c_char,
    mut qss: QuickScanState,
) -> QuickScanState {
    let mut current_block: u64;
    let mut cin: libc::c_char = 0;
    let mut cWait: libc::c_char = qss as libc::c_char;
    if cWait as libc::c_int == 0 as libc::c_int {
        current_block = 2772859450930607224;
    } else {
        current_block = 5601891728916014340;
    }
    '_PlainScan: loop {
        match current_block {
            2772859450930607224 => {
                if cWait as libc::c_int == 0 as libc::c_int {} else {
                    __assert_fail(
                        b"cWait==0\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        22497 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 49],
                            &[libc::c_char; 49],
                        >(b"QuickScanState quickscan(char *, QuickScanState)\0"))
                            .as_ptr(),
                    );
                }
                's_14: loop {
                    let fresh89 = zLine;
                    zLine = zLine.offset(1);
                    cin = *fresh89;
                    if !(cin as libc::c_int != 0 as libc::c_int) {
                        break '_PlainScan;
                    }
                    if *(*__ctype_b_loc())
                        .offset(cin as libc::c_uchar as libc::c_int as isize)
                        as libc::c_int
                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                    {
                        continue;
                    }
                    match cin as libc::c_int {
                        45 => {
                            if *zLine as libc::c_int != '-' as i32 {
                                current_block = 2370887241019905314;
                            } else {
                                loop {
                                    zLine = zLine.offset(1);
                                    cin = *zLine;
                                    if !(cin as libc::c_int != 0 as libc::c_int) {
                                        break;
                                    }
                                    if cin as libc::c_int == '\n' as i32 {
                                        current_block = 2772859450930607224;
                                        break 's_14;
                                    }
                                }
                                return qss;
                            }
                        }
                        59 => {
                            qss = ::core::mem::transmute::<
                                libc::c_uint,
                                QuickScanState,
                            >(
                                qss as libc::c_uint
                                    | QSS_EndingSemi as libc::c_int as libc::c_uint,
                            );
                            continue;
                        }
                        47 => {
                            if *zLine as libc::c_int == '*' as i32 {
                                zLine = zLine.offset(1);
                                cWait = '*' as i32 as libc::c_char;
                                qss = (cWait as libc::c_uint
                                    | qss as libc::c_uint
                                        & QSS_ScanMask as libc::c_int as libc::c_uint)
                                    as QuickScanState;
                                current_block = 5601891728916014340;
                                break;
                            } else {
                                current_block = 2370887241019905314;
                            }
                        }
                        91 => {
                            cin = ']' as i32 as libc::c_char;
                            current_block = 704277254677061422;
                        }
                        96 | 39 | 34 => {
                            current_block = 704277254677061422;
                        }
                        _ => {
                            current_block = 2370887241019905314;
                        }
                    }
                    match current_block {
                        2370887241019905314 => {
                            qss = (qss as libc::c_uint
                                & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                                | QSS_HasDark as libc::c_int as libc::c_uint)
                                as QuickScanState;
                        }
                        _ => {
                            cWait = cin;
                            qss = (QSS_HasDark as libc::c_int | cWait as libc::c_int)
                                as QuickScanState;
                            current_block = 5601891728916014340;
                            break;
                        }
                    }
                }
            }
            _ => {
                let fresh90 = zLine;
                zLine = zLine.offset(1);
                cin = *fresh90;
                if !(cin as libc::c_int != 0 as libc::c_int) {
                    break;
                }
                if !(cin as libc::c_int == cWait as libc::c_int) {
                    current_block = 5601891728916014340;
                    continue;
                }
                match cWait as libc::c_int {
                    42 => {
                        if *zLine as libc::c_int != '/' as i32 {
                            current_block = 5601891728916014340;
                            continue;
                        }
                        zLine = zLine.offset(1);
                        cWait = 0 as libc::c_int as libc::c_char;
                        qss = (0 as libc::c_int as libc::c_uint
                            | qss as libc::c_uint
                                & QSS_ScanMask as libc::c_int as libc::c_uint)
                            as QuickScanState;
                        current_block = 2772859450930607224;
                        continue;
                    }
                    96 | 39 | 34 => {
                        if *zLine as libc::c_int == cWait as libc::c_int {
                            zLine = zLine.offset(1);
                            current_block = 5601891728916014340;
                            continue;
                        }
                    }
                    93 => {}
                    _ => {
                        __assert_fail(
                            b"0\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            22554 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 49],
                                &[libc::c_char; 49],
                            >(b"QuickScanState quickscan(char *, QuickScanState)\0"))
                                .as_ptr(),
                        );
                        current_block = 5601891728916014340;
                        continue;
                    }
                }
                cWait = 0 as libc::c_int as libc::c_char;
                qss = (0 as libc::c_int as libc::c_uint
                    | qss as libc::c_uint & QSS_ScanMask as libc::c_int as libc::c_uint)
                    as QuickScanState;
                current_block = 2772859450930607224;
            }
        }
    }
    return qss;
}
unsafe extern "C" fn line_is_command_terminator(
    mut zLine: *mut libc::c_char,
) -> libc::c_int {
    while *(*__ctype_b_loc())
        .offset(
            *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                as isize,
        ) as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        zLine = zLine.offset(1);
    }
    if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        zLine = zLine.offset(1 as libc::c_int as isize);
    } else if tolower(
        *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int,
    ) as libc::c_char as libc::c_int == 'g' as i32
        && tolower(
            *zLine.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int,
        ) as libc::c_char as libc::c_int == 'o' as i32
    {
        zLine = zLine.offset(2 as libc::c_int as isize);
    } else {
        return 0 as libc::c_int
    }
    return (quickscan(zLine, QSS_Start) as libc::c_uint
        == QSS_Start as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn line_is_complete(
    mut zSql: *mut libc::c_char,
    mut nSql: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if zSql.is_null() {
        return 1 as libc::c_int;
    }
    *zSql.offset(nSql as isize) = ';' as i32 as libc::c_char;
    *zSql.offset((nSql + 1 as libc::c_int) as isize) = 0 as libc::c_int as libc::c_char;
    rc = sqlite3_complete(zSql);
    *zSql.offset(nSql as isize) = 0 as libc::c_int as libc::c_char;
    return rc;
}
unsafe extern "C" fn runOneSqlLine(
    mut p: *mut ShellState,
    mut zSql: *mut libc::c_char,
    mut in_0: *mut FILE,
    mut startline: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    open_db(p, 0 as libc::c_int);
    if (*p).shellFlgs & 0x4 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        resolve_backslashes(zSql);
    }
    if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
        (*p).nProgress = 0 as libc::c_int as libc::c_uint;
    }
    beginTimer();
    rc = shell_exec(p, zSql, &mut zErrMsg);
    endTimer();
    if rc != 0 || !zErrMsg.is_null() {
        let mut zPrefix: [libc::c_char; 100] = [0; 100];
        let mut zErrorTail: *const libc::c_char = 0 as *const libc::c_char;
        let mut zErrorType: *const libc::c_char = 0 as *const libc::c_char;
        if zErrMsg.is_null() {
            zErrorType = b"Error\0" as *const u8 as *const libc::c_char;
            zErrorTail = sqlite3_errmsg((*p).db);
        } else if strncmp(
            zErrMsg,
            b"in prepare, \0" as *const u8 as *const libc::c_char,
            12 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            zErrorType = b"Parse error\0" as *const u8 as *const libc::c_char;
            zErrorTail = &mut *zErrMsg.offset(12 as libc::c_int as isize)
                as *mut libc::c_char;
        } else if strncmp(
            zErrMsg,
            b"stepping, \0" as *const u8 as *const libc::c_char,
            10 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            zErrorType = b"Runtime error\0" as *const u8 as *const libc::c_char;
            zErrorTail = &mut *zErrMsg.offset(10 as libc::c_int as isize)
                as *mut libc::c_char;
        } else {
            zErrorType = b"Error\0" as *const u8 as *const libc::c_char;
            zErrorTail = zErrMsg;
        }
        if !in_0.is_null() || stdin_is_interactive == 0 {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"%s near line %d:\0" as *const u8 as *const libc::c_char,
                zErrorType,
                startline,
            );
        } else {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"%s:\0" as *const u8 as *const libc::c_char,
                zErrorType,
            );
        }
        fprintf(
            stderr,
            b"%s %s\n\0" as *const u8 as *const libc::c_char,
            zPrefix.as_mut_ptr(),
            zErrorTail,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
        zErrMsg = 0 as *mut libc::c_char;
        return 1 as libc::c_int;
    } else {
        if (*p).shellFlgs & 0x20 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        {
            let mut zLineBuf: [libc::c_char; 2000] = [0; 2000];
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 2000]>() as libc::c_ulong
                    as libc::c_int,
                zLineBuf.as_mut_ptr(),
                b"changes: %lld   total_changes: %lld\0" as *const u8
                    as *const libc::c_char,
                sqlite3_changes64((*p).db),
                sqlite3_total_changes64((*p).db),
            );
            fprintf(
                (*p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                zLineBuf.as_mut_ptr(),
            );
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn echo_group_input(
    mut p: *mut ShellState,
    mut zDo: *const libc::c_char,
) {
    if (*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        fprintf((*p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zDo);
    }
}
unsafe extern "C" fn process_input(mut p: *mut ShellState) -> libc::c_int {
    let mut zLine: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nLine: libc::c_int = 0;
    let mut nSql: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0;
    let mut errCnt: libc::c_int = 0 as libc::c_int;
    let mut startline: libc::c_int = 0 as libc::c_int;
    let mut qss: QuickScanState = QSS_Start;
    if (*p).inputNesting == 25 as libc::c_int {
        fprintf(
            stderr,
            b"Input nesting limit (%d) reached at line %d. Check recursion.\n\0"
                as *const u8 as *const libc::c_char,
            25 as libc::c_int,
            (*p).lineno,
        );
        return 1 as libc::c_int;
    }
    (*p).inputNesting += 1;
    (*p).lineno = 0 as libc::c_int;
    while errCnt == 0 as libc::c_int || bail_on_error == 0
        || ((*p).in_0).is_null() && stdin_is_interactive != 0
    {
        fflush((*p).out);
        zLine = one_input_line(
            (*p).in_0,
            zLine,
            (nSql > 0 as libc::c_int) as libc::c_int,
        );
        if zLine.is_null() {
            if ((*p).in_0).is_null() && stdin_is_interactive != 0 {
                printf(b"\n\0" as *const u8 as *const libc::c_char);
            }
            break;
        } else {
            if seenInterrupt != 0 {
                if !((*p).in_0).is_null() {
                    break;
                }
                ::core::ptr::write_volatile(
                    &mut seenInterrupt as *mut libc::c_int,
                    0 as libc::c_int,
                );
            }
            (*p).lineno += 1;
            if qss as libc::c_uint & QSS_CharMask as libc::c_int as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && line_is_command_terminator(zLine) != 0
                && line_is_complete(zSql, nSql) != 0
            {
                memcpy(
                    zLine as *mut libc::c_void,
                    b";\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            }
            qss = quickscan(zLine, qss);
            if qss as libc::c_uint & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint && nSql == 0 as libc::c_int
            {
                echo_group_input(p, zLine);
                qss = QSS_Start;
            } else if !zLine.is_null()
                && (*zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                    || *zLine.offset(0 as libc::c_int as isize) as libc::c_int
                        == '#' as i32) && nSql == 0 as libc::c_int
            {
                echo_group_input(p, zLine);
                if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                {
                    rc = do_meta_command(zLine, p);
                    if rc == 2 as libc::c_int {
                        break;
                    }
                    if rc != 0 {
                        errCnt += 1;
                    }
                }
                qss = QSS_Start;
            } else {
                nLine = strlen30(zLine);
                if nSql + nLine + 2 as libc::c_int >= nAlloc {
                    nAlloc = nSql + (nSql >> 1 as libc::c_int) + nLine
                        + 100 as libc::c_int;
                    zSql = realloc(zSql as *mut libc::c_void, nAlloc as libc::c_ulong)
                        as *mut libc::c_char;
                    shell_check_oom(zSql as *mut libc::c_void);
                }
                if nSql == 0 as libc::c_int {
                    let mut i: libc::c_int = 0;
                    i = 0 as libc::c_int;
                    while *zLine.offset(i as isize) as libc::c_int != 0
                        && *(*__ctype_b_loc())
                            .offset(
                                *zLine.offset(i as isize) as libc::c_uchar as libc::c_int
                                    as isize,
                            ) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        i += 1;
                    }
                    if nAlloc > 0 as libc::c_int && !zSql.is_null() {} else {
                        __assert_fail(
                            b"nAlloc>0 && zSql!=0\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            22766 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 32],
                                &[libc::c_char; 32],
                            >(b"int process_input(ShellState *)\0"))
                                .as_ptr(),
                        );
                    }
                    memcpy(
                        zSql as *mut libc::c_void,
                        zLine.offset(i as isize) as *const libc::c_void,
                        (nLine + 1 as libc::c_int - i) as libc::c_ulong,
                    );
                    startline = (*p).lineno;
                    nSql = nLine - i;
                } else {
                    let fresh91 = nSql;
                    nSql = nSql + 1;
                    *zSql.offset(fresh91 as isize) = '\n' as i32 as libc::c_char;
                    memcpy(
                        zSql.offset(nSql as isize) as *mut libc::c_void,
                        zLine as *const libc::c_void,
                        (nLine + 1 as libc::c_int) as libc::c_ulong,
                    );
                    nSql += nLine;
                }
                if nSql != 0
                    && qss as libc::c_uint
                        & !(QSS_HasDark as libc::c_int) as libc::c_uint
                        == QSS_EndingSemi as libc::c_int as libc::c_uint
                    && sqlite3_complete(zSql) != 0
                {
                    echo_group_input(p, zSql);
                    errCnt += runOneSqlLine(p, zSql, (*p).in_0, startline);
                    nSql = 0 as libc::c_int;
                    if (*p).outCount != 0 {
                        output_reset(p);
                        (*p).outCount = 0 as libc::c_int;
                    } else {
                        clearTempFile(p);
                    }
                    (*p).bSafeMode = (*p).bSafeModePersist;
                    qss = QSS_Start;
                } else if nSql != 0
                    && qss as libc::c_uint
                        & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                        == QSS_Start as libc::c_int as libc::c_uint
                {
                    echo_group_input(p, zSql);
                    nSql = 0 as libc::c_int;
                    qss = QSS_Start;
                }
            }
        }
    }
    if nSql != 0 {
        echo_group_input(p, zSql);
        errCnt += runOneSqlLine(p, zSql, (*p).in_0, startline);
    }
    free(zSql as *mut libc::c_void);
    free(zLine as *mut libc::c_void);
    (*p).inputNesting -= 1;
    return (errCnt > 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn find_home_dir(mut clearFlag: libc::c_int) -> *mut libc::c_char {
    static mut home_dir: *mut libc::c_char = 0 as *const libc::c_char
        as *mut libc::c_char;
    if clearFlag != 0 {
        free(home_dir as *mut libc::c_void);
        home_dir = 0 as *mut libc::c_char;
        return 0 as *mut libc::c_char;
    }
    if !home_dir.is_null() {
        return home_dir;
    }
    let mut pwent: *mut passwd = 0 as *mut passwd;
    let mut uid: uid_t = getuid();
    pwent = getpwuid(uid);
    if !pwent.is_null() {
        home_dir = (*pwent).pw_dir;
    }
    if home_dir.is_null() {
        home_dir = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    }
    if !home_dir.is_null() {
        let mut n: libc::c_int = strlen30(home_dir) + 1 as libc::c_int;
        let mut z: *mut libc::c_char = malloc(n as libc::c_ulong) as *mut libc::c_char;
        if !z.is_null() {
            memcpy(
                z as *mut libc::c_void,
                home_dir as *const libc::c_void,
                n as libc::c_ulong,
            );
        }
        home_dir = z;
    }
    return home_dir;
}
unsafe extern "C" fn process_sqliterc(
    mut p: *mut ShellState,
    mut sqliterc_override: *const libc::c_char,
) {
    let mut home_dir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sqliterc: *const libc::c_char = sqliterc_override;
    let mut zBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut inSaved: *mut FILE = (*p).in_0;
    let mut savedLineno: libc::c_int = (*p).lineno;
    if sqliterc.is_null() {
        home_dir = find_home_dir(0 as libc::c_int);
        if home_dir.is_null() {
            fprintf(
                stderr,
                b"-- warning: cannot find home directory; cannot read ~/.sqliterc\n\0"
                    as *const u8 as *const libc::c_char,
            );
            return;
        }
        zBuf = sqlite3_mprintf(
            b"%s/.sqliterc\0" as *const u8 as *const libc::c_char,
            home_dir,
        );
        shell_check_oom(zBuf as *mut libc::c_void);
        sqliterc = zBuf;
    }
    (*p).in_0 = fopen(sqliterc, b"rb\0" as *const u8 as *const libc::c_char);
    if !((*p).in_0).is_null() {
        if stdin_is_interactive != 0 {
            fprintf(
                stderr,
                b"-- Loading resources from %s\n\0" as *const u8 as *const libc::c_char,
                sqliterc,
            );
        }
        if process_input(p) != 0 && bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
        fclose((*p).in_0);
    } else if !sqliterc_override.is_null() {
        fprintf(
            stderr,
            b"cannot open: \"%s\"\n\0" as *const u8 as *const libc::c_char,
            sqliterc,
        );
        if bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
    }
    (*p).in_0 = inSaved;
    (*p).lineno = savedLineno;
    sqlite3_free(zBuf as *mut libc::c_void);
}
static mut zOptions: [libc::c_char; 2043] = unsafe {
    *::core::mem::transmute::<
        &[u8; 2043],
        &[libc::c_char; 2043],
    >(
        b"   -append              append the database to the end of the file\n   -ascii               set output mode to 'ascii'\n   -bail                stop after hitting an error\n   -batch               force batch I/O\n   -box                 set output mode to 'box'\n   -column              set output mode to 'column'\n   -cmd COMMAND         run \"COMMAND\" before reading stdin\n   -csv                 set output mode to 'csv'\n   -deserialize         open the database using sqlite3_deserialize()\n   -echo                print inputs before execution\n   -init FILENAME       read/process named file\n   -[no]header          turn headers on or off\n   -help                show this message\n   -html                set output mode to HTML\n   -interactive         force interactive I/O\n   -json                set output mode to 'json'\n   -line                set output mode to 'line'\n   -list                set output mode to 'list'\n   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n   -markdown            set output mode to 'markdown'\n   -maxsize N           maximum size for a --deserialize database\n   -memtrace            trace all memory allocations and deallocations\n   -mmap N              default mmap size set to N\n   -newline SEP         set output row separator. Default: '\\n'\n   -nofollow            refuse to open symbolic links to database files\n   -nonce STRING        set the safe-mode escape nonce\n   -nullvalue TEXT      set text string for NULL values. Default ''\n   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n   -quote               set output mode to 'quote'\n   -readonly            open the database read-only\n   -safe                enable safe-mode\n   -separator SEP       set output column separator. Default: '|'\n   -stats               print memory stats before each finalize\n   -table               set output mode to 'table'\n   -tabs                set output mode to 'tabs'\n   -version             show SQLite version\n   -vfs NAME            use NAME as the default VFS\n\0",
    )
};
unsafe extern "C" fn usage(mut showDetail: libc::c_int) {
    fprintf(
        stderr,
        b"Usage: %s [OPTIONS] FILENAME [SQL]\nFILENAME is the name of an SQLite database. A new database is created\nif the file does not previously exist.\n\0"
            as *const u8 as *const libc::c_char,
        Argv0,
    );
    if showDetail != 0 {
        fprintf(
            stderr,
            b"OPTIONS include:\n%s\0" as *const u8 as *const libc::c_char,
            zOptions.as_ptr(),
        );
    } else {
        fprintf(
            stderr,
            b"Use the -help option for additional information\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    exit(1 as libc::c_int);
}
unsafe extern "C" fn verify_uninitialized() {
    if sqlite3_config(-(1 as libc::c_int)) == 21 as libc::c_int {
        fprintf(
            stdout,
            b"WARNING: attempt to configure SQLite after initialization.\n\0"
                as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn main_init(mut data: *mut ShellState) {
    memset(
        data as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    (*data).mode = 2 as libc::c_int;
    (*data).cMode = (*data).mode;
    (*data).normalMode = (*data).cMode;
    (*data).autoExplain = 1 as libc::c_int as u8_0;
    (*data)
        .pAuxDb = &mut *((*data).aAuxDb).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut AuxDb;
    memcpy(
        ((*data).colSeparator).as_mut_ptr() as *mut libc::c_void,
        b"|\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    memcpy(
        ((*data).rowSeparator).as_mut_ptr() as *mut libc::c_void,
        b"\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    (*data).showHeader = 0 as libc::c_int;
    (*data).shellFlgs = 0x2 as libc::c_int as libc::c_uint;
    verify_uninitialized();
    sqlite3_config(17 as libc::c_int, 1 as libc::c_int);
    sqlite3_config(
        16 as libc::c_int,
        Some(
            shellLog
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *const libc::c_char,
                ) -> (),
        ),
        data,
    );
    sqlite3_config(2 as libc::c_int);
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        mainPrompt.as_mut_ptr(),
        b"sqlite> \0" as *const u8 as *const libc::c_char,
    );
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        continuePrompt.as_mut_ptr(),
        b"   ...> \0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn printBold(mut zText: *const libc::c_char) {
    printf(b"\x1B[1m%s\x1B[0m\0" as *const u8 as *const libc::c_char, zText);
}
unsafe extern "C" fn cmdline_option_value(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
    mut i: libc::c_int,
) -> *mut libc::c_char {
    if i == argc {
        fprintf(
            stderr,
            b"%s: Error: missing argument to %s\n\0" as *const u8 as *const libc::c_char,
            *argv.offset(0 as libc::c_int as isize),
            *argv.offset((argc - 1 as libc::c_int) as isize),
        );
        exit(1 as libc::c_int);
    }
    return *argv.offset(i as isize);
}
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data: ShellState = ShellState {
        db: 0 as *mut sqlite3,
        autoExplain: 0,
        autoEQP: 0,
        autoEQPtest: 0,
        autoEQPtrace: 0,
        scanstatsOn: 0,
        openMode: 0,
        doXdgOpen: 0,
        nEqpLevel: 0,
        eTraceType: 0,
        bSafeMode: 0,
        bSafeModePersist: 0,
        cmOpts: ColModeOpts {
            iWrap: 0,
            bQuote: 0,
            bWordWrap: 0,
        },
        statsOn: 0,
        mEqpLines: 0,
        inputNesting: 0,
        outCount: 0,
        cnt: 0,
        lineno: 0,
        openFlags: 0,
        in_0: 0 as *mut FILE,
        out: 0 as *mut FILE,
        traceOut: 0 as *mut FILE,
        nErr: 0,
        mode: 0,
        modePrior: 0,
        cMode: 0,
        normalMode: 0,
        writableSchema: 0,
        showHeader: 0,
        nCheck: 0,
        nProgress: 0,
        mxProgress: 0,
        flgProgress: 0,
        shellFlgs: 0,
        priorShFlgs: 0,
        szMax: 0,
        zDestTable: 0 as *mut libc::c_char,
        zTempFile: 0 as *mut libc::c_char,
        zTestcase: [0; 30],
        colSeparator: [0; 20],
        rowSeparator: [0; 20],
        colSepPrior: [0; 20],
        rowSepPrior: [0; 20],
        colWidth: 0 as *mut libc::c_int,
        actualWidth: 0 as *mut libc::c_int,
        nWidth: 0,
        nullValue: [0; 20],
        outfile: [0; 4096],
        pStmt: 0 as *mut sqlite3_stmt,
        pLog: 0 as *mut FILE,
        aAuxDb: [AuxDb {
            db: 0 as *mut sqlite3,
            zDbFilename: 0 as *const libc::c_char,
            zFreeOnClose: 0 as *mut libc::c_char,
        }; 5],
        pAuxDb: 0 as *mut AuxDb,
        aiIndent: 0 as *mut libc::c_int,
        nIndent: 0,
        iIndent: 0,
        zNonce: 0 as *mut libc::c_char,
        sGraph: EQPGraph {
            pRow: 0 as *mut EQPGraphRow,
            pLast: 0 as *mut EQPGraphRow,
            zPrefix: [0; 100],
        },
        expert: ExpertInfo {
            pExpert: 0 as *mut sqlite3expert,
            bVerbose: 0,
        },
    };
    let mut zInitFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut warnInmemoryDb: libc::c_int = 0 as libc::c_int;
    let mut readStdin: libc::c_int = 1 as libc::c_int;
    let mut nCmd: libc::c_int = 0 as libc::c_int;
    let mut azCmd: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
    setvbuf(
        stderr,
        0 as *mut libc::c_char,
        2 as libc::c_int,
        0 as libc::c_int as size_t,
    );
    stdin_is_interactive = isatty(0 as libc::c_int);
    stdout_is_console = isatty(1 as libc::c_int);
    if !(getenv(b"SQLITE_DEBUG_BREAK\0" as *const u8 as *const libc::c_char)).is_null() {
        if isatty(0 as libc::c_int) != 0 && isatty(2 as libc::c_int) != 0 {
            fprintf(
                stderr,
                b"attach debugger to process %d and press any key to continue.\n\0"
                    as *const u8 as *const libc::c_char,
                getpid(),
            );
            fgetc(stdin);
        } else {
            raise(5 as libc::c_int);
        }
    }
    if strncmp(
        sqlite3_sourceid(),
        b"2022-09-05 11:02:23 4635f4a69c8c2a8df242b384a992aea71224e39a2ccab42d8c0b0602f1e826e8\0"
            as *const u8 as *const libc::c_char,
        60 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        fprintf(
            stderr,
            b"SQLite header and source version mismatch\n%s\n%s\n\0" as *const u8
                as *const libc::c_char,
            sqlite3_sourceid(),
            b"2022-09-05 11:02:23 4635f4a69c8c2a8df242b384a992aea71224e39a2ccab42d8c0b0602f1e826e8\0"
                as *const u8 as *const libc::c_char,
        );
        exit(1 as libc::c_int);
    }
    main_init(&mut data);
    if argc >= 1 as libc::c_int && !argv.is_null()
        && !(*argv.offset(0 as libc::c_int as isize)).is_null()
    {} else {
        __assert_fail(
            b"argc>=1 && argv && argv[0]\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            23168 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 23],
                &[libc::c_char; 23],
            >(b"int main(int, char **)\0"))
                .as_ptr(),
        );
    }
    Argv0 = *argv.offset(0 as libc::c_int as isize);
    signal(
        2 as libc::c_int,
        Some(interrupt_handler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    verify_uninitialized();
    i = 1 as libc::c_int;
    while i < argc {
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        z = *argv.offset(i as isize);
        if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
            if ((*(data.aAuxDb).as_mut_ptr()).zDbFilename).is_null() {
                let ref mut fresh92 = (*(data.aAuxDb).as_mut_ptr()).zDbFilename;
                *fresh92 = z;
            } else {
                readStdin = 0 as libc::c_int;
                nCmd += 1;
                azCmd = realloc(
                    azCmd as *mut libc::c_void,
                    (::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                        .wrapping_mul(nCmd as libc::c_ulong),
                ) as *mut *mut libc::c_char;
                shell_check_oom(azCmd as *mut libc::c_void);
                let ref mut fresh93 = *azCmd.offset((nCmd - 1 as libc::c_int) as isize);
                *fresh93 = z;
            }
        }
        if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
            z = z.offset(1);
        }
        if strcmp(z, b"-separator\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
            || strcmp(z, b"-nullvalue\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            || strcmp(z, b"-newline\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            || strcmp(z, b"-cmd\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            i += 1;
            cmdline_option_value(argc, argv, i);
        } else if strcmp(z, b"-init\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            zInitFile = cmdline_option_value(argc, argv, i);
        } else if strcmp(z, b"-batch\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            stdin_is_interactive = 0 as libc::c_int;
        } else if strcmp(z, b"-heap\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            cmdline_option_value(argc, argv, i);
        } else if strcmp(z, b"-pagecache\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut n: sqlite3_int64 = 0;
            let mut sz: sqlite3_int64 = 0;
            i += 1;
            sz = integerValue(cmdline_option_value(argc, argv, i));
            if sz > 70000 as libc::c_int as libc::c_longlong {
                sz = 70000 as libc::c_int as sqlite3_int64;
            }
            if sz < 0 as libc::c_int as libc::c_longlong {
                sz = 0 as libc::c_int as sqlite3_int64;
            }
            i += 1;
            n = integerValue(cmdline_option_value(argc, argv, i));
            if sz > 0 as libc::c_int as libc::c_longlong
                && n > 0 as libc::c_int as libc::c_longlong
                && 0xffffffffffff as libc::c_longlong / sz < n
            {
                n = 0xffffffffffff as libc::c_longlong / sz;
            }
            sqlite3_config(
                7 as libc::c_int,
                if n > 0 as libc::c_int as libc::c_longlong
                    && sz > 0 as libc::c_int as libc::c_longlong
                {
                    malloc((n * sz) as libc::c_ulong)
                } else {
                    0 as *mut libc::c_void
                },
                sz,
                n,
            );
            data.shellFlgs |= 0x1 as libc::c_int as libc::c_uint;
        } else if strcmp(z, b"-lookaside\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut n_0: libc::c_int = 0;
            let mut sz_0: libc::c_int = 0;
            i += 1;
            sz_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
            if sz_0 < 0 as libc::c_int {
                sz_0 = 0 as libc::c_int;
            }
            i += 1;
            n_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
            if n_0 < 0 as libc::c_int {
                n_0 = 0 as libc::c_int;
            }
            sqlite3_config(13 as libc::c_int, sz_0, n_0);
            if sz_0 * n_0 == 0 as libc::c_int {
                data.shellFlgs &= !(0x2 as libc::c_int) as libc::c_uint;
            }
        } else if strcmp(z, b"-threadsafe\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut n_1: libc::c_int = 0;
            i += 1;
            n_1 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
            match n_1 {
                0 => {
                    sqlite3_config(1 as libc::c_int);
                }
                2 => {
                    sqlite3_config(2 as libc::c_int);
                }
                _ => {
                    sqlite3_config(3 as libc::c_int);
                }
            }
        } else if strcmp(z, b"-mmap\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            let mut sz_1: sqlite3_int64 = integerValue(
                cmdline_option_value(argc, argv, i),
            );
            sqlite3_config(22 as libc::c_int, sz_1, sz_1);
        } else if strcmp(z, b"-vfs\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            zVfs = cmdline_option_value(argc, argv, i);
        } else if strcmp(z, b"-append\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 2 as libc::c_int as u8_0;
        } else if strcmp(z, b"-deserialize\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 5 as libc::c_int as u8_0;
        } else if strcmp(z, b"-maxsize\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int && (i + 1 as libc::c_int) < argc
        {
            i += 1;
            data.szMax = integerValue(*argv.offset(i as isize));
        } else if strcmp(z, b"-readonly\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 4 as libc::c_int as u8_0;
        } else if strcmp(z, b"-nofollow\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openFlags = 0x1000000 as libc::c_int;
        } else if strcmp(z, b"-memtrace\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            sqlite3MemTraceActivate(stderr);
        } else if strcmp(z, b"-bail\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            bail_on_error = 1 as libc::c_int;
        } else if strcmp(z, b"-nonce\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            free(data.zNonce as *mut libc::c_void);
            i += 1;
            data.zNonce = strdup(*argv.offset(i as isize));
        } else {
            strcmp(z, b"-safe\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int;
        }
        i += 1;
    }
    verify_uninitialized();
    sqlite3_initialize();
    if !zVfs.is_null() {
        let mut pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(zVfs);
        if !pVfs.is_null() {
            sqlite3_vfs_register(pVfs, 1 as libc::c_int);
        } else {
            fprintf(
                stderr,
                b"no such VFS: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                *argv.offset(i as isize),
            );
            exit(1 as libc::c_int);
        }
    }
    if ((*data.pAuxDb).zDbFilename).is_null() {
        (*data.pAuxDb).zDbFilename = b":memory:\0" as *const u8 as *const libc::c_char;
        warnInmemoryDb = (argc == 1 as libc::c_int) as libc::c_int;
    }
    data.out = stdout;
    sqlite3_appendvfs_init(
        0 as *mut sqlite3,
        0 as *mut *mut libc::c_char,
        0 as *const sqlite3_api_routines,
    );
    if access((*data.pAuxDb).zDbFilename, 0 as libc::c_int) == 0 as libc::c_int {
        open_db(&mut data, 0 as libc::c_int);
    }
    process_sqliterc(&mut data, zInitFile);
    i = 1 as libc::c_int;
    while i < argc {
        let mut z_0: *mut libc::c_char = *argv.offset(i as isize);
        if !(*z_0.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32) {
            if *z_0.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_0 = z_0.offset(1);
            }
            if strcmp(z_0, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
            } else if strcmp(z_0, b"-html\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 4 as libc::c_int;
            } else if strcmp(z_0, b"-list\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 2 as libc::c_int;
            } else if strcmp(z_0, b"-quote\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 6 as libc::c_int;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b",\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            } else if strcmp(z_0, b"-line\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 0 as libc::c_int;
            } else if strcmp(z_0, b"-column\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 1 as libc::c_int;
            } else if strcmp(z_0, b"-json\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 13 as libc::c_int;
            } else if strcmp(z_0, b"-markdown\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 14 as libc::c_int;
            } else if strcmp(z_0, b"-table\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 15 as libc::c_int;
            } else if strcmp(z_0, b"-box\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 16 as libc::c_int;
            } else if strcmp(z_0, b"-csv\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 8 as libc::c_int;
                memcpy(
                    (data.colSeparator).as_mut_ptr() as *mut libc::c_void,
                    b",\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            } else if strcmp(z_0, b"-append\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 2 as libc::c_int as u8_0;
            } else if strcmp(z_0, b"-deserialize\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 5 as libc::c_int as u8_0;
            } else if strcmp(z_0, b"-maxsize\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && (i + 1 as libc::c_int) < argc
            {
                i += 1;
                data.szMax = integerValue(*argv.offset(i as isize));
            } else if strcmp(z_0, b"-readonly\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 4 as libc::c_int as u8_0;
            } else if strcmp(z_0, b"-nofollow\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openFlags |= 0x1000000 as libc::c_int;
            } else if strcmp(z_0, b"-ascii\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 10 as libc::c_int;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"\x1F\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\x1E\0" as *const u8 as *const libc::c_char,
                );
            } else if strcmp(z_0, b"-tabs\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 2 as libc::c_int;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"\t\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            } else if strcmp(z_0, b"-separator\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if strcmp(z_0, b"-newline\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if strcmp(z_0, b"-nullvalue\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.nullValue).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if strcmp(z_0, b"-header\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.showHeader = 1 as libc::c_int;
                data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
            } else if strcmp(z_0, b"-noheader\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.showHeader = 0 as libc::c_int;
                data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
            } else if strcmp(z_0, b"-echo\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.shellFlgs |= 0x40 as libc::c_int as libc::c_uint;
            } else if strcmp(z_0, b"-eqp\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.autoEQP = 1 as libc::c_int as u8_0;
            } else if strcmp(z_0, b"-eqpfull\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.autoEQP = 3 as libc::c_int as u8_0;
            } else if strcmp(z_0, b"-stats\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.statsOn = 1 as libc::c_int as libc::c_uint;
            } else if strcmp(z_0, b"-scanstats\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.scanstatsOn = 1 as libc::c_int as u8_0;
            } else if strcmp(z_0, b"-backslash\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.shellFlgs |= 0x4 as libc::c_int as libc::c_uint;
            } else if !(strcmp(z_0, b"-bail\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int)
            {
                if strcmp(z_0, b"-version\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    printf(
                        b"%s %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_libversion(),
                        sqlite3_sourceid(),
                    );
                    return 0 as libc::c_int;
                } else if strcmp(
                    z_0,
                    b"-interactive\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    stdin_is_interactive = 1 as libc::c_int;
                } else if strcmp(z_0, b"-batch\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    stdin_is_interactive = 0 as libc::c_int;
                } else if strcmp(z_0, b"-heap\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if strcmp(
                    z_0,
                    b"-pagecache\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if strcmp(
                    z_0,
                    b"-lookaside\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if strcmp(
                    z_0,
                    b"-threadsafe\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if strcmp(z_0, b"-nonce\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if strcmp(z_0, b"-mmap\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if strcmp(z_0, b"-memtrace\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if strcmp(z_0, b"-vfs\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if strcmp(z_0, b"-help\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    usage(1 as libc::c_int);
                } else if strcmp(z_0, b"-cmd\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    if i == argc - 1 as libc::c_int {
                        break;
                    }
                    i += 1;
                    z_0 = cmdline_option_value(argc, argv, i);
                    if *z_0.offset(0 as libc::c_int as isize) as libc::c_int
                        == '.' as i32
                    {
                        rc = do_meta_command(z_0, &mut data);
                        if rc != 0 && bail_on_error != 0 {
                            return if rc == 2 as libc::c_int {
                                0 as libc::c_int
                            } else {
                                rc
                            };
                        }
                    } else {
                        open_db(&mut data, 0 as libc::c_int);
                        rc = shell_exec(&mut data, z_0, &mut zErrMsg);
                        if !zErrMsg.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                zErrMsg,
                            );
                            if bail_on_error != 0 {
                                return if rc != 0 as libc::c_int {
                                    rc
                                } else {
                                    1 as libc::c_int
                                };
                            }
                        } else if rc != 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: unable to process SQL \"%s\"\n\0" as *const u8
                                    as *const libc::c_char,
                                z_0,
                            );
                            if bail_on_error != 0 {
                                return rc;
                            }
                        }
                    }
                } else if strcmp(z_0, b"-safe\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.bSafeModePersist = 1 as libc::c_int as u8_0;
                    data.bSafeMode = data.bSafeModePersist;
                } else {
                    fprintf(
                        stderr,
                        b"%s: Error: unknown option: %s\n\0" as *const u8
                            as *const libc::c_char,
                        Argv0,
                        z_0,
                    );
                    fprintf(
                        stderr,
                        b"Use -help for a list of options.\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                }
            }
            data.cMode = data.mode;
        }
        i += 1;
    }
    if readStdin == 0 {
        i = 0 as libc::c_int;
        while i < nCmd {
            if *(*azCmd.offset(i as isize)).offset(0 as libc::c_int as isize)
                as libc::c_int == '.' as i32
            {
                rc = do_meta_command(*azCmd.offset(i as isize), &mut data);
                if rc != 0 {
                    free(azCmd as *mut libc::c_void);
                    return if rc == 2 as libc::c_int { 0 as libc::c_int } else { rc };
                }
            } else {
                open_db(&mut data, 0 as libc::c_int);
                rc = shell_exec(&mut data, *azCmd.offset(i as isize), &mut zErrMsg);
                if !zErrMsg.is_null() || rc != 0 {
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                            zErrMsg,
                        );
                    } else {
                        fprintf(
                            stderr,
                            b"Error: unable to process SQL: %s\n\0" as *const u8
                                as *const libc::c_char,
                            *azCmd.offset(i as isize),
                        );
                    }
                    sqlite3_free(zErrMsg as *mut libc::c_void);
                    free(azCmd as *mut libc::c_void);
                    return if rc != 0 as libc::c_int { rc } else { 1 as libc::c_int };
                }
            }
            i += 1;
        }
    } else if stdin_is_interactive != 0 {
        let mut zHome: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zHistory: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut nHistory: libc::c_int = 0;
        printf(
            b"SQLite version %s %.19s\nEnter \".help\" for usage hints.\n\0" as *const u8
                as *const libc::c_char,
            sqlite3_libversion(),
            sqlite3_sourceid(),
        );
        if warnInmemoryDb != 0 {
            printf(b"Connected to a \0" as *const u8 as *const libc::c_char);
            printBold(
                b"transient in-memory database\0" as *const u8 as *const libc::c_char,
            );
            printf(
                b".\nUse \".open FILENAME\" to reopen on a persistent database.\n\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        zHistory = getenv(b"SQLITE_HISTORY\0" as *const u8 as *const libc::c_char);
        if !zHistory.is_null() {
            zHistory = strdup(zHistory);
        } else {
            zHome = find_home_dir(0 as libc::c_int);
            if !zHome.is_null() {
                nHistory = strlen30(zHome) + 20 as libc::c_int;
                zHistory = malloc(nHistory as libc::c_ulong) as *mut libc::c_char;
                if !zHistory.is_null() {
                    sqlite3_snprintf(
                        nHistory,
                        zHistory,
                        b"%s/.sqlite_history\0" as *const u8 as *const libc::c_char,
                        zHome,
                    );
                }
            }
        }
        !zHistory.is_null();
        data.in_0 = 0 as *mut FILE;
        rc = process_input(&mut data);
        if !zHistory.is_null() {
            free(zHistory as *mut libc::c_void);
        }
    } else {
        data.in_0 = stdin;
        rc = process_input(&mut data);
    }
    free(azCmd as *mut libc::c_void);
    set_table_name(&mut data, 0 as *const libc::c_char);
    if !(data.db).is_null() {
        close_db(data.db);
    }
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
            as libc::c_int
    {
        sqlite3_free(data.aAuxDb[i as usize].zFreeOnClose as *mut libc::c_void);
        if !(data.aAuxDb[i as usize].db).is_null() {
            close_db(data.aAuxDb[i as usize].db);
        }
        i += 1;
    }
    find_home_dir(1 as libc::c_int);
    output_reset(&mut data);
    data.doXdgOpen = 0 as libc::c_int as u8_0;
    clearTempFile(&mut data);
    free(data.colWidth as *mut libc::c_void);
    free(data.zNonce as *mut libc::c_void);
    memset(
        &mut data as *mut ShellState as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    return rc;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::core::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
